import {
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  Controls,
  CylinderGeometry,
  DepthFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  EdgesGeometry,
  Euler,
  Float32BufferAttribute,
  FrontSide,
  Group,
  InstancedBufferAttribute,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  NearestFilter,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderLib,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  Uint8BufferAttribute,
  UniformsLib,
  UniformsUtils,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-YM4YKUOR.js";
import {
  FILE_DESCRIPTION,
  FILE_NAME,
  Handle,
  IFC4,
  IFCBRIDGE,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCCLASSIFICATION,
  IFCCLASSIFICATIONREFERENCE,
  IFCCOMPLEXPROPERTY,
  IFCELEMENTQUANTITY,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPHYSICALCOMPLEXQUANTITY,
  IFCPROJECT,
  IFCPROPERTYENUMERATEDVALUE,
  IFCPROPERTYLISTVALUE,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOCONTROL,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSIGNSTOPRODUCT,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESDOCUMENT,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONNECTSELEMENTS,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDECLARES,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCRELFLOWCONTROLELEMENTS,
  IFCRELNESTS,
  IFCROAD,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  LogLevel,
  Schemas,
  web_ifc_api_exports
} from "./chunk-OQBFOM3L.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@thatopen/fragments/dist/index.mjs
var t = Object.defineProperty;
var e = (e2, s, i) => (((e3, s2, i2) => {
  s2 in e3 ? t(e3, s2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e3[s2] = i2;
})(e2, "symbol" != typeof s ? s + "" : s, i), i);
var U = new Int32Array(2);
var D = new Float32Array(U.buffer);
var V = new Float64Array(U.buffer);
var B = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0];
var G;
var z;
(z = G || (G = {}))[z.UTF8_BYTES = 1] = "UTF8_BYTES", z[z.UTF16_STRING = 2] = "UTF16_STRING";
var Y = class _Y {
  constructor(t15) {
    this.bytes_ = t15, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  static allocate(t15) {
    return new _Y(new Uint8Array(t15));
  }
  clear() {
    this.position_ = 0;
  }
  bytes() {
    return this.bytes_;
  }
  position() {
    return this.position_;
  }
  setPosition(t15) {
    this.position_ = t15;
  }
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t15) {
    return this.readUint8(t15) << 24 >> 24;
  }
  readUint8(t15) {
    return this.bytes_[t15];
  }
  readInt16(t15) {
    return this.readUint16(t15) << 16 >> 16;
  }
  readUint16(t15) {
    return this.bytes_[t15] | this.bytes_[t15 + 1] << 8;
  }
  readInt32(t15) {
    return this.bytes_[t15] | this.bytes_[t15 + 1] << 8 | this.bytes_[t15 + 2] << 16 | this.bytes_[t15 + 3] << 24;
  }
  readUint32(t15) {
    return this.readInt32(t15) >>> 0;
  }
  readInt64(t15) {
    return BigInt.asIntN(64, BigInt(this.readUint32(t15)) + (BigInt(this.readUint32(t15 + 4)) << BigInt(32)));
  }
  readUint64(t15) {
    return BigInt.asUintN(64, BigInt(this.readUint32(t15)) + (BigInt(this.readUint32(t15 + 4)) << BigInt(32)));
  }
  readFloat32(t15) {
    return U[0] = this.readInt32(t15), D[0];
  }
  readFloat64(t15) {
    return U[B ? 0 : 1] = this.readInt32(t15), U[B ? 1 : 0] = this.readInt32(t15 + 4), V[0];
  }
  writeInt8(t15, e2) {
    this.bytes_[t15] = e2;
  }
  writeUint8(t15, e2) {
    this.bytes_[t15] = e2;
  }
  writeInt16(t15, e2) {
    this.bytes_[t15] = e2, this.bytes_[t15 + 1] = e2 >> 8;
  }
  writeUint16(t15, e2) {
    this.bytes_[t15] = e2, this.bytes_[t15 + 1] = e2 >> 8;
  }
  writeInt32(t15, e2) {
    this.bytes_[t15] = e2, this.bytes_[t15 + 1] = e2 >> 8, this.bytes_[t15 + 2] = e2 >> 16, this.bytes_[t15 + 3] = e2 >> 24;
  }
  writeUint32(t15, e2) {
    this.bytes_[t15] = e2, this.bytes_[t15 + 1] = e2 >> 8, this.bytes_[t15 + 2] = e2 >> 16, this.bytes_[t15 + 3] = e2 >> 24;
  }
  writeInt64(t15, e2) {
    this.writeInt32(t15, Number(BigInt.asIntN(32, e2))), this.writeInt32(t15 + 4, Number(BigInt.asIntN(32, e2 >> BigInt(32))));
  }
  writeUint64(t15, e2) {
    this.writeUint32(t15, Number(BigInt.asUintN(32, e2))), this.writeUint32(t15 + 4, Number(BigInt.asUintN(32, e2 >> BigInt(32))));
  }
  writeFloat32(t15, e2) {
    D[0] = e2, this.writeInt32(t15, U[0]);
  }
  writeFloat64(t15, e2) {
    V[0] = e2, this.writeInt32(t15, U[B ? 0 : 1]), this.writeInt32(t15 + 4, U[B ? 1 : 0]);
  }
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + 4 + 4) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t15 = "";
    for (let e2 = 0; e2 < 4; e2++) t15 += String.fromCharCode(this.readInt8(this.position_ + 4 + e2));
    return t15;
  }
  __offset(t15, e2) {
    const s = t15 - this.readInt32(t15);
    return e2 < this.readInt16(s) ? this.readInt16(s + e2) : 0;
  }
  __union(t15, e2) {
    return t15.bb_pos = e2 + this.readInt32(e2), t15.bb = this, t15;
  }
  __string(t15, e2) {
    t15 += this.readInt32(t15);
    const s = this.readInt32(t15);
    t15 += 4;
    const i = this.bytes_.subarray(t15, t15 + s);
    return e2 === G.UTF8_BYTES ? i : this.text_decoder_.decode(i);
  }
  __union_with_string(t15, e2) {
    return "string" == typeof t15 ? this.__string(e2) : this.__union(t15, e2);
  }
  __indirect(t15) {
    return t15 + this.readInt32(t15);
  }
  __vector(t15) {
    return t15 + this.readInt32(t15) + 4;
  }
  __vector_len(t15) {
    return this.readInt32(t15 + this.readInt32(t15));
  }
  __has_identifier(t15) {
    if (4 != t15.length) throw new Error("FlatBuffers: file identifier must be length 4");
    for (let e2 = 0; e2 < 4; e2++) if (t15.charCodeAt(e2) != this.readInt8(this.position() + 4 + e2)) return false;
    return true;
  }
  createScalarList(t15, e2) {
    const s = [];
    for (let i = 0; i < e2; ++i) {
      const e3 = t15(i);
      null !== e3 && s.push(e3);
    }
    return s;
  }
  createObjList(t15, e2) {
    const s = [];
    for (let i = 0; i < e2; ++i) {
      const e3 = t15(i);
      null !== e3 && s.push(e3.unpack());
    }
    return s;
  }
};
var H = class _H {
  constructor(t15) {
    let e2;
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false, this.string_maps = null, this.text_encoder = new TextEncoder(), e2 = t15 || 1024, this.bb = Y.allocate(e2), this.space = e2;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false, this.string_maps = null;
  }
  forceDefaults(t15) {
    this.force_defaults = t15;
  }
  dataBuffer() {
    return this.bb;
  }
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  prep(t15, e2) {
    t15 > this.minalign && (this.minalign = t15);
    const s = 1 + ~(this.bb.capacity() - this.space + e2) & t15 - 1;
    for (; this.space < s + t15 + e2; ) {
      const t16 = this.bb.capacity();
      this.bb = _H.growByteBuffer(this.bb), this.space += this.bb.capacity() - t16;
    }
    this.pad(s);
  }
  pad(t15) {
    for (let e2 = 0; e2 < t15; e2++) this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t15) {
    this.bb.writeInt8(this.space -= 1, t15);
  }
  writeInt16(t15) {
    this.bb.writeInt16(this.space -= 2, t15);
  }
  writeInt32(t15) {
    this.bb.writeInt32(this.space -= 4, t15);
  }
  writeInt64(t15) {
    this.bb.writeInt64(this.space -= 8, t15);
  }
  writeFloat32(t15) {
    this.bb.writeFloat32(this.space -= 4, t15);
  }
  writeFloat64(t15) {
    this.bb.writeFloat64(this.space -= 8, t15);
  }
  addInt8(t15) {
    this.prep(1, 0), this.writeInt8(t15);
  }
  addInt16(t15) {
    this.prep(2, 0), this.writeInt16(t15);
  }
  addInt32(t15) {
    this.prep(4, 0), this.writeInt32(t15);
  }
  addInt64(t15) {
    this.prep(8, 0), this.writeInt64(t15);
  }
  addFloat32(t15) {
    this.prep(4, 0), this.writeFloat32(t15);
  }
  addFloat64(t15) {
    this.prep(8, 0), this.writeFloat64(t15);
  }
  addFieldInt8(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addInt8(e2), this.slot(t15));
  }
  addFieldInt16(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addInt16(e2), this.slot(t15));
  }
  addFieldInt32(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addInt32(e2), this.slot(t15));
  }
  addFieldInt64(t15, e2, s) {
    (this.force_defaults || e2 !== s) && (this.addInt64(e2), this.slot(t15));
  }
  addFieldFloat32(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addFloat32(e2), this.slot(t15));
  }
  addFieldFloat64(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addFloat64(e2), this.slot(t15));
  }
  addFieldOffset(t15, e2, s) {
    (this.force_defaults || e2 != s) && (this.addOffset(e2), this.slot(t15));
  }
  addFieldStruct(t15, e2, s) {
    e2 != s && (this.nested(e2), this.slot(t15));
  }
  nested(t15) {
    if (t15 != this.offset()) throw new TypeError("FlatBuffers: struct must be serialized inline.");
  }
  notNested() {
    if (this.isNested) throw new TypeError("FlatBuffers: object serialization must not be nested.");
  }
  slot(t15) {
    null !== this.vtable && (this.vtable[t15] = this.offset());
  }
  offset() {
    return this.bb.capacity() - this.space;
  }
  static growByteBuffer(t15) {
    const e2 = t15.capacity();
    if (3221225472 & e2) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const s = e2 << 1, i = Y.allocate(s);
    return i.setPosition(s - e2), i.bytes().set(t15.bytes(), s - e2), i;
  }
  addOffset(t15) {
    this.prep(4, 0), this.writeInt32(this.offset() - t15 + 4);
  }
  startObject(t15) {
    this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t15;
    for (let e2 = 0; e2 < t15; e2++) this.vtable[e2] = 0;
    this.isNested = true, this.object_start = this.offset();
  }
  endObject() {
    if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t15 = this.offset();
    let e2 = this.vtable_in_use - 1;
    for (; e2 >= 0 && 0 == this.vtable[e2]; e2--) ;
    const s = e2 + 1;
    for (; e2 >= 0; e2--) this.addInt16(0 != this.vtable[e2] ? t15 - this.vtable[e2] : 0);
    this.addInt16(t15 - this.object_start);
    const i = 2 * (s + 2);
    this.addInt16(i);
    let r = 0;
    const n = this.space;
    t: for (e2 = 0; e2 < this.vtables.length; e2++) {
      const t16 = this.bb.capacity() - this.vtables[e2];
      if (i == this.bb.readInt16(t16)) {
        for (let e3 = 2; e3 < i; e3 += 2) if (this.bb.readInt16(n + e3) != this.bb.readInt16(t16 + e3)) continue t;
        r = this.vtables[e2];
        break;
      }
    }
    return r ? (this.space = this.bb.capacity() - t15, this.bb.writeInt32(this.space, r - t15)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t15, this.offset() - t15)), this.isNested = false, t15;
  }
  finish(t15, e2, s) {
    const i = s ? 4 : 0;
    if (e2) {
      const t16 = e2;
      if (this.prep(this.minalign, 8 + i), 4 != t16.length) throw new TypeError("FlatBuffers: file identifier must be length 4");
      for (let e3 = 3; e3 >= 0; e3--) this.writeInt8(t16.charCodeAt(e3));
    }
    this.prep(this.minalign, 4 + i), this.addOffset(t15), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  finishSizePrefixed(t15, e2) {
    this.finish(t15, e2, true);
  }
  requiredField(t15, e2) {
    const s = this.bb.capacity() - t15, i = s - this.bb.readInt32(s);
    if (!(e2 < this.bb.readInt16(i) && 0 != this.bb.readInt16(i + e2))) throw new TypeError("FlatBuffers: field " + e2 + " must be set");
  }
  startVector(t15, e2, s) {
    this.notNested(), this.vector_num_elems = e2, this.prep(4, t15 * e2), this.prep(s, t15 * e2);
  }
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  createSharedString(t15) {
    if (!t15) return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t15)) return this.string_maps.get(t15);
    const e2 = this.createString(t15);
    return this.string_maps.set(t15, e2), e2;
  }
  createString(t15) {
    if (null == t15) return 0;
    let e2;
    return e2 = t15 instanceof Uint8Array ? t15 : this.text_encoder.encode(t15), this.addInt8(0), this.startVector(1, e2.length, 1), this.bb.setPosition(this.space -= e2.length), this.bb.bytes().set(e2, this.space), this.endVector();
  }
  createByteVector(t15) {
    return null == t15 ? 0 : (this.startVector(1, t15.length, 1), this.bb.setPosition(this.space -= t15.length), this.bb.bytes().set(t15, this.space), this.endVector());
  }
  createObjectOffset(t15) {
    return null === t15 ? 0 : "string" == typeof t15 ? this.createString(t15) : t15.pack(this);
  }
  createObjectOffsetList(t15) {
    const e2 = [];
    for (let s = 0; s < t15.length; ++s) {
      const i = t15[s];
      if (null === i) throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      e2.push(this.createObjectOffset(i));
    }
    return e2;
  }
  createStructOffsetList(t15, e2) {
    return e2(this, t15.length), this.createObjectOffsetList(t15.slice().reverse()), this.endVector();
  }
};
var j = class {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  x() {
    return this.bb.readFloat32(this.bb_pos);
  }
  mutate_x(t15) {
    return this.bb.writeFloat32(this.bb_pos + 0, t15), true;
  }
  y() {
    return this.bb.readFloat32(this.bb_pos + 4);
  }
  mutate_y(t15) {
    return this.bb.writeFloat32(this.bb_pos + 4, t15), true;
  }
  z() {
    return this.bb.readFloat32(this.bb_pos + 8);
  }
  mutate_z(t15) {
    return this.bb.writeFloat32(this.bb_pos + 8, t15), true;
  }
  static sizeOf() {
    return 12;
  }
  static createFloatVector(t15, e2, s, i) {
    return t15.prep(4, 12), t15.writeFloat32(i), t15.writeFloat32(s), t15.writeFloat32(e2), t15.offset();
  }
};
var $ = ((t15) => (t15[t15.NONE = 0] = "NONE", t15[t15.WIRE = 1] = "WIRE", t15[t15.WIRE_SET = 2] = "WIRE_SET", t15[t15.CIRCLE_CURVE = 3] = "CIRCLE_CURVE", t15))($ || {});
var Q = class {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  min(t15) {
    return (t15 || new j()).__init(this.bb_pos, this.bb);
  }
  max(t15) {
    return (t15 || new j()).__init(this.bb_pos + 12, this.bb);
  }
  static sizeOf() {
    return 24;
  }
  static createBoundingBox(t15, e2, s, i, r, n, o) {
    return t15.prep(4, 24), t15.prep(4, 12), t15.writeFloat32(o), t15.writeFloat32(n), t15.writeFloat32(r), t15.prep(4, 12), t15.writeFloat32(i), t15.writeFloat32(s), t15.writeFloat32(e2), t15.offset();
  }
};
var tt = class {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  x() {
    return this.bb.readFloat64(this.bb_pos);
  }
  mutate_x(t15) {
    return this.bb.writeFloat64(this.bb_pos + 0, t15), true;
  }
  y() {
    return this.bb.readFloat64(this.bb_pos + 8);
  }
  mutate_y(t15) {
    return this.bb.writeFloat64(this.bb_pos + 8, t15), true;
  }
  z() {
    return this.bb.readFloat64(this.bb_pos + 16);
  }
  mutate_z(t15) {
    return this.bb.writeFloat64(this.bb_pos + 16, t15), true;
  }
  static sizeOf() {
    return 24;
  }
  static createDoubleVector(t15, e2, s, i) {
    return t15.prep(8, 24), t15.writeFloat64(i), t15.writeFloat64(s), t15.writeFloat64(e2), t15.offset();
  }
};
var it = class {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  position(t15) {
    return (t15 || new tt()).__init(this.bb_pos, this.bb);
  }
  xDirection(t15) {
    return (t15 || new j()).__init(this.bb_pos + 24, this.bb);
  }
  yDirection(t15) {
    return (t15 || new j()).__init(this.bb_pos + 36, this.bb);
  }
  static sizeOf() {
    return 48;
  }
  static createTransform(t15, e2, s, i, r, n, o, a, c, h) {
    return t15.prep(8, 48), t15.prep(4, 12), t15.writeFloat32(h), t15.writeFloat32(c), t15.writeFloat32(a), t15.prep(4, 12), t15.writeFloat32(o), t15.writeFloat32(n), t15.writeFloat32(r), t15.prep(8, 24), t15.writeFloat64(i), t15.writeFloat64(s), t15.writeFloat64(e2), t15.offset();
  }
};
var nt = ((t15) => (t15[t15.NONE = 0] = "NONE", t15[t15.LINES = 1] = "LINES", t15[t15.ELLIPSE_ARC = 2] = "ELLIPSE_ARC", t15[t15.CLOTHOID = 3] = "CLOTHOID", t15[t15.PARABOLA = 4] = "PARABOLA", t15))(nt || {});
var _t = ((t15) => (t15[t15.ONE = 0] = "ONE", t15[t15.TWO = 1] = "TWO", t15))(_t || {});
var Et = ((t15) => (t15[t15.NONE = 0] = "NONE", t15[t15.SHELL = 1] = "SHELL", t15[t15.CIRCLE_EXTRUSION = 2] = "CIRCLE_EXTRUSION", t15))(Et || {});
var pt = ((t15) => (t15[t15.DEFAULT = 0] = "DEFAULT", t15))(pt || {});
var mt = ((t15) => (t15[t15.LINE = 0] = "LINE", t15[t15.SHELL = 1] = "SHELL", t15))(mt || {});
var gt = ((t15) => (t15[t15.UPDATE = 0] = "UPDATE", t15[t15.CREATE = 1] = "CREATE", t15[t15.DELETE = 2] = "DELETE", t15[t15.FINISH = 3] = "FINISH", t15))(gt || {});
var Tt = ((t15) => (t15[t15.GEOMETRY = 0] = "GEOMETRY", t15[t15.WIRES = 1] = "WIRES", t15[t15.INVISIBLE = 2] = "INVISIBLE", t15))(Tt || {});
var At = ((t15) => (t15[t15.CREATE_MODEL = 0] = "CREATE_MODEL", t15[t15.DELETE_MODEL = 1] = "DELETE_MODEL", t15[t15.EXECUTE = 2] = "EXECUTE", t15[t15.RAYCAST = 3] = "RAYCAST", t15[t15.FETCH_BOXES = 4] = "FETCH_BOXES", t15[t15.REFRESH_VIEW = 5] = "REFRESH_VIEW", t15[t15.RECOMPUTE_MESHES = 6] = "RECOMPUTE_MESHES", t15[t15.CREATE_MATERIAL = 7] = "CREATE_MATERIAL", t15[t15.THROW_ERROR = 8] = "THROW_ERROR", t15))(At || {});
var Ft = ((t15) => (t15[t15.VISIBLE = 0] = "VISIBLE", t15))(Ft || {});
var Rt = ((t15) => (t15[t15.POINT = 0] = "POINT", t15[t15.LINE = 1] = "LINE", t15[t15.FACE = 2] = "FACE", t15))(Rt || {});
var yt = class {
  static containedInParallelPlanes(t15, e2) {
    let s = true;
    for (const i of t15) {
      const t16 = i.distanceToPoint(e2);
      s = s && t16 >= 0;
    }
    return s;
  }
  static collides(t15, e2, s) {
    for (const i of e2) {
      if (this.getPointDistance(i, s, t15) < 0) return false;
    }
    return true;
  }
  static getPointDistance(t15, e2, s) {
    const i = t15.normal;
    for (const t16 of this.dimensions) {
      const r = i[t16] >= 0 !== e2;
      this.tempPoint[t16] = r ? s.max[t16] : s.min[t16];
    }
    return t15.distanceToPoint(this.tempPoint);
  }
};
e(yt, "tempPoint", new Vector3()), e(yt, "dimensions", ["x", "y", "z"]);
var St = { exports: {} };
function wt(t15, e2, s) {
  s = s || 2;
  var i, r, n, o, a, c, h, l = e2 && e2.length, d = l ? e2[0] * s : t15.length, b = Nt(t15, 0, d, s, true), u = [];
  if (!b || b.next === b.prev) return u;
  if (l && (b = function(t16, e3, s2, i2) {
    var r2, n2, o2, a2 = [];
    for (r2 = 0, n2 = e3.length; r2 < n2; r2++) (o2 = Nt(t16, e3[r2] * i2, r2 < n2 - 1 ? e3[r2 + 1] * i2 : t16.length, i2, false)) === o2.next && (o2.steiner = true), a2.push(zt(o2));
    for (a2.sort(Dt), r2 = 0; r2 < a2.length; r2++) s2 = Vt(a2[r2], s2);
    return s2;
  }(t15, e2, b, s)), t15.length > 80 * s) {
    i = n = t15[0], r = o = t15[1];
    for (var I = s; I < d; I += s) (a = t15[I]) < i && (i = a), (c = t15[I + 1]) < r && (r = c), a > n && (n = a), c > o && (o = c);
    h = 0 !== (h = Math.max(n - i, o - r)) ? 32767 / h : 0;
  }
  return vt(b, u, s, i, r, h, 0), u;
}
function Nt(t15, e2, s, i, r) {
  var n, o;
  if (r === te(t15, e2, s, i) > 0) for (n = e2; n < s; n += i) o = $t(n, t15[n], t15[n + 1], o);
  else for (n = s - i; n >= e2; n -= i) o = $t(n, t15[n], t15[n + 1], o);
  return o && Wt(o, o.next) && (Qt(o), o = o.next), o;
}
function Lt(t15, e2) {
  if (!t15) return t15;
  e2 || (e2 = t15);
  var s, i = t15;
  do {
    if (s = false, i.steiner || !Wt(i, i.next) && 0 !== kt(i.prev, i, i.next)) i = i.next;
    else {
      if (Qt(i), (i = e2 = i.prev) === i.next) break;
      s = true;
    }
  } while (s || i !== e2);
  return e2;
}
function vt(t15, e2, s, i, r, n, o) {
  if (t15) {
    !o && n && function(t16, e3, s2, i2) {
      var r2 = t16;
      do {
        0 === r2.z && (r2.z = Gt(r2.x, r2.y, e3, s2, i2)), r2.prevZ = r2.prev, r2.nextZ = r2.next, r2 = r2.next;
      } while (r2 !== t16);
      r2.prevZ.nextZ = null, r2.prevZ = null, function(t17) {
        var e4, s3, i3, r3, n2, o2, a2, c2, h2 = 1;
        do {
          for (s3 = t17, t17 = null, n2 = null, o2 = 0; s3; ) {
            for (o2++, i3 = s3, a2 = 0, e4 = 0; e4 < h2 && (a2++, i3 = i3.nextZ); e4++) ;
            for (c2 = h2; a2 > 0 || c2 > 0 && i3; ) 0 !== a2 && (0 === c2 || !i3 || s3.z <= i3.z) ? (r3 = s3, s3 = s3.nextZ, a2--) : (r3 = i3, i3 = i3.nextZ, c2--), n2 ? n2.nextZ = r3 : t17 = r3, r3.prevZ = n2, n2 = r3;
            s3 = i3;
          }
          n2.nextZ = null, h2 *= 2;
        } while (o2 > 1);
      }(r2);
    }(t15, i, r, n);
    for (var a, c, h = t15; t15.prev !== t15.next; ) if (a = t15.prev, c = t15.next, n ? Pt(t15, i, r, n) : Mt(t15)) e2.push(a.i / s | 0), e2.push(t15.i / s | 0), e2.push(c.i / s | 0), Qt(t15), t15 = c.next, h = c.next;
    else if ((t15 = c) === h) {
      o ? 1 === o ? vt(t15 = xt(Lt(t15), e2, s), e2, s, i, r, n, 2) : 2 === o && Ut(t15, e2, s, i, r, n) : vt(Lt(t15), e2, s, i, r, n, 1);
      break;
    }
  }
}
function Mt(t15) {
  var e2 = t15.prev, s = t15, i = t15.next;
  if (kt(e2, s, i) >= 0) return false;
  for (var r = e2.x, n = s.x, o = i.x, a = e2.y, c = s.y, h = i.y, l = r < n ? r < o ? r : o : n < o ? n : o, d = a < c ? a < h ? a : h : c < h ? c : h, b = r > n ? r > o ? r : o : n > o ? n : o, u = a > c ? a > h ? a : h : c > h ? c : h, I = i.next; I !== e2; ) {
    if (I.x >= l && I.x <= b && I.y >= d && I.y <= u && Yt(r, a, n, c, o, h, I.x, I.y) && kt(I.prev, I, I.next) >= 0) return false;
    I = I.next;
  }
  return true;
}
function Pt(t15, e2, s, i) {
  var r = t15.prev, n = t15, o = t15.next;
  if (kt(r, n, o) >= 0) return false;
  for (var a = r.x, c = n.x, h = o.x, l = r.y, d = n.y, b = o.y, u = a < c ? a < h ? a : h : c < h ? c : h, I = l < d ? l < b ? l : b : d < b ? d : b, f = a > c ? a > h ? a : h : c > h ? c : h, _ = l > d ? l > b ? l : b : d > b ? d : b, E = Gt(u, I, e2, s, i), p = Gt(f, _, e2, s, i), C = t15.prevZ, m = t15.nextZ; C && C.z >= E && m && m.z <= p; ) {
    if (C.x >= u && C.x <= f && C.y >= I && C.y <= _ && C !== r && C !== o && Yt(a, l, c, d, h, b, C.x, C.y) && kt(C.prev, C, C.next) >= 0) return false;
    if (C = C.prevZ, m.x >= u && m.x <= f && m.y >= I && m.y <= _ && m !== r && m !== o && Yt(a, l, c, d, h, b, m.x, m.y) && kt(m.prev, m, m.next) >= 0) return false;
    m = m.nextZ;
  }
  for (; C && C.z >= E; ) {
    if (C.x >= u && C.x <= f && C.y >= I && C.y <= _ && C !== r && C !== o && Yt(a, l, c, d, h, b, C.x, C.y) && kt(C.prev, C, C.next) >= 0) return false;
    C = C.prevZ;
  }
  for (; m && m.z <= p; ) {
    if (m.x >= u && m.x <= f && m.y >= I && m.y <= _ && m !== r && m !== o && Yt(a, l, c, d, h, b, m.x, m.y) && kt(m.prev, m, m.next) >= 0) return false;
    m = m.nextZ;
  }
  return true;
}
function xt(t15, e2, s) {
  var i = t15;
  do {
    var r = i.prev, n = i.next.next;
    !Wt(r, n) && jt(r, i, i.next, n) && Zt(r, n) && Zt(n, r) && (e2.push(r.i / s | 0), e2.push(i.i / s | 0), e2.push(n.i / s | 0), Qt(i), Qt(i.next), i = t15 = n), i = i.next;
  } while (i !== t15);
  return Lt(i);
}
function Ut(t15, e2, s, i, r, n) {
  var o = t15;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && Ht(o, a)) {
        var c = Kt(o, a);
        return o = Lt(o, o.next), c = Lt(c, c.next), vt(o, e2, s, i, r, n, 0), void vt(c, e2, s, i, r, n, 0);
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== t15);
}
function Dt(t15, e2) {
  return t15.x - e2.x;
}
function Vt(t15, e2) {
  var s = function(t16, e3) {
    var s2, i2 = e3, r = t16.x, n = t16.y, o = -1 / 0;
    do {
      if (n <= i2.y && n >= i2.next.y && i2.next.y !== i2.y) {
        var a = i2.x + (n - i2.y) * (i2.next.x - i2.x) / (i2.next.y - i2.y);
        if (a <= r && a > o && (o = a, s2 = i2.x < i2.next.x ? i2 : i2.next, a === r)) return s2;
      }
      i2 = i2.next;
    } while (i2 !== e3);
    if (!s2) return null;
    var c, h = s2, l = s2.x, d = s2.y, b = 1 / 0;
    i2 = s2;
    do {
      r >= i2.x && i2.x >= l && r !== i2.x && Yt(n < d ? r : o, n, l, d, n < d ? o : r, n, i2.x, i2.y) && (c = Math.abs(n - i2.y) / (r - i2.x), Zt(i2, t16) && (c < b || c === b && (i2.x > s2.x || i2.x === s2.x && Bt(s2, i2))) && (s2 = i2, b = c)), i2 = i2.next;
    } while (i2 !== h);
    return s2;
  }(t15, e2);
  if (!s) return e2;
  var i = Kt(s, t15);
  return Lt(i, i.next), Lt(s, s.next);
}
function Bt(t15, e2) {
  return kt(t15.prev, t15, e2.prev) < 0 && kt(e2.next, t15, t15.next) < 0;
}
function Gt(t15, e2, s, i, r) {
  return (t15 = 1431655765 & ((t15 = 858993459 & ((t15 = 252645135 & ((t15 = 16711935 & ((t15 = (t15 - s) * r | 0) | t15 << 8)) | t15 << 4)) | t15 << 2)) | t15 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - i) * r | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
}
function zt(t15) {
  var e2 = t15, s = t15;
  do {
    (e2.x < s.x || e2.x === s.x && e2.y < s.y) && (s = e2), e2 = e2.next;
  } while (e2 !== t15);
  return s;
}
function Yt(t15, e2, s, i, r, n, o, a) {
  return (r - o) * (e2 - a) >= (t15 - o) * (n - a) && (t15 - o) * (i - a) >= (s - o) * (e2 - a) && (s - o) * (n - a) >= (r - o) * (i - a);
}
function Ht(t15, e2) {
  return t15.next.i !== e2.i && t15.prev.i !== e2.i && !function(t16, e3) {
    var s = t16;
    do {
      if (s.i !== t16.i && s.next.i !== t16.i && s.i !== e3.i && s.next.i !== e3.i && jt(s, s.next, t16, e3)) return true;
      s = s.next;
    } while (s !== t16);
    return false;
  }(t15, e2) && (Zt(t15, e2) && Zt(e2, t15) && function(t16, e3) {
    var s = t16, i = false, r = (t16.x + e3.x) / 2, n = (t16.y + e3.y) / 2;
    do {
      s.y > n != s.next.y > n && s.next.y !== s.y && r < (s.next.x - s.x) * (n - s.y) / (s.next.y - s.y) + s.x && (i = !i), s = s.next;
    } while (s !== t16);
    return i;
  }(t15, e2) && (kt(t15.prev, t15, e2.prev) || kt(t15, e2.prev, e2)) || Wt(t15, e2) && kt(t15.prev, t15, t15.next) > 0 && kt(e2.prev, e2, e2.next) > 0);
}
function kt(t15, e2, s) {
  return (e2.y - t15.y) * (s.x - e2.x) - (e2.x - t15.x) * (s.y - e2.y);
}
function Wt(t15, e2) {
  return t15.x === e2.x && t15.y === e2.y;
}
function jt(t15, e2, s, i) {
  var r = Xt(kt(t15, e2, s)), n = Xt(kt(t15, e2, i)), o = Xt(kt(s, i, t15)), a = Xt(kt(s, i, e2));
  return r !== n && o !== a || (!(0 !== r || !qt(t15, s, e2)) || (!(0 !== n || !qt(t15, i, e2)) || (!(0 !== o || !qt(s, t15, i)) || !(0 !== a || !qt(s, e2, i)))));
}
function qt(t15, e2, s) {
  return e2.x <= Math.max(t15.x, s.x) && e2.x >= Math.min(t15.x, s.x) && e2.y <= Math.max(t15.y, s.y) && e2.y >= Math.min(t15.y, s.y);
}
function Xt(t15) {
  return t15 > 0 ? 1 : t15 < 0 ? -1 : 0;
}
function Zt(t15, e2) {
  return kt(t15.prev, t15, t15.next) < 0 ? kt(t15, e2, t15.next) >= 0 && kt(t15, t15.prev, e2) >= 0 : kt(t15, e2, t15.prev) < 0 || kt(t15, t15.next, e2) < 0;
}
function Kt(t15, e2) {
  var s = new Jt(t15.i, t15.x, t15.y), i = new Jt(e2.i, e2.x, e2.y), r = t15.next, n = e2.prev;
  return t15.next = e2, e2.prev = t15, s.next = r, r.prev = s, i.next = s, s.prev = i, n.next = i, i.prev = n, i;
}
function $t(t15, e2, s, i) {
  var r = new Jt(t15, e2, s);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function Qt(t15) {
  t15.next.prev = t15.prev, t15.prev.next = t15.next, t15.prevZ && (t15.prevZ.nextZ = t15.nextZ), t15.nextZ && (t15.nextZ.prevZ = t15.prevZ);
}
function Jt(t15, e2, s) {
  this.i = t15, this.x = e2, this.y = s, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
function te(t15, e2, s, i) {
  for (var r = 0, n = e2, o = s - i; n < s; n += i) r += (t15[o] - t15[n]) * (t15[n + 1] + t15[o + 1]), o = n;
  return r;
}
St.exports = wt, St.exports.default = wt, wt.deviation = function(t15, e2, s, i) {
  var r = e2 && e2.length, n = r ? e2[0] * s : t15.length, o = Math.abs(te(t15, 0, n, s));
  if (r) for (var a = 0, c = e2.length; a < c; a++) {
    var h = e2[a] * s, l = a < c - 1 ? e2[a + 1] * s : t15.length;
    o -= Math.abs(te(t15, h, l, s));
  }
  var d = 0;
  for (a = 0; a < i.length; a += 3) {
    var b = i[a] * s, u = i[a + 1] * s, I = i[a + 2] * s;
    d += Math.abs((t15[b] - t15[I]) * (t15[u + 1] - t15[b + 1]) - (t15[b] - t15[u]) * (t15[I + 1] - t15[b + 1]));
  }
  return 0 === o && 0 === d ? 0 : Math.abs((d - o) / o);
}, wt.flatten = function(t15) {
  for (var e2 = t15[0][0].length, s = { vertices: [], holes: [], dimensions: e2 }, i = 0, r = 0; r < t15.length; r++) {
    for (var n = 0; n < t15[r].length; n++) for (var o = 0; o < e2; o++) s.vertices.push(t15[r][n][o]);
    r > 0 && (i += t15[r - 1].length, s.holes.push(i));
  }
  return s;
};
var ee = class {
  constructor() {
    e(this, "int"), e(this, "float"), e(this, "buffer"), e(this, "s1", 4), e(this, "s2", 8);
    const { intBuffer: t15, floatBuffer: s, buffer: i } = this.newBuffers();
    this.int = t15, this.float = s, this.buffer = i;
  }
  newBuffers() {
    const t15 = new Int32Array(1), e2 = t15.buffer;
    return { intBuffer: t15, floatBuffer: new Float32Array(e2), buffer: new Uint8Array(e2) };
  }
};
var se = class {
  static check(t15) {
    const e2 = Number.isInteger(t15), s = t15 < this._max, i = t15 > this._min;
    return e2 && s && i;
  }
};
e(se, "_max", 2147483647), e(se, "_min", -2147483648);
var ie = class t2 {
  constructor() {
    e(this, "_core", new ee()), e(this, "_handlers"), e(this, "_result", -1), e(this, "handleObject", (t15) => {
      const e2 = Object.keys(t15);
      for (const s of e2) t15.hasOwnProperty(s) && this.compute(t15[s]);
    }), e(this, "handleString", (t15) => {
      const e2 = t15.length;
      for (let s = 0; s < e2; ++s) {
        const e3 = t15.codePointAt(s);
        this._core.int[0] = e3, this.update();
      }
    }), e(this, "handleBoolean", (t15) => {
      this._core.int[0] = t15 ? 1 : 0, this.update();
    }), e(this, "handleNumber", (t15) => {
      (se.check(t15) ? this._core.int : this._core.float)[0] = t15, this.update();
    }), this._handlers = this.newHandlers();
  }
  get value() {
    return ~this._result;
  }
  fromMaterialData(t15) {
    const { modelId: e2, objectClass: s, currentLod: i, templateId: r, ...n } = t15;
    this.reset(), this.compute(e2), this.compute(s), this.compute(n), this.compute(i), this.compute(void 0 !== r);
  }
  generate(t15) {
    this.reset();
    for (const e2 of t15) this.compute(e2);
    return this.value;
  }
  compute(t15) {
    return this.getHandler(t15)(t15), this;
  }
  reset() {
    return this._result = -1, this;
  }
  getHandler(t15) {
    const e2 = typeof t15, s = this._handlers[e2];
    if (!s) throw new Error("Fragments: Unsupported input type");
    return s;
  }
  newHandlers() {
    return { number: this.handleNumber, boolean: this.handleBoolean, string: this.handleString, object: this.handleObject };
  }
  update() {
    for (let e2 = 0; e2 < this._core.s1; ++e2) {
      this._result ^= this._core.buffer[e2];
      for (let e3 = 0; e3 < this._core.s2; ++e3) 1 & this._result ? this._result = this._result >> 1 ^ t2._polynomial : this._result >>= 1;
    }
  }
};
e(ie, "_polynomial", 2197175160);
var ne = class t3 {
  constructor(t15, s) {
    e(this, "_first"), this._first = this.newData(t15, s);
  }
  static getComplementary(t15, e2) {
    let s = 0;
    const i = t15.position.length;
    s = this.makeBufferComplementary(i, t15, s, e2), s !== 1 / 0 && e2(s, 1 / 0);
  }
  static get(t15, e2, s, i) {
    const { filtered: r, position: n, size: o } = this.getData(t15, s);
    return this.setAllBufferData(r, e2, n, o, i), { position: n, size: o };
  }
  fullOf(t15) {
    const e2 = this._first.following, s = this._first.data;
    return null === e2 && s === t15;
  }
  update(t15, e2) {
    const s = this.getBufferData(t15);
    if (!(s.data === e2)) {
      const { a: i, c: r, b: n } = this.newBuffers(t15, s, e2);
      this.setupInputData(s, i, r), this.setupUpdateBuffers(i, n, r);
    }
  }
  size(t15) {
    let e2 = 0, s = this._first;
    for (; null !== s; ) {
      this.doesFilterPass(t15, s) && e2++, s = s.following;
    }
    return e2;
  }
  static setAllBufferData(t15, e2, s, i, r) {
    for (let n = 0; n < t15.length; ++n) {
      const o = t15[n];
      this.transform(o, e2), this.setBuffers(s, i, n), r && r(n, o.data);
    }
  }
  static makeBufferComplementary(t15, e2, s, i) {
    for (let r = 0; r < t15; ++r) {
      const t16 = this.getBuffers(e2, r), { position: n, size: o } = t16;
      n > s && i(s, n - s), s = n + o;
    }
    return s;
  }
  static setBuffers(t15, e2, s) {
    t15[s] = this._tempData.position;
    const i = this._tempData.size === 1 / 0;
    e2[s] = i ? this._inf : this._tempData.size;
  }
  add(e2, s, i) {
    if (!t3._stash.length) return this.newData(s, i, e2);
    const r = t3._stash.pop();
    if (!r) throw new Error("Fragments: No stash found");
    return r.position = e2, r.size = s, r.data = i, r;
  }
  remove(e2) {
    e2 && (e2.following = null, e2.past = null, t3._stash.push(e2));
  }
  static getData(t15, e2) {
    const s = t15.filter(e2), i = s.length;
    return { filtered: s, position: new Uint32Array(i), size: new Uint32Array(i) };
  }
  filter(t15) {
    const e2 = [];
    let s = this._first;
    for (; null !== s; ) {
      this.doesFilterPass(t15, s) && e2.push(s), s = s.following;
    }
    return e2;
  }
  static transform(t15, e2) {
    const s = this.getTempData(), i = t15.position + t15.size, r = i === e2.length;
    if (s.position = e2[t15.position], r) s.size = 1 / 0;
    else {
      const t16 = e2[i];
      s.size = t16 - s.position;
    }
    return s;
  }
  static getBuffers(t15, e2) {
    const s = t15.position[e2];
    let i;
    return i = t15.size[e2] === this._inf ? 1 / 0 : t15.size[e2], { position: s, size: i };
  }
  static getTempData() {
    return this._tempData ? this._tempData : { position: 0, size: 0 };
  }
  doesFilterPass(t15, e2) {
    return !t15 || t15(e2.data);
  }
  setupUpdateBuffers(t15, e2, s) {
    this.chainBuffers(t15, e2, s), this.setupFirstBuffer(t15, e2), this.setupLastBuffer(s, e2), this.setupMiddleBufferStart(e2), this.setupMiddleBufferEnd(e2);
  }
  setupMiddleBufferEnd(t15) {
    var e2;
    if ((null == (e2 = t15.following) ? void 0 : e2.data) === t15.data) {
      if (!t15.following) return;
      const e3 = t15.following.size + t15.size, s = t15.following.following;
      t15.size = e3, this.remove(t15.following), t15.following = s, t15.following && (t15.following.past = t15);
    }
  }
  setupFirstBuffer(t15, e2) {
    t15.size || (t15.past ? t15.past.following = e2 : this._first = e2, e2.past = t15.past, this.remove(t15));
  }
  setupMiddleBufferStart(t15) {
    var e2;
    if ((null == (e2 = t15.past) ? void 0 : e2.data) === t15.data) {
      if (!t15.past) return;
      t15.size = t15.past.size + t15.size, t15.position = t15.past.position;
      const e3 = t15.past.past;
      this.remove(t15.past), t15.past = e3, t15.past ? t15.past.following = t15 : this._first = t15;
    }
  }
  chainBuffers(t15, e2, s) {
    t15.following = e2, e2.past = t15, e2.following = s, s.past = e2;
  }
  setupLastBuffer(t15, e2) {
    t15.size || (t15.following && (t15.following.past = e2), e2.following = t15.following, this.remove(t15));
  }
  newBuffers(t15, e2, s) {
    const i = t15 - e2.position, r = this.add(e2.position, i, e2.data), n = this.add(t15, 1, s), o = e2.size - r.size - 1;
    return { a: r, c: this.add(t15 + 1, o, e2.data), b: n };
  }
  setupInputData(t15, e2, s) {
    t15.past ? (t15.past.following = e2, e2.past = t15.past) : this._first = e2, t15.following && (t15.following.past = s, s.following = t15.following), this.remove(t15);
  }
  newData(t15, e2, s = 0) {
    return { position: s, size: t15, past: null, following: null, data: e2 };
  }
  getBufferData(t15) {
    let e2 = this._first;
    for (; ; ) {
      const s = null === e2, i = e2.position <= t15, r = t15 < e2.position + e2.size;
      if (s || i && r) return e2;
      e2 = e2.following;
    }
  }
};
e(ne, "_stash", []), e(ne, "_tempData", { position: 0, size: 0 }), e(ne, "_inf", 4294967295);
var ae = class {
  static fixNumber(t15) {
    return Number.isNaN(t15) ? 0 : Number.isFinite(t15) ? t15 : 0;
  }
  static forEach(t15, e2) {
    if (Array.isArray(t15)) {
      let s = 0;
      for (const i of t15) e2(i, s++);
    } else e2(t15, 0);
  }
};
var ce = class {
  static estimateCapacity() {
    const t15 = this.capacityFactor, e2 = window.screen.width, s = window.screen.height, i = window.devicePixelRatio;
    return Math.trunc(e2 * s * i * i * t15);
  }
};
e(ce, "capacityFactor", 200);
var he = class {
  static parseMaterial(t15) {
    const e2 = t15.r() / 255, i = t15.g() / 255, r = t15.b() / 255, n = t15.a() / 255, o = t15.a() < 255;
    return { color: new Color(e2, i, r), renderedFaces: t15.renderedFaces(), opacity: n, transparent: o };
  }
  static parseBox(t15, e2) {
    this.getBox(t15, e2, "min"), this.getBox(t15, e2, "max");
  }
  static parseTransform(t15, e2) {
    return this.getVector(t15, "position", this._doubleVector), this.getVector(t15, "xDirection", this._floatVector), this.getVector(t15, "yDirection", this._floatVector), this.computeZVector(), this.setTransform(e2), e2;
  }
  static setTransform(t15) {
    const { x: e2, y: s, z: i } = this._temp.xDirection, { x: r, y: n, z: o } = this._temp.yDirection, { x: a, y: c, z: h } = this._temp.zDirection, { x: l, y: d, z: b } = this._temp.position;
    t15.set(e2, r, a, l, s, n, c, d, i, o, h, b, 0, 0, 0, 1);
  }
  static getBox(t15, e2, s) {
    t15[s](this._floatVector);
    const i = this._floatVector.x(), r = this._floatVector.y(), n = this._floatVector.z();
    e2[s].x = ae.fixNumber(i), e2[s].y = ae.fixNumber(r), e2[s].z = ae.fixNumber(n);
  }
  static getVector(t15, e2, s) {
    t15[e2](s);
    const i = this._temp[e2], r = s.x(), n = s.y(), o = s.z();
    i.x = ae.fixNumber(r), i.y = ae.fixNumber(n), i.z = ae.fixNumber(o);
  }
  static computeZVector() {
    this._temp.zDirection.crossVectors(this._temp.xDirection, this._temp.yDirection);
  }
};
e(he, "_temp", { position: new Vector3(), xDirection: new Vector3(), yDirection: new Vector3(), zDirection: new Vector3() }), e(he, "_doubleVector", new tt()), e(he, "_floatVector", new j());
var le = class {
  static get(t15, e2, s) {
    this.fetchSampleTransform(t15, e2), this.fetchItemTransform(t15, e2), s.multiplyMatrices(this._item, this._sample);
  }
  static getBox(t15, e2) {
    t15.bbox(this._box), he.parseBox(this._box, e2);
  }
  static getBoxData(t15) {
    this._min.copy(t15.min), this._max.copy(t15.max), this._center.addVectors(this._min, this._max), this._center.divideScalar(2), t15.getSize(this._distance);
  }
  static boxSize(t15) {
    return this.getBoxData(t15), this.applyTransformer(), this._edge.start = this._min.clone(), this._edge.end = this._max.clone(), this._edge;
  }
  static applyTransformer() {
    const { x: t15, y: e2, z: s } = this._distance, i = Math.max(t15, e2, s);
    t15 === i ? this._transformers.x() : e2 === i ? this._transformers.y() : this._transformers.z();
  }
  static fetchItemTransform(t15, e2) {
    const s = t15.item();
    e2.globalTransforms(s, this._transform), he.parseTransform(this._transform, this._item);
  }
  static fetchSampleTransform(t15, e2) {
    const s = t15.localTransform();
    e2.localTransforms(s, this._transform), he.parseTransform(this._transform, this._sample);
  }
  static setBoxZ() {
    this._min.set(this._center.x, this._center.y, this._min.z), this._max.set(this._center.x, this._center.y, this._max.z);
  }
  static setBoxY() {
    this._min.set(this._center.x, this._min.y, this._center.z), this._max.set(this._center.x, this._max.y, this._center.z);
  }
  static setBoxX() {
    this._min.set(this._min.x, this._center.y, this._center.z), this._max.set(this._max.x, this._center.y, this._center.z);
  }
};
e(le, "_transform", new it()), e(le, "_min", new Vector3()), e(le, "_max", new Vector3()), e(le, "_center", new Vector3()), e(le, "_distance", new Vector3()), e(le, "_edge", new Line3()), e(le, "_item", new Matrix4()), e(le, "_sample", new Matrix4()), e(le, "_box", new Q()), e(le, "_transformers", { x: () => le.setBoxX(), y: () => le.setBoxY(), z: () => le.setBoxZ() });
e(class {
  static getWidth(t15) {
    return t15.getSize(this._temp.vector), this._temp.vector.x > this._temp.vector.y && this._temp.vector.set(this._temp.vector.y, this._temp.vector.x, this._temp.vector.z), this._temp.vector.y > this._temp.vector.z && this._temp.vector.set(this._temp.vector.x, this._temp.vector.z, this._temp.vector.y), this._temp.vector.x > this._temp.vector.y && this._temp.vector.set(this._temp.vector.y, this._temp.vector.x, this._temp.vector.z), this._temp.vector.y;
  }
}, "_temp", { vector: new Vector3() });
var de = new Box3();
var be = new Vector3();
UniformsLib.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new Vector2(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, ShaderLib.line = { uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]), vertexShader: "\n		#include <common>\n		#include <color_pars_vertex>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n		#include <clipping_planes_pars_vertex>\n\n		uniform float linewidth;\n		uniform vec2 resolution;\n\n		attribute vec3 instanceStart;\n		attribute vec3 instanceEnd;\n\n		attribute vec3 instanceColorStart;\n		attribute vec3 instanceColorEnd;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#ifdef USE_DASH\n\n			uniform float dashScale;\n			attribute float instanceDistanceStart;\n			attribute float instanceDistanceEnd;\n			varying float vLineDistance;\n\n		#endif\n\n		void trimSegment( const in vec4 start, inout vec4 end ) {\n\n			// trim end segment so it terminates between the camera plane and the near plane\n\n			// conservative estimate of the near plane\n			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n			float nearEstimate = - 0.5 * b / a;\n\n			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n			end.xyz = mix( start.xyz, end.xyz, alpha );\n\n		}\n\n		void main() {\n\n			#ifdef USE_COLOR\n\n				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n			#endif\n\n			#ifdef USE_DASH\n\n				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n				vUv = uv;\n\n			#endif\n\n			float aspect = resolution.x / resolution.y;\n\n			// camera space\n			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n			#ifdef WORLD_UNITS\n\n				worldStart = start.xyz;\n				worldEnd = end.xyz;\n\n			#else\n\n				vUv = uv;\n\n			#endif\n\n			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n			// perhaps there is a more elegant solution -- WestLangley\n\n			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n			if ( perspective ) {\n\n				if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n					trimSegment( start, end );\n\n				} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n					trimSegment( end, start );\n\n				}\n\n			}\n\n			// clip space\n			vec4 clipStart = projectionMatrix * start;\n			vec4 clipEnd = projectionMatrix * end;\n\n			// ndc space\n			vec3 ndcStart = clipStart.xyz / clipStart.w;\n			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n			// direction\n			vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n			// account for clip-space aspect ratio\n			dir.x *= aspect;\n			dir = normalize( dir );\n\n			#ifdef WORLD_UNITS\n\n				vec3 worldDir = normalize( end.xyz - start.xyz );\n				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n				vec3 worldFwd = cross( worldDir, worldUp );\n				worldPos = position.y < 0.5 ? start: end;\n\n				// height offset\n				float hw = linewidth * 0.5;\n				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n				// don't extend the line if we're rendering dashes because we\n				// won't be rendering the endcaps\n				#ifndef USE_DASH\n\n					// cap extension\n					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n					// add width to the box\n					worldPos.xyz += worldFwd * hw;\n\n					// endcaps\n					if ( position.y > 1.0 || position.y < 0.0 ) {\n\n						worldPos.xyz -= worldFwd * 2.0 * hw;\n\n					}\n\n				#endif\n\n				// project the worldpos\n				vec4 clip = projectionMatrix * worldPos;\n\n				// shift the depth of the projected points so the line\n				// segments overlap neatly\n				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n				clip.z = clipPose.z * clip.w;\n\n			#else\n\n				vec2 offset = vec2( dir.y, - dir.x );\n				// undo aspect ratio adjustment\n				dir.x /= aspect;\n				offset.x /= aspect;\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				// endcaps\n				if ( position.y < 0.0 ) {\n\n					offset += - dir;\n\n				} else if ( position.y > 1.0 ) {\n\n					offset += dir;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth;\n\n				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n				offset /= resolution.y;\n\n				// select end\n				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n				// back to clip space\n				offset *= clip.w;\n\n				clip.xy += offset;\n\n			#endif\n\n			gl_Position = clip;\n\n			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n			#include <logdepthbuf_vertex>\n			#include <clipping_planes_vertex>\n			#include <fog_vertex>\n\n		}\n		", fragmentShader: "\n		uniform vec3 diffuse;\n		uniform float opacity;\n		uniform float linewidth;\n\n		#ifdef USE_DASH\n\n			uniform float dashOffset;\n			uniform float dashSize;\n			uniform float gapSize;\n\n		#endif\n\n		varying float vLineDistance;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#include <common>\n		#include <color_pars_fragment>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n		#include <clipping_planes_pars_fragment>\n\n		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n			float mua;\n			float mub;\n\n			vec3 p13 = p1 - p3;\n			vec3 p43 = p4 - p3;\n\n			vec3 p21 = p2 - p1;\n\n			float d1343 = dot( p13, p43 );\n			float d4321 = dot( p43, p21 );\n			float d1321 = dot( p13, p21 );\n			float d4343 = dot( p43, p43 );\n			float d2121 = dot( p21, p21 );\n\n			float denom = d2121 * d4343 - d4321 * d4321;\n\n			float numer = d1343 * d4321 - d1321 * d4343;\n\n			mua = numer / denom;\n			mua = clamp( mua, 0.0, 1.0 );\n			mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n			mub = clamp( mub, 0.0, 1.0 );\n\n			return vec2( mua, mub );\n\n		}\n\n		void main() {\n\n			#include <clipping_planes_fragment>\n\n			#ifdef USE_DASH\n\n				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n			#endif\n\n			float alpha = opacity;\n\n			#ifdef WORLD_UNITS\n\n				// Find the closest points on the view ray and the line segment\n				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n				vec3 lineDir = worldEnd - worldStart;\n				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n				vec3 p1 = worldStart + lineDir * params.x;\n				vec3 p2 = rayEnd * params.y;\n				vec3 delta = p1 - p2;\n				float len = length( delta );\n				float norm = len / linewidth;\n\n				#ifndef USE_DASH\n\n					#ifdef USE_ALPHA_TO_COVERAGE\n\n						float dnorm = fwidth( norm );\n						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n					#else\n\n						if ( norm > 0.5 ) {\n\n							discard;\n\n						}\n\n					#endif\n\n				#endif\n\n			#else\n\n				#ifdef USE_ALPHA_TO_COVERAGE\n\n					// artifacts appear on some hardware if a derivative is taken within a conditional\n					float a = vUv.x;\n					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n					float len2 = a * a + b * b;\n					float dlen = fwidth( len2 );\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n					}\n\n				#else\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						float a = vUv.x;\n						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n						float len2 = a * a + b * b;\n\n						if ( len2 > 1.0 ) discard;\n\n					}\n\n				#endif\n\n			#endif\n\n			vec4 diffuseColor = vec4( diffuse, alpha );\n\n			#include <logdepthbuf_fragment>\n			#include <color_fragment>\n\n			gl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n			#include <premultiplied_alpha_fragment>\n\n		}\n		" };
var fe = new Vector4();
var _e = new Vector3();
var Ee = new Vector3();
var pe = new Vector4();
var Ce = new Vector4();
var me = new Vector4();
var ge = new Vector3();
var Te = new Matrix4();
var Ae = new Line3();
var Fe = new Vector3();
var Re = new Box3();
var ye = new Sphere();
var Oe = new Vector4();
var je = class {
};
e(je, "vertex", "\n            #include <common>\n            #include <clipping_planes_pars_vertex>\n\n            attribute float itemFilter;\n            uniform vec2 lodSize;\n            attribute vec3 itemFirst;\n            attribute vec3 itemLast;\n\n            float lodWidth = 2.0;\n            \n            void cutLodLine(const in vec4 first, inout vec4 second ) {\n                float projValue1 = projectionMatrix[2][2];\n                float projValue2 = projectionMatrix[3][2];\n                float approxResult = -(projValue2 / projValue1) / 2.0;\n                float diff1 = approxResult - first.z;\n                float diff2 = second.z - first.z;\n                float cutFilter = diff1 / diff2;\n                second.xyz = mix(first.xyz, second.xyz, cutFilter);\n            }\n                \n            void main() {\n                if (itemFilter == 0.0) {\n                    gl_Position = vec4(0,0,0,0);\n                    return;\n                }\n\n                vec4 rawFirst = vec4(itemFirst, 1.0);\n                vec4 rawLast = vec4(itemLast, 1.0);\n                vec4 first = modelViewMatrix * rawFirst;\n                vec4 last = modelViewMatrix * rawLast;\n                \n                bool lodPerspective = projectionMatrix[2][3] == -1.0;\n                if (lodPerspective) {\n                    bool firstCut = first.z < 0.0 && last.z >= 0.0;\n                    bool lastCut = last.z < 0.0 && first.z >= 0.0;\n                    if (firstCut) {\n                        cutLodLine( first, last );\n                    } else if (lastCut) {\n                        cutLodLine( last, first );\n                    }\n                }\n\n                vec4 firstCut = projectionMatrix * first;\n                vec4 lastCut = projectionMatrix * last;\n                vec3 firstNdc = firstCut.xyz / firstCut.w;\n                vec3 lastNdc = lastCut.xyz / lastCut.w;\n\n                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;\n\n                float lodRatio = lodSize.x / lodSize.y;\n                lodOrientation.x *= lodRatio;\n                lodOrientation = normalize(lodOrientation);\n                \n                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);\n                lodOrientation.x /= lodRatio;\n                lodDistance.x /= lodRatio;\n\n                if (position.x < 0.0) { \n                    lodDistance *= - 1.0;\n                }\n\n                if (position.y < 0.0) {\n                    lodDistance += -lodOrientation;\n                } else if (position.y > 1.0) {\n                    lodDistance += lodOrientation;\n                }\n\n                lodDistance *= lodWidth;\n                lodDistance /= lodSize.y;\n\n                bool isFirst = position.y < 0.5;\n                vec4 lodPosition = isFirst ? firstCut : lastCut;\n                lodDistance *= lodPosition.w;\n                lodPosition.xy += lodDistance;\n                gl_Position = lodPosition;\n\n                vec4 mvPosition = isFirst ? first : last;\n                #include <clipping_planes_vertex>\n            }\n    "), e(je, "fragment", "\n            #include <common>\n            #include <clipping_planes_pars_fragment>\n\n            uniform vec3 lodColor;\n            uniform float lodOpacity;\n\n            void main() {\n                #include <clipping_planes_fragment>\n                gl_FragColor = vec4(lodColor, lodOpacity);\n                #include <colorspace_fragment>\n            }\n    ");
var qe = class t4 {
  static setupLodMeshResize(t15) {
    t15.onBeforeRender = (e2) => {
      e2.getSize(t15.material[0].lodSize);
    };
  }
  static setupLodAttributes(e2) {
    e2.setIndex(t4.indices), e2.setAttribute("position", t4.vertices);
  }
  static setLodBuffer(t15, e2, s) {
    let i = t15.getItemFirst(), r = t15.getItemLast(), n = this.setItemFirst(t15, i, e2, r);
    const o = this.resetAttributes(i, n, e2, r);
    ({ itemFirst: i, dataBuffer: n, itemLast: r } = o), this.setupFinish(s, n), t15.setAttribute("itemFirst", i), t15.setAttribute("itemLast", r);
  }
  static setLodVisibility(t15, e2) {
    const s = this.setupItemFilter(t15);
    this.applyVisibilityState(t15, e2, s), s.needsUpdate = true;
  }
  static getInterAttribute(t15, e2) {
    return t15.getAttribute(e2);
  }
  static computeLodSphere(e2) {
    if (!e2.boundingSphere) return;
    const s = e2.getItemFirst();
    if (s) {
      const i = t4.getLodMidPoint(e2, s), r = t4.getLodRadius(i, s);
      e2.boundingSphere.radius = r;
    }
  }
  static newLodMaterialParams(t15) {
    const e2 = { lodColor: { value: new Color(t15.color) }, lodSize: { value: new Vector2(1, 1) }, lodOpacity: { value: t15.opacity ?? 1 } };
    return { uniforms: UniformsUtils.merge([UniformsLib.common, e2]), transparent: t15.transparent ?? false, vertexShader: je.vertex, fragmentShader: je.fragment };
  }
  static setLodFilter(t15, e2) {
    const s = t15.getItemFilter(), i = s.array;
    for (let t16 = 0; t16 < e2.position.length; ++t16) {
      const s2 = e2.position[t16] / 2, r = e2.size[t16] / 2;
      4294967295 === r ? i.fill(1, s2) : i.fill(1, s2, s2 + r);
    }
    s.needsUpdate = true;
  }
  static getInstancedAttribute(t15, e2) {
    return t15.getAttribute(e2);
  }
  static computeLodBox(t15) {
    if (!t15.boundingBox) return;
    const e2 = t15.getItemFirst();
    if (e2) {
      const s = e2.data.array;
      t15.boundingBox.setFromArray(s);
    } else t15.boundingBox.makeEmpty();
  }
  static setDataBuffer(t15, e2, s) {
    return (t15 = e2.data).array = s, t15.needsUpdate = true, t15;
  }
  static disposeAllData(e2) {
    delete e2.attributes.itemFilter, delete e2.attributes.position, e2.index = null, e2.dispose(), t4.setupLodAttributes(e2);
  }
  static setItemFirst(t15, e2, s, i) {
    let r = null;
    if (e2) {
      s.length === e2.data.array.length ? r = this.setDataBuffer(r, e2, s) : (e2 = void 0, this.disposeAllData(t15));
    }
    return r;
  }
  static setupFinish(t15, e2) {
    t15 && (e2.onUploadCallback = t15);
  }
  static resetAttributes(t15, e2, i, r) {
    return t15 || (e2 = new InstancedInterleavedBuffer(i, 6, 1), t15 = new InterleavedBufferAttribute(e2, 3, 0), r = new InterleavedBufferAttribute(e2, 3, 3)), { itemFirst: t15, dataBuffer: e2, itemLast: r };
  }
  static setupItemFilter(t15) {
    const e2 = t15.getItemFirst().count;
    let i = t15.getItemFilter();
    return i ? i.array.fill(0) : (i = new InstancedBufferAttribute(new Uint8Array(e2), 1), t15.setAttribute("itemFilter", i)), i;
  }
  static applyVisibilityState(t15, e2, s) {
    true !== e2 ? e2 && this.setLodFilter(t15, e2) : s.array.fill(1);
  }
  static getLodMidPoint(t15, e2) {
    const s = t15.boundingSphere.center;
    return this.tempBox.setFromArray(e2.data.array), this.tempBox.getCenter(s), s;
  }
  static getLodRadius(e2, s) {
    let i = 0;
    const r = s.data.array.length;
    for (let n = 0; n < r; n += 3) {
      const r2 = s.data.array;
      t4.tempVec.fromArray(r2, n);
      const o = e2.distanceToSquared(t4.tempVec);
      i = Math.max(i, o);
    }
    return Math.sqrt(i);
  }
};
e(qe, "tempVec", new Vector3()), e(qe, "tempBox", new Box3()), e(qe, "vertices", new Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), e(qe, "indices", new Uint8BufferAttribute([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5], 1));
function us(t15) {
  let e2 = t15.length;
  for (; --e2 >= 0; ) t15[e2] = 0;
}
var Is = 256;
var fs = 286;
var _s = 30;
var Es = 15;
var ps = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var Cs = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var ms = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var gs = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Ts = new Array(576);
us(Ts);
var As = new Array(60);
us(As);
var Fs = new Array(512);
us(Fs);
var Rs = new Array(256);
us(Rs);
var ys = new Array(29);
us(ys);
var Os = new Array(_s);
function Ss(t15, e2, s, i, r) {
  this.static_tree = t15, this.extra_bits = e2, this.extra_base = s, this.elems = i, this.max_length = r, this.has_stree = t15 && t15.length;
}
var ws;
var Ns;
var Ls;
function vs(t15, e2) {
  this.dyn_tree = t15, this.max_code = 0, this.stat_desc = e2;
}
us(Os);
var Ms = (t15) => t15 < 256 ? Fs[t15] : Fs[256 + (t15 >>> 7)];
var Ps = (t15, e2) => {
  t15.pending_buf[t15.pending++] = 255 & e2, t15.pending_buf[t15.pending++] = e2 >>> 8 & 255;
};
var xs = (t15, e2, s) => {
  t15.bi_valid > 16 - s ? (t15.bi_buf |= e2 << t15.bi_valid & 65535, Ps(t15, t15.bi_buf), t15.bi_buf = e2 >> 16 - t15.bi_valid, t15.bi_valid += s - 16) : (t15.bi_buf |= e2 << t15.bi_valid & 65535, t15.bi_valid += s);
};
var Us = (t15, e2, s) => {
  xs(t15, s[2 * e2], s[2 * e2 + 1]);
};
var Ds = (t15, e2) => {
  let s = 0;
  do {
    s |= 1 & t15, t15 >>>= 1, s <<= 1;
  } while (--e2 > 0);
  return s >>> 1;
};
var Vs = (t15, e2, s) => {
  const i = new Array(16);
  let r, n, o = 0;
  for (r = 1; r <= Es; r++) o = o + s[r - 1] << 1, i[r] = o;
  for (n = 0; n <= e2; n++) {
    let e3 = t15[2 * n + 1];
    0 !== e3 && (t15[2 * n] = Ds(i[e3]++, e3));
  }
};
var Bs = (t15) => {
  let e2;
  for (e2 = 0; e2 < fs; e2++) t15.dyn_ltree[2 * e2] = 0;
  for (e2 = 0; e2 < _s; e2++) t15.dyn_dtree[2 * e2] = 0;
  for (e2 = 0; e2 < 19; e2++) t15.bl_tree[2 * e2] = 0;
  t15.dyn_ltree[512] = 1, t15.opt_len = t15.static_len = 0, t15.sym_next = t15.matches = 0;
};
var Gs = (t15) => {
  t15.bi_valid > 8 ? Ps(t15, t15.bi_buf) : t15.bi_valid > 0 && (t15.pending_buf[t15.pending++] = t15.bi_buf), t15.bi_buf = 0, t15.bi_valid = 0;
};
var zs = (t15, e2, s, i) => {
  const r = 2 * e2, n = 2 * s;
  return t15[r] < t15[n] || t15[r] === t15[n] && i[e2] <= i[s];
};
var Ys = (t15, e2, s) => {
  const i = t15.heap[s];
  let r = s << 1;
  for (; r <= t15.heap_len && (r < t15.heap_len && zs(e2, t15.heap[r + 1], t15.heap[r], t15.depth) && r++, !zs(e2, i, t15.heap[r], t15.depth)); ) t15.heap[s] = t15.heap[r], s = r, r <<= 1;
  t15.heap[s] = i;
};
var Hs = (t15, e2, s) => {
  let i, r, n, o, a = 0;
  if (0 !== t15.sym_next) do {
    i = 255 & t15.pending_buf[t15.sym_buf + a++], i += (255 & t15.pending_buf[t15.sym_buf + a++]) << 8, r = t15.pending_buf[t15.sym_buf + a++], 0 === i ? Us(t15, r, e2) : (n = Rs[r], Us(t15, n + Is + 1, e2), o = ps[n], 0 !== o && (r -= ys[n], xs(t15, r, o)), i--, n = Ms(i), Us(t15, n, s), o = Cs[n], 0 !== o && (i -= Os[n], xs(t15, i, o)));
  } while (a < t15.sym_next);
  Us(t15, 256, e2);
};
var ks = (t15, e2) => {
  const s = e2.dyn_tree, i = e2.stat_desc.static_tree, r = e2.stat_desc.has_stree, n = e2.stat_desc.elems;
  let o, a, c, h = -1;
  for (t15.heap_len = 0, t15.heap_max = 573, o = 0; o < n; o++) 0 !== s[2 * o] ? (t15.heap[++t15.heap_len] = h = o, t15.depth[o] = 0) : s[2 * o + 1] = 0;
  for (; t15.heap_len < 2; ) c = t15.heap[++t15.heap_len] = h < 2 ? ++h : 0, s[2 * c] = 1, t15.depth[c] = 0, t15.opt_len--, r && (t15.static_len -= i[2 * c + 1]);
  for (e2.max_code = h, o = t15.heap_len >> 1; o >= 1; o--) Ys(t15, s, o);
  c = n;
  do {
    o = t15.heap[1], t15.heap[1] = t15.heap[t15.heap_len--], Ys(t15, s, 1), a = t15.heap[1], t15.heap[--t15.heap_max] = o, t15.heap[--t15.heap_max] = a, s[2 * c] = s[2 * o] + s[2 * a], t15.depth[c] = (t15.depth[o] >= t15.depth[a] ? t15.depth[o] : t15.depth[a]) + 1, s[2 * o + 1] = s[2 * a + 1] = c, t15.heap[1] = c++, Ys(t15, s, 1);
  } while (t15.heap_len >= 2);
  t15.heap[--t15.heap_max] = t15.heap[1], ((t16, e3) => {
    const s2 = e3.dyn_tree, i2 = e3.max_code, r2 = e3.stat_desc.static_tree, n2 = e3.stat_desc.has_stree, o2 = e3.stat_desc.extra_bits, a2 = e3.stat_desc.extra_base, c2 = e3.stat_desc.max_length;
    let h2, l, d, b, u, I, f = 0;
    for (b = 0; b <= Es; b++) t16.bl_count[b] = 0;
    for (s2[2 * t16.heap[t16.heap_max] + 1] = 0, h2 = t16.heap_max + 1; h2 < 573; h2++) l = t16.heap[h2], b = s2[2 * s2[2 * l + 1] + 1] + 1, b > c2 && (b = c2, f++), s2[2 * l + 1] = b, l > i2 || (t16.bl_count[b]++, u = 0, l >= a2 && (u = o2[l - a2]), I = s2[2 * l], t16.opt_len += I * (b + u), n2 && (t16.static_len += I * (r2[2 * l + 1] + u)));
    if (0 !== f) {
      do {
        for (b = c2 - 1; 0 === t16.bl_count[b]; ) b--;
        t16.bl_count[b]--, t16.bl_count[b + 1] += 2, t16.bl_count[c2]--, f -= 2;
      } while (f > 0);
      for (b = c2; 0 !== b; b--) for (l = t16.bl_count[b]; 0 !== l; ) d = t16.heap[--h2], d > i2 || (s2[2 * d + 1] !== b && (t16.opt_len += (b - s2[2 * d + 1]) * s2[2 * d], s2[2 * d + 1] = b), l--);
    }
  })(t15, e2), Vs(s, h, t15.bl_count);
};
var Ws = (t15, e2, s) => {
  let i, r, n = -1, o = e2[1], a = 0, c = 7, h = 4;
  for (0 === o && (c = 138, h = 3), e2[2 * (s + 1) + 1] = 65535, i = 0; i <= s; i++) r = o, o = e2[2 * (i + 1) + 1], ++a < c && r === o || (a < h ? t15.bl_tree[2 * r] += a : 0 !== r ? (r !== n && t15.bl_tree[2 * r]++, t15.bl_tree[32]++) : a <= 10 ? t15.bl_tree[34]++ : t15.bl_tree[36]++, a = 0, n = r, 0 === o ? (c = 138, h = 3) : r === o ? (c = 6, h = 3) : (c = 7, h = 4));
};
var js = (t15, e2, s) => {
  let i, r, n = -1, o = e2[1], a = 0, c = 7, h = 4;
  for (0 === o && (c = 138, h = 3), i = 0; i <= s; i++) if (r = o, o = e2[2 * (i + 1) + 1], !(++a < c && r === o)) {
    if (a < h) do {
      Us(t15, r, t15.bl_tree);
    } while (0 != --a);
    else 0 !== r ? (r !== n && (Us(t15, r, t15.bl_tree), a--), Us(t15, 16, t15.bl_tree), xs(t15, a - 3, 2)) : a <= 10 ? (Us(t15, 17, t15.bl_tree), xs(t15, a - 3, 3)) : (Us(t15, 18, t15.bl_tree), xs(t15, a - 11, 7));
    a = 0, n = r, 0 === o ? (c = 138, h = 3) : r === o ? (c = 6, h = 3) : (c = 7, h = 4);
  }
};
var qs = false;
var Xs = (t15, e2, s, i) => {
  xs(t15, 0 + (i ? 1 : 0), 3), Gs(t15), Ps(t15, s), Ps(t15, ~s), s && t15.pending_buf.set(t15.window.subarray(e2, e2 + s), t15.pending), t15.pending += s;
};
var Zs = { _tr_init: (t15) => {
  qs || ((() => {
    let t16, e2, s, i, r;
    const n = new Array(16);
    for (s = 0, i = 0; i < 28; i++) for (ys[i] = s, t16 = 0; t16 < 1 << ps[i]; t16++) Rs[s++] = i;
    for (Rs[s - 1] = i, r = 0, i = 0; i < 16; i++) for (Os[i] = r, t16 = 0; t16 < 1 << Cs[i]; t16++) Fs[r++] = i;
    for (r >>= 7; i < _s; i++) for (Os[i] = r << 7, t16 = 0; t16 < 1 << Cs[i] - 7; t16++) Fs[256 + r++] = i;
    for (e2 = 0; e2 <= Es; e2++) n[e2] = 0;
    for (t16 = 0; t16 <= 143; ) Ts[2 * t16 + 1] = 8, t16++, n[8]++;
    for (; t16 <= 255; ) Ts[2 * t16 + 1] = 9, t16++, n[9]++;
    for (; t16 <= 279; ) Ts[2 * t16 + 1] = 7, t16++, n[7]++;
    for (; t16 <= 287; ) Ts[2 * t16 + 1] = 8, t16++, n[8]++;
    for (Vs(Ts, 287, n), t16 = 0; t16 < _s; t16++) As[2 * t16 + 1] = 5, As[2 * t16] = Ds(t16, 5);
    ws = new Ss(Ts, ps, 257, fs, Es), Ns = new Ss(As, Cs, 0, _s, Es), Ls = new Ss(new Array(0), ms, 0, 19, 7);
  })(), qs = true), t15.l_desc = new vs(t15.dyn_ltree, ws), t15.d_desc = new vs(t15.dyn_dtree, Ns), t15.bl_desc = new vs(t15.bl_tree, Ls), t15.bi_buf = 0, t15.bi_valid = 0, Bs(t15);
}, _tr_stored_block: Xs, _tr_flush_block: (t15, e2, s, i) => {
  let r, n, o = 0;
  t15.level > 0 ? (2 === t15.strm.data_type && (t15.strm.data_type = ((t16) => {
    let e3, s2 = 4093624447;
    for (e3 = 0; e3 <= 31; e3++, s2 >>>= 1) if (1 & s2 && 0 !== t16.dyn_ltree[2 * e3]) return 0;
    if (0 !== t16.dyn_ltree[18] || 0 !== t16.dyn_ltree[20] || 0 !== t16.dyn_ltree[26]) return 1;
    for (e3 = 32; e3 < Is; e3++) if (0 !== t16.dyn_ltree[2 * e3]) return 1;
    return 0;
  })(t15)), ks(t15, t15.l_desc), ks(t15, t15.d_desc), o = ((t16) => {
    let e3;
    for (Ws(t16, t16.dyn_ltree, t16.l_desc.max_code), Ws(t16, t16.dyn_dtree, t16.d_desc.max_code), ks(t16, t16.bl_desc), e3 = 18; e3 >= 3 && 0 === t16.bl_tree[2 * gs[e3] + 1]; e3--) ;
    return t16.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
  })(t15), r = t15.opt_len + 3 + 7 >>> 3, n = t15.static_len + 3 + 7 >>> 3, n <= r && (r = n)) : r = n = s + 5, s + 4 <= r && -1 !== e2 ? Xs(t15, e2, s, i) : 4 === t15.strategy || n === r ? (xs(t15, 2 + (i ? 1 : 0), 3), Hs(t15, Ts, As)) : (xs(t15, 4 + (i ? 1 : 0), 3), ((t16, e3, s2, i2) => {
    let r2;
    for (xs(t16, e3 - 257, 5), xs(t16, s2 - 1, 5), xs(t16, i2 - 4, 4), r2 = 0; r2 < i2; r2++) xs(t16, t16.bl_tree[2 * gs[r2] + 1], 3);
    js(t16, t16.dyn_ltree, e3 - 1), js(t16, t16.dyn_dtree, s2 - 1);
  })(t15, t15.l_desc.max_code + 1, t15.d_desc.max_code + 1, o + 1), Hs(t15, t15.dyn_ltree, t15.dyn_dtree)), Bs(t15), i && Gs(t15);
}, _tr_tally: (t15, e2, s) => (t15.pending_buf[t15.sym_buf + t15.sym_next++] = e2, t15.pending_buf[t15.sym_buf + t15.sym_next++] = e2 >> 8, t15.pending_buf[t15.sym_buf + t15.sym_next++] = s, 0 === e2 ? t15.dyn_ltree[2 * s]++ : (t15.matches++, e2--, t15.dyn_ltree[2 * (Rs[s] + Is + 1)]++, t15.dyn_dtree[2 * Ms(e2)]++), t15.sym_next === t15.sym_end), _tr_align: (t15) => {
  xs(t15, 2, 3), Us(t15, 256, Ts), ((t16) => {
    16 === t16.bi_valid ? (Ps(t16, t16.bi_buf), t16.bi_buf = 0, t16.bi_valid = 0) : t16.bi_valid >= 8 && (t16.pending_buf[t16.pending++] = 255 & t16.bi_buf, t16.bi_buf >>= 8, t16.bi_valid -= 8);
  })(t15);
} };
var Ks = (t15, e2, s, i) => {
  let r = 65535 & t15, n = t15 >>> 16 & 65535, o = 0;
  for (; 0 !== s; ) {
    o = s > 2e3 ? 2e3 : s, s -= o;
    do {
      r = r + e2[i++] | 0, n = n + r | 0;
    } while (--o);
    r %= 65521, n %= 65521;
  }
  return r | n << 16;
};
var $s = new Uint32Array((() => {
  let t15, e2 = [];
  for (var s = 0; s < 256; s++) {
    t15 = s;
    for (var i = 0; i < 8; i++) t15 = 1 & t15 ? 3988292384 ^ t15 >>> 1 : t15 >>> 1;
    e2[s] = t15;
  }
  return e2;
})());
var Qs = (t15, e2, s, i) => {
  const r = $s, n = i + s;
  t15 ^= -1;
  for (let s2 = i; s2 < n; s2++) t15 = t15 >>> 8 ^ r[255 & (t15 ^ e2[s2])];
  return ~t15;
};
var Js = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
var ti = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
var { _tr_init: ei, _tr_stored_block: si, _tr_flush_block: ii, _tr_tally: ri, _tr_align: ni } = Zs;
var { Z_NO_FLUSH: oi, Z_PARTIAL_FLUSH: ai, Z_FULL_FLUSH: ci, Z_FINISH: hi, Z_BLOCK: li, Z_OK: di, Z_STREAM_END: bi, Z_STREAM_ERROR: ui, Z_DATA_ERROR: Ii, Z_BUF_ERROR: fi, Z_DEFAULT_COMPRESSION: _i, Z_FILTERED: Ei, Z_HUFFMAN_ONLY: pi, Z_RLE: Ci, Z_FIXED: mi, Z_DEFAULT_STRATEGY: gi, Z_UNKNOWN: Ti, Z_DEFLATED: Ai } = ti;
var Fi = 258;
var Ri = 262;
var yi = 42;
var Oi = 113;
var Si = 666;
var wi = (t15, e2) => (t15.msg = Js[e2], e2);
var Ni = (t15) => 2 * t15 - (t15 > 4 ? 9 : 0);
var Li = (t15) => {
  let e2 = t15.length;
  for (; --e2 >= 0; ) t15[e2] = 0;
};
var vi = (t15) => {
  let e2, s, i, r = t15.w_size;
  e2 = t15.hash_size, i = e2;
  do {
    s = t15.head[--i], t15.head[i] = s >= r ? s - r : 0;
  } while (--e2);
  e2 = r, i = e2;
  do {
    s = t15.prev[--i], t15.prev[i] = s >= r ? s - r : 0;
  } while (--e2);
};
var Mi = (t15, e2, s) => (e2 << t15.hash_shift ^ s) & t15.hash_mask;
var Pi = (t15) => {
  const e2 = t15.state;
  let s = e2.pending;
  s > t15.avail_out && (s = t15.avail_out), 0 !== s && (t15.output.set(e2.pending_buf.subarray(e2.pending_out, e2.pending_out + s), t15.next_out), t15.next_out += s, e2.pending_out += s, t15.total_out += s, t15.avail_out -= s, e2.pending -= s, 0 === e2.pending && (e2.pending_out = 0));
};
var xi = (t15, e2) => {
  ii(t15, t15.block_start >= 0 ? t15.block_start : -1, t15.strstart - t15.block_start, e2), t15.block_start = t15.strstart, Pi(t15.strm);
};
var Ui = (t15, e2) => {
  t15.pending_buf[t15.pending++] = e2;
};
var Di = (t15, e2) => {
  t15.pending_buf[t15.pending++] = e2 >>> 8 & 255, t15.pending_buf[t15.pending++] = 255 & e2;
};
var Vi = (t15, e2, s, i) => {
  let r = t15.avail_in;
  return r > i && (r = i), 0 === r ? 0 : (t15.avail_in -= r, e2.set(t15.input.subarray(t15.next_in, t15.next_in + r), s), 1 === t15.state.wrap ? t15.adler = Ks(t15.adler, e2, r, s) : 2 === t15.state.wrap && (t15.adler = Qs(t15.adler, e2, r, s)), t15.next_in += r, t15.total_in += r, r);
};
var Bi = (t15, e2) => {
  let s, i, r = t15.max_chain_length, n = t15.strstart, o = t15.prev_length, a = t15.nice_match;
  const c = t15.strstart > t15.w_size - Ri ? t15.strstart - (t15.w_size - Ri) : 0, h = t15.window, l = t15.w_mask, d = t15.prev, b = t15.strstart + Fi;
  let u = h[n + o - 1], I = h[n + o];
  t15.prev_length >= t15.good_match && (r >>= 2), a > t15.lookahead && (a = t15.lookahead);
  do {
    if (s = e2, h[s + o] === I && h[s + o - 1] === u && h[s] === h[n] && h[++s] === h[n + 1]) {
      n += 2, s++;
      do {
      } while (h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && h[++n] === h[++s] && n < b);
      if (i = Fi - (b - n), n = b - Fi, i > o) {
        if (t15.match_start = e2, o = i, i >= a) break;
        u = h[n + o - 1], I = h[n + o];
      }
    }
  } while ((e2 = d[e2 & l]) > c && 0 != --r);
  return o <= t15.lookahead ? o : t15.lookahead;
};
var Gi = (t15) => {
  const e2 = t15.w_size;
  let s, i, r;
  do {
    if (i = t15.window_size - t15.lookahead - t15.strstart, t15.strstart >= e2 + (e2 - Ri) && (t15.window.set(t15.window.subarray(e2, e2 + e2 - i), 0), t15.match_start -= e2, t15.strstart -= e2, t15.block_start -= e2, t15.insert > t15.strstart && (t15.insert = t15.strstart), vi(t15), i += e2), 0 === t15.strm.avail_in) break;
    if (s = Vi(t15.strm, t15.window, t15.strstart + t15.lookahead, i), t15.lookahead += s, t15.lookahead + t15.insert >= 3) for (r = t15.strstart - t15.insert, t15.ins_h = t15.window[r], t15.ins_h = Mi(t15, t15.ins_h, t15.window[r + 1]); t15.insert && (t15.ins_h = Mi(t15, t15.ins_h, t15.window[r + 3 - 1]), t15.prev[r & t15.w_mask] = t15.head[t15.ins_h], t15.head[t15.ins_h] = r, r++, t15.insert--, !(t15.lookahead + t15.insert < 3)); ) ;
  } while (t15.lookahead < Ri && 0 !== t15.strm.avail_in);
};
var zi = (t15, e2) => {
  let s, i, r, n = t15.pending_buf_size - 5 > t15.w_size ? t15.w_size : t15.pending_buf_size - 5, o = 0, a = t15.strm.avail_in;
  do {
    if (s = 65535, r = t15.bi_valid + 42 >> 3, t15.strm.avail_out < r) break;
    if (r = t15.strm.avail_out - r, i = t15.strstart - t15.block_start, s > i + t15.strm.avail_in && (s = i + t15.strm.avail_in), s > r && (s = r), s < n && (0 === s && e2 !== hi || e2 === oi || s !== i + t15.strm.avail_in)) break;
    o = e2 === hi && s === i + t15.strm.avail_in ? 1 : 0, si(t15, 0, 0, o), t15.pending_buf[t15.pending - 4] = s, t15.pending_buf[t15.pending - 3] = s >> 8, t15.pending_buf[t15.pending - 2] = ~s, t15.pending_buf[t15.pending - 1] = ~s >> 8, Pi(t15.strm), i && (i > s && (i = s), t15.strm.output.set(t15.window.subarray(t15.block_start, t15.block_start + i), t15.strm.next_out), t15.strm.next_out += i, t15.strm.avail_out -= i, t15.strm.total_out += i, t15.block_start += i, s -= i), s && (Vi(t15.strm, t15.strm.output, t15.strm.next_out, s), t15.strm.next_out += s, t15.strm.avail_out -= s, t15.strm.total_out += s);
  } while (0 === o);
  return a -= t15.strm.avail_in, a && (a >= t15.w_size ? (t15.matches = 2, t15.window.set(t15.strm.input.subarray(t15.strm.next_in - t15.w_size, t15.strm.next_in), 0), t15.strstart = t15.w_size, t15.insert = t15.strstart) : (t15.window_size - t15.strstart <= a && (t15.strstart -= t15.w_size, t15.window.set(t15.window.subarray(t15.w_size, t15.w_size + t15.strstart), 0), t15.matches < 2 && t15.matches++, t15.insert > t15.strstart && (t15.insert = t15.strstart)), t15.window.set(t15.strm.input.subarray(t15.strm.next_in - a, t15.strm.next_in), t15.strstart), t15.strstart += a, t15.insert += a > t15.w_size - t15.insert ? t15.w_size - t15.insert : a), t15.block_start = t15.strstart), t15.high_water < t15.strstart && (t15.high_water = t15.strstart), o ? 4 : e2 !== oi && e2 !== hi && 0 === t15.strm.avail_in && t15.strstart === t15.block_start ? 2 : (r = t15.window_size - t15.strstart, t15.strm.avail_in > r && t15.block_start >= t15.w_size && (t15.block_start -= t15.w_size, t15.strstart -= t15.w_size, t15.window.set(t15.window.subarray(t15.w_size, t15.w_size + t15.strstart), 0), t15.matches < 2 && t15.matches++, r += t15.w_size, t15.insert > t15.strstart && (t15.insert = t15.strstart)), r > t15.strm.avail_in && (r = t15.strm.avail_in), r && (Vi(t15.strm, t15.window, t15.strstart, r), t15.strstart += r, t15.insert += r > t15.w_size - t15.insert ? t15.w_size - t15.insert : r), t15.high_water < t15.strstart && (t15.high_water = t15.strstart), r = t15.bi_valid + 42 >> 3, r = t15.pending_buf_size - r > 65535 ? 65535 : t15.pending_buf_size - r, n = r > t15.w_size ? t15.w_size : r, i = t15.strstart - t15.block_start, (i >= n || (i || e2 === hi) && e2 !== oi && 0 === t15.strm.avail_in && i <= r) && (s = i > r ? r : i, o = e2 === hi && 0 === t15.strm.avail_in && s === i ? 1 : 0, si(t15, t15.block_start, s, o), t15.block_start += s, Pi(t15.strm)), o ? 3 : 1);
};
var Yi = (t15, e2) => {
  let s, i;
  for (; ; ) {
    if (t15.lookahead < Ri) {
      if (Gi(t15), t15.lookahead < Ri && e2 === oi) return 1;
      if (0 === t15.lookahead) break;
    }
    if (s = 0, t15.lookahead >= 3 && (t15.ins_h = Mi(t15, t15.ins_h, t15.window[t15.strstart + 3 - 1]), s = t15.prev[t15.strstart & t15.w_mask] = t15.head[t15.ins_h], t15.head[t15.ins_h] = t15.strstart), 0 !== s && t15.strstart - s <= t15.w_size - Ri && (t15.match_length = Bi(t15, s)), t15.match_length >= 3) if (i = ri(t15, t15.strstart - t15.match_start, t15.match_length - 3), t15.lookahead -= t15.match_length, t15.match_length <= t15.max_lazy_match && t15.lookahead >= 3) {
      t15.match_length--;
      do {
        t15.strstart++, t15.ins_h = Mi(t15, t15.ins_h, t15.window[t15.strstart + 3 - 1]), s = t15.prev[t15.strstart & t15.w_mask] = t15.head[t15.ins_h], t15.head[t15.ins_h] = t15.strstart;
      } while (0 != --t15.match_length);
      t15.strstart++;
    } else t15.strstart += t15.match_length, t15.match_length = 0, t15.ins_h = t15.window[t15.strstart], t15.ins_h = Mi(t15, t15.ins_h, t15.window[t15.strstart + 1]);
    else i = ri(t15, 0, t15.window[t15.strstart]), t15.lookahead--, t15.strstart++;
    if (i && (xi(t15, false), 0 === t15.strm.avail_out)) return 1;
  }
  return t15.insert = t15.strstart < 2 ? t15.strstart : 2, e2 === hi ? (xi(t15, true), 0 === t15.strm.avail_out ? 3 : 4) : t15.sym_next && (xi(t15, false), 0 === t15.strm.avail_out) ? 1 : 2;
};
var Hi = (t15, e2) => {
  let s, i, r;
  for (; ; ) {
    if (t15.lookahead < Ri) {
      if (Gi(t15), t15.lookahead < Ri && e2 === oi) return 1;
      if (0 === t15.lookahead) break;
    }
    if (s = 0, t15.lookahead >= 3 && (t15.ins_h = Mi(t15, t15.ins_h, t15.window[t15.strstart + 3 - 1]), s = t15.prev[t15.strstart & t15.w_mask] = t15.head[t15.ins_h], t15.head[t15.ins_h] = t15.strstart), t15.prev_length = t15.match_length, t15.prev_match = t15.match_start, t15.match_length = 2, 0 !== s && t15.prev_length < t15.max_lazy_match && t15.strstart - s <= t15.w_size - Ri && (t15.match_length = Bi(t15, s), t15.match_length <= 5 && (t15.strategy === Ei || 3 === t15.match_length && t15.strstart - t15.match_start > 4096) && (t15.match_length = 2)), t15.prev_length >= 3 && t15.match_length <= t15.prev_length) {
      r = t15.strstart + t15.lookahead - 3, i = ri(t15, t15.strstart - 1 - t15.prev_match, t15.prev_length - 3), t15.lookahead -= t15.prev_length - 1, t15.prev_length -= 2;
      do {
        ++t15.strstart <= r && (t15.ins_h = Mi(t15, t15.ins_h, t15.window[t15.strstart + 3 - 1]), s = t15.prev[t15.strstart & t15.w_mask] = t15.head[t15.ins_h], t15.head[t15.ins_h] = t15.strstart);
      } while (0 != --t15.prev_length);
      if (t15.match_available = 0, t15.match_length = 2, t15.strstart++, i && (xi(t15, false), 0 === t15.strm.avail_out)) return 1;
    } else if (t15.match_available) {
      if (i = ri(t15, 0, t15.window[t15.strstart - 1]), i && xi(t15, false), t15.strstart++, t15.lookahead--, 0 === t15.strm.avail_out) return 1;
    } else t15.match_available = 1, t15.strstart++, t15.lookahead--;
  }
  return t15.match_available && (i = ri(t15, 0, t15.window[t15.strstart - 1]), t15.match_available = 0), t15.insert = t15.strstart < 2 ? t15.strstart : 2, e2 === hi ? (xi(t15, true), 0 === t15.strm.avail_out ? 3 : 4) : t15.sym_next && (xi(t15, false), 0 === t15.strm.avail_out) ? 1 : 2;
};
function ki(t15, e2, s, i, r) {
  this.good_length = t15, this.max_lazy = e2, this.nice_length = s, this.max_chain = i, this.func = r;
}
var Wi = [new ki(0, 0, 0, 0, zi), new ki(4, 4, 8, 4, Yi), new ki(4, 5, 16, 8, Yi), new ki(4, 6, 32, 32, Yi), new ki(4, 4, 16, 16, Hi), new ki(8, 16, 32, 32, Hi), new ki(8, 16, 128, 128, Hi), new ki(8, 32, 128, 256, Hi), new ki(32, 128, 258, 1024, Hi), new ki(32, 258, 258, 4096, Hi)];
function ji() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Ai, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Li(this.dyn_ltree), Li(this.dyn_dtree), Li(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Li(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Li(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
var qi = (t15) => {
  if (!t15) return 1;
  const e2 = t15.state;
  return !e2 || e2.strm !== t15 || e2.status !== yi && 57 !== e2.status && 69 !== e2.status && 73 !== e2.status && 91 !== e2.status && 103 !== e2.status && e2.status !== Oi && e2.status !== Si ? 1 : 0;
};
var Xi = (t15) => {
  if (qi(t15)) return wi(t15, ui);
  t15.total_in = t15.total_out = 0, t15.data_type = Ti;
  const e2 = t15.state;
  return e2.pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = 2 === e2.wrap ? 57 : e2.wrap ? yi : Oi, t15.adler = 2 === e2.wrap ? 0 : 1, e2.last_flush = -2, ei(e2), di;
};
var Zi = (t15) => {
  const e2 = Xi(t15);
  var s;
  return e2 === di && ((s = t15.state).window_size = 2 * s.w_size, Li(s.head), s.max_lazy_match = Wi[s.level].max_lazy, s.good_match = Wi[s.level].good_length, s.nice_match = Wi[s.level].nice_length, s.max_chain_length = Wi[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = 2, s.match_available = 0, s.ins_h = 0), e2;
};
var Ki = (t15, e2, s, i, r, n) => {
  if (!t15) return ui;
  let o = 1;
  if (e2 === _i && (e2 = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), r < 1 || r > 9 || s !== Ai || i < 8 || i > 15 || e2 < 0 || e2 > 9 || n < 0 || n > mi || 8 === i && 1 !== o) return wi(t15, ui);
  8 === i && (i = 9);
  const a = new ji();
  return t15.state = a, a.strm = t15, a.status = yi, a.wrap = o, a.gzhead = null, a.w_bits = i, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = e2, a.strategy = n, a.method = s, Zi(t15);
};
var $i = { deflateInit: (t15, e2) => Ki(t15, e2, Ai, 15, 8, gi), deflateInit2: Ki, deflateReset: Zi, deflateResetKeep: Xi, deflateSetHeader: (t15, e2) => qi(t15) || 2 !== t15.state.wrap ? ui : (t15.state.gzhead = e2, di), deflate: (t15, e2) => {
  if (qi(t15) || e2 > li || e2 < 0) return t15 ? wi(t15, ui) : ui;
  const s = t15.state;
  if (!t15.output || 0 !== t15.avail_in && !t15.input || s.status === Si && e2 !== hi) return wi(t15, 0 === t15.avail_out ? fi : ui);
  const i = s.last_flush;
  if (s.last_flush = e2, 0 !== s.pending) {
    if (Pi(t15), 0 === t15.avail_out) return s.last_flush = -1, di;
  } else if (0 === t15.avail_in && Ni(e2) <= Ni(i) && e2 !== hi) return wi(t15, fi);
  if (s.status === Si && 0 !== t15.avail_in) return wi(t15, fi);
  if (s.status === yi && 0 === s.wrap && (s.status = Oi), s.status === yi) {
    let e3 = Ai + (s.w_bits - 8 << 4) << 8, i2 = -1;
    if (i2 = s.strategy >= pi || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3, e3 |= i2 << 6, 0 !== s.strstart && (e3 |= 32), e3 += 31 - e3 % 31, Di(s, e3), 0 !== s.strstart && (Di(s, t15.adler >>> 16), Di(s, 65535 & t15.adler)), t15.adler = 1, s.status = Oi, Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
  }
  if (57 === s.status) {
    if (t15.adler = 0, Ui(s, 31), Ui(s, 139), Ui(s, 8), s.gzhead) Ui(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), Ui(s, 255 & s.gzhead.time), Ui(s, s.gzhead.time >> 8 & 255), Ui(s, s.gzhead.time >> 16 & 255), Ui(s, s.gzhead.time >> 24 & 255), Ui(s, 9 === s.level ? 2 : s.strategy >= pi || s.level < 2 ? 4 : 0), Ui(s, 255 & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (Ui(s, 255 & s.gzhead.extra.length), Ui(s, s.gzhead.extra.length >> 8 & 255)), s.gzhead.hcrc && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending, 0)), s.gzindex = 0, s.status = 69;
    else if (Ui(s, 0), Ui(s, 0), Ui(s, 0), Ui(s, 0), Ui(s, 0), Ui(s, 9 === s.level ? 2 : s.strategy >= pi || s.level < 2 ? 4 : 0), Ui(s, 3), s.status = Oi, Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
  }
  if (69 === s.status) {
    if (s.gzhead.extra) {
      let e3 = s.pending, i2 = (65535 & s.gzhead.extra.length) - s.gzindex;
      for (; s.pending + i2 > s.pending_buf_size; ) {
        let r2 = s.pending_buf_size - s.pending;
        if (s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + r2), s.pending), s.pending = s.pending_buf_size, s.gzhead.hcrc && s.pending > e3 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - e3, e3)), s.gzindex += r2, Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
        e3 = 0, i2 -= r2;
      }
      let r = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(r.subarray(s.gzindex, s.gzindex + i2), s.pending), s.pending += i2, s.gzhead.hcrc && s.pending > e3 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - e3, e3)), s.gzindex = 0;
    }
    s.status = 73;
  }
  if (73 === s.status) {
    if (s.gzhead.name) {
      let e3, i2 = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > i2 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - i2, i2)), Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
          i2 = 0;
        }
        e3 = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0, Ui(s, e3);
      } while (0 !== e3);
      s.gzhead.hcrc && s.pending > i2 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - i2, i2)), s.gzindex = 0;
    }
    s.status = 91;
  }
  if (91 === s.status) {
    if (s.gzhead.comment) {
      let e3, i2 = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > i2 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - i2, i2)), Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
          i2 = 0;
        }
        e3 = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, Ui(s, e3);
      } while (0 !== e3);
      s.gzhead.hcrc && s.pending > i2 && (t15.adler = Qs(t15.adler, s.pending_buf, s.pending - i2, i2));
    }
    s.status = 103;
  }
  if (103 === s.status) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size && (Pi(t15), 0 !== s.pending)) return s.last_flush = -1, di;
      Ui(s, 255 & t15.adler), Ui(s, t15.adler >> 8 & 255), t15.adler = 0;
    }
    if (s.status = Oi, Pi(t15), 0 !== s.pending) return s.last_flush = -1, di;
  }
  if (0 !== t15.avail_in || 0 !== s.lookahead || e2 !== oi && s.status !== Si) {
    let i2 = 0 === s.level ? zi(s, e2) : s.strategy === pi ? ((t16, e3) => {
      let s2;
      for (; ; ) {
        if (0 === t16.lookahead && (Gi(t16), 0 === t16.lookahead)) {
          if (e3 === oi) return 1;
          break;
        }
        if (t16.match_length = 0, s2 = ri(t16, 0, t16.window[t16.strstart]), t16.lookahead--, t16.strstart++, s2 && (xi(t16, false), 0 === t16.strm.avail_out)) return 1;
      }
      return t16.insert = 0, e3 === hi ? (xi(t16, true), 0 === t16.strm.avail_out ? 3 : 4) : t16.sym_next && (xi(t16, false), 0 === t16.strm.avail_out) ? 1 : 2;
    })(s, e2) : s.strategy === Ci ? ((t16, e3) => {
      let s2, i3, r, n;
      const o = t16.window;
      for (; ; ) {
        if (t16.lookahead <= Fi) {
          if (Gi(t16), t16.lookahead <= Fi && e3 === oi) return 1;
          if (0 === t16.lookahead) break;
        }
        if (t16.match_length = 0, t16.lookahead >= 3 && t16.strstart > 0 && (r = t16.strstart - 1, i3 = o[r], i3 === o[++r] && i3 === o[++r] && i3 === o[++r])) {
          n = t16.strstart + Fi;
          do {
          } while (i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && i3 === o[++r] && r < n);
          t16.match_length = Fi - (n - r), t16.match_length > t16.lookahead && (t16.match_length = t16.lookahead);
        }
        if (t16.match_length >= 3 ? (s2 = ri(t16, 1, t16.match_length - 3), t16.lookahead -= t16.match_length, t16.strstart += t16.match_length, t16.match_length = 0) : (s2 = ri(t16, 0, t16.window[t16.strstart]), t16.lookahead--, t16.strstart++), s2 && (xi(t16, false), 0 === t16.strm.avail_out)) return 1;
      }
      return t16.insert = 0, e3 === hi ? (xi(t16, true), 0 === t16.strm.avail_out ? 3 : 4) : t16.sym_next && (xi(t16, false), 0 === t16.strm.avail_out) ? 1 : 2;
    })(s, e2) : Wi[s.level].func(s, e2);
    if (3 !== i2 && 4 !== i2 || (s.status = Si), 1 === i2 || 3 === i2) return 0 === t15.avail_out && (s.last_flush = -1), di;
    if (2 === i2 && (e2 === ai ? ni(s) : e2 !== li && (si(s, 0, 0, false), e2 === ci && (Li(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, s.insert = 0))), Pi(t15), 0 === t15.avail_out)) return s.last_flush = -1, di;
  }
  return e2 !== hi ? di : s.wrap <= 0 ? bi : (2 === s.wrap ? (Ui(s, 255 & t15.adler), Ui(s, t15.adler >> 8 & 255), Ui(s, t15.adler >> 16 & 255), Ui(s, t15.adler >> 24 & 255), Ui(s, 255 & t15.total_in), Ui(s, t15.total_in >> 8 & 255), Ui(s, t15.total_in >> 16 & 255), Ui(s, t15.total_in >> 24 & 255)) : (Di(s, t15.adler >>> 16), Di(s, 65535 & t15.adler)), Pi(t15), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? di : bi);
}, deflateEnd: (t15) => {
  if (qi(t15)) return ui;
  const e2 = t15.state.status;
  return t15.state = null, e2 === Oi ? wi(t15, Ii) : di;
}, deflateSetDictionary: (t15, e2) => {
  let s = e2.length;
  if (qi(t15)) return ui;
  const i = t15.state, r = i.wrap;
  if (2 === r || 1 === r && i.status !== yi || i.lookahead) return ui;
  if (1 === r && (t15.adler = Ks(t15.adler, e2, s, 0)), i.wrap = 0, s >= i.w_size) {
    0 === r && (Li(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
    let t16 = new Uint8Array(i.w_size);
    t16.set(e2.subarray(s - i.w_size, s), 0), e2 = t16, s = i.w_size;
  }
  const n = t15.avail_in, o = t15.next_in, a = t15.input;
  for (t15.avail_in = s, t15.next_in = 0, t15.input = e2, Gi(i); i.lookahead >= 3; ) {
    let t16 = i.strstart, e3 = i.lookahead - 2;
    do {
      i.ins_h = Mi(i, i.ins_h, i.window[t16 + 3 - 1]), i.prev[t16 & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = t16, t16++;
    } while (--e3);
    i.strstart = t16, i.lookahead = 2, Gi(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t15.next_in = o, t15.input = a, t15.avail_in = n, i.wrap = r, di;
}, deflateInfo: "pako deflate (from Nodeca project)" };
var Qi = (t15, e2) => Object.prototype.hasOwnProperty.call(t15, e2);
var Ji = function(t15) {
  const e2 = Array.prototype.slice.call(arguments, 1);
  for (; e2.length; ) {
    const s = e2.shift();
    if (s) {
      if ("object" != typeof s) throw new TypeError(s + "must be non-object");
      for (const e3 in s) Qi(s, e3) && (t15[e3] = s[e3]);
    }
  }
  return t15;
};
var tr = (t15) => {
  let e2 = 0;
  for (let s2 = 0, i = t15.length; s2 < i; s2++) e2 += t15[s2].length;
  const s = new Uint8Array(e2);
  for (let e3 = 0, i = 0, r = t15.length; e3 < r; e3++) {
    let r2 = t15[e3];
    s.set(r2, i), i += r2.length;
  }
  return s;
};
var er = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (t15) {
  er = false;
}
var sr = new Uint8Array(256);
for (let t15 = 0; t15 < 256; t15++) sr[t15] = t15 >= 252 ? 6 : t15 >= 248 ? 5 : t15 >= 240 ? 4 : t15 >= 224 ? 3 : t15 >= 192 ? 2 : 1;
sr[254] = sr[254] = 1;
var ir = (t15) => {
  if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t15);
  let e2, s, i, r, n, o = t15.length, a = 0;
  for (r = 0; r < o; r++) s = t15.charCodeAt(r), 55296 == (64512 & s) && r + 1 < o && (i = t15.charCodeAt(r + 1), 56320 == (64512 & i) && (s = 65536 + (s - 55296 << 10) + (i - 56320), r++)), a += s < 128 ? 1 : s < 2048 ? 2 : s < 65536 ? 3 : 4;
  for (e2 = new Uint8Array(a), n = 0, r = 0; n < a; r++) s = t15.charCodeAt(r), 55296 == (64512 & s) && r + 1 < o && (i = t15.charCodeAt(r + 1), 56320 == (64512 & i) && (s = 65536 + (s - 55296 << 10) + (i - 56320), r++)), s < 128 ? e2[n++] = s : s < 2048 ? (e2[n++] = 192 | s >>> 6, e2[n++] = 128 | 63 & s) : s < 65536 ? (e2[n++] = 224 | s >>> 12, e2[n++] = 128 | s >>> 6 & 63, e2[n++] = 128 | 63 & s) : (e2[n++] = 240 | s >>> 18, e2[n++] = 128 | s >>> 12 & 63, e2[n++] = 128 | s >>> 6 & 63, e2[n++] = 128 | 63 & s);
  return e2;
};
var rr = (t15, e2) => {
  const s = e2 || t15.length;
  if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(t15.subarray(0, e2));
  let i, r;
  const n = new Array(2 * s);
  for (r = 0, i = 0; i < s; ) {
    let e3 = t15[i++];
    if (e3 < 128) {
      n[r++] = e3;
      continue;
    }
    let o = sr[e3];
    if (o > 4) n[r++] = 65533, i += o - 1;
    else {
      for (e3 &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && i < s; ) e3 = e3 << 6 | 63 & t15[i++], o--;
      o > 1 ? n[r++] = 65533 : e3 < 65536 ? n[r++] = e3 : (e3 -= 65536, n[r++] = 55296 | e3 >> 10 & 1023, n[r++] = 56320 | 1023 & e3);
    }
  }
  return ((t16, e3) => {
    if (e3 < 65534 && t16.subarray && er) return String.fromCharCode.apply(null, t16.length === e3 ? t16 : t16.subarray(0, e3));
    let s2 = "";
    for (let i2 = 0; i2 < e3; i2++) s2 += String.fromCharCode(t16[i2]);
    return s2;
  })(n, r);
};
var nr = (t15, e2) => {
  (e2 = e2 || t15.length) > t15.length && (e2 = t15.length);
  let s = e2 - 1;
  for (; s >= 0 && 128 == (192 & t15[s]); ) s--;
  return s < 0 || 0 === s ? e2 : s + sr[t15[s]] > e2 ? s : e2;
};
var or = function() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
var ar = Object.prototype.toString;
var { Z_NO_FLUSH: cr, Z_SYNC_FLUSH: hr, Z_FULL_FLUSH: lr, Z_FINISH: dr, Z_OK: br, Z_STREAM_END: ur, Z_DEFAULT_COMPRESSION: Ir, Z_DEFAULT_STRATEGY: fr, Z_DEFLATED: _r } = ti;
function Er(t15) {
  this.options = Ji({ level: Ir, method: _r, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: fr }, t15 || {});
  let e2 = this.options;
  e2.raw && e2.windowBits > 0 ? e2.windowBits = -e2.windowBits : e2.gzip && e2.windowBits > 0 && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new or(), this.strm.avail_out = 0;
  let s = $i.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
  if (s !== br) throw new Error(Js[s]);
  if (e2.header && $i.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
    let t16;
    if (t16 = "string" == typeof e2.dictionary ? ir(e2.dictionary) : "[object ArrayBuffer]" === ar.call(e2.dictionary) ? new Uint8Array(e2.dictionary) : e2.dictionary, s = $i.deflateSetDictionary(this.strm, t16), s !== br) throw new Error(Js[s]);
    this._dict_set = true;
  }
}
function pr(t15, e2) {
  const s = new Er(e2);
  if (s.push(t15, true), s.err) throw s.msg || Js[s.err];
  return s.result;
}
Er.prototype.push = function(t15, e2) {
  const s = this.strm, i = this.options.chunkSize;
  let r, n;
  if (this.ended) return false;
  for (n = e2 === ~~e2 ? e2 : true === e2 ? dr : cr, "string" == typeof t15 ? s.input = ir(t15) : "[object ArrayBuffer]" === ar.call(t15) ? s.input = new Uint8Array(t15) : s.input = t15, s.next_in = 0, s.avail_in = s.input.length; ; ) if (0 === s.avail_out && (s.output = new Uint8Array(i), s.next_out = 0, s.avail_out = i), (n === hr || n === lr) && s.avail_out <= 6) this.onData(s.output.subarray(0, s.next_out)), s.avail_out = 0;
  else {
    if (r = $i.deflate(s, n), r === ur) return s.next_out > 0 && this.onData(s.output.subarray(0, s.next_out)), r = $i.deflateEnd(this.strm), this.onEnd(r), this.ended = true, r === br;
    if (0 !== s.avail_out) {
      if (n > 0 && s.next_out > 0) this.onData(s.output.subarray(0, s.next_out)), s.avail_out = 0;
      else if (0 === s.avail_in) break;
    } else this.onData(s.output);
  }
  return true;
}, Er.prototype.onData = function(t15) {
  this.chunks.push(t15);
}, Er.prototype.onEnd = function(t15) {
  t15 === br && (this.result = tr(this.chunks)), this.chunks = [], this.err = t15, this.msg = this.strm.msg;
};
var Cr = { Deflate: Er, deflate: pr, deflateRaw: function(t15, e2) {
  return (e2 = e2 || {}).raw = true, pr(t15, e2);
}, gzip: function(t15, e2) {
  return (e2 = e2 || {}).gzip = true, pr(t15, e2);
} };
var mr = 16209;
var gr = function(t15, e2) {
  let s, i, r, n, o, a, c, h, l, d, b, u, I, f, _, E, p, C, m, g, T, A, F, R;
  const y = t15.state;
  s = t15.next_in, F = t15.input, i = s + (t15.avail_in - 5), r = t15.next_out, R = t15.output, n = r - (e2 - t15.avail_out), o = r + (t15.avail_out - 257), a = y.dmax, c = y.wsize, h = y.whave, l = y.wnext, d = y.window, b = y.hold, u = y.bits, I = y.lencode, f = y.distcode, _ = (1 << y.lenbits) - 1, E = (1 << y.distbits) - 1;
  t: do {
    u < 15 && (b += F[s++] << u, u += 8, b += F[s++] << u, u += 8), p = I[b & _];
    e: for (; ; ) {
      if (C = p >>> 24, b >>>= C, u -= C, C = p >>> 16 & 255, 0 === C) R[r++] = 65535 & p;
      else {
        if (!(16 & C)) {
          if (64 & C) {
            if (32 & C) {
              y.mode = 16191;
              break t;
            }
            t15.msg = "invalid literal/length code", y.mode = mr;
            break t;
          }
          p = I[(65535 & p) + (b & (1 << C) - 1)];
          continue e;
        }
        for (m = 65535 & p, C &= 15, C && (u < C && (b += F[s++] << u, u += 8), m += b & (1 << C) - 1, b >>>= C, u -= C), u < 15 && (b += F[s++] << u, u += 8, b += F[s++] << u, u += 8), p = f[b & E]; ; ) {
          if (C = p >>> 24, b >>>= C, u -= C, C = p >>> 16 & 255, 16 & C) {
            if (g = 65535 & p, C &= 15, u < C && (b += F[s++] << u, u += 8, u < C && (b += F[s++] << u, u += 8)), g += b & (1 << C) - 1, g > a) {
              t15.msg = "invalid distance too far back", y.mode = mr;
              break t;
            }
            if (b >>>= C, u -= C, C = r - n, g > C) {
              if (C = g - C, C > h && y.sane) {
                t15.msg = "invalid distance too far back", y.mode = mr;
                break t;
              }
              if (T = 0, A = d, 0 === l) {
                if (T += c - C, C < m) {
                  m -= C;
                  do {
                    R[r++] = d[T++];
                  } while (--C);
                  T = r - g, A = R;
                }
              } else if (l < C) {
                if (T += c + l - C, C -= l, C < m) {
                  m -= C;
                  do {
                    R[r++] = d[T++];
                  } while (--C);
                  if (T = 0, l < m) {
                    C = l, m -= C;
                    do {
                      R[r++] = d[T++];
                    } while (--C);
                    T = r - g, A = R;
                  }
                }
              } else if (T += l - C, C < m) {
                m -= C;
                do {
                  R[r++] = d[T++];
                } while (--C);
                T = r - g, A = R;
              }
              for (; m > 2; ) R[r++] = A[T++], R[r++] = A[T++], R[r++] = A[T++], m -= 3;
              m && (R[r++] = A[T++], m > 1 && (R[r++] = A[T++]));
            } else {
              T = r - g;
              do {
                R[r++] = R[T++], R[r++] = R[T++], R[r++] = R[T++], m -= 3;
              } while (m > 2);
              m && (R[r++] = R[T++], m > 1 && (R[r++] = R[T++]));
            }
            break;
          }
          if (64 & C) {
            t15.msg = "invalid distance code", y.mode = mr;
            break t;
          }
          p = f[(65535 & p) + (b & (1 << C) - 1)];
        }
      }
      break;
    }
  } while (s < i && r < o);
  m = u >> 3, s -= m, u -= m << 3, b &= (1 << u) - 1, t15.next_in = s, t15.next_out = r, t15.avail_in = s < i ? i - s + 5 : 5 - (s - i), t15.avail_out = r < o ? o - r + 257 : 257 - (r - o), y.hold = b, y.bits = u;
};
var Tr = 15;
var Ar = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
var Fr = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
var Rr = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
var yr = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var Or = (t15, e2, s, i, r, n, o, a) => {
  const c = a.bits;
  let h, l, d, b, u, I, f = 0, _ = 0, E = 0, p = 0, C = 0, m = 0, g = 0, T = 0, A = 0, F = 0, R = null;
  const y = new Uint16Array(16), O = new Uint16Array(16);
  let S, w, N, L = null;
  for (f = 0; f <= Tr; f++) y[f] = 0;
  for (_ = 0; _ < i; _++) y[e2[s + _]]++;
  for (C = c, p = Tr; p >= 1 && 0 === y[p]; p--) ;
  if (C > p && (C = p), 0 === p) return r[n++] = 20971520, r[n++] = 20971520, a.bits = 1, 0;
  for (E = 1; E < p && 0 === y[E]; E++) ;
  for (C < E && (C = E), T = 1, f = 1; f <= Tr; f++) if (T <<= 1, T -= y[f], T < 0) return -1;
  if (T > 0 && (0 === t15 || 1 !== p)) return -1;
  for (O[1] = 0, f = 1; f < Tr; f++) O[f + 1] = O[f] + y[f];
  for (_ = 0; _ < i; _++) 0 !== e2[s + _] && (o[O[e2[s + _]]++] = _);
  if (0 === t15 ? (R = L = o, I = 20) : 1 === t15 ? (R = Ar, L = Fr, I = 257) : (R = Rr, L = yr, I = 0), F = 0, _ = 0, f = E, u = n, m = C, g = 0, d = -1, A = 1 << C, b = A - 1, 1 === t15 && A > 852 || 2 === t15 && A > 592) return 1;
  for (; ; ) {
    S = f - g, o[_] + 1 < I ? (w = 0, N = o[_]) : o[_] >= I ? (w = L[o[_] - I], N = R[o[_] - I]) : (w = 96, N = 0), h = 1 << f - g, l = 1 << m, E = l;
    do {
      l -= h, r[u + (F >> g) + l] = S << 24 | w << 16 | N;
    } while (0 !== l);
    for (h = 1 << f - 1; F & h; ) h >>= 1;
    if (0 !== h ? (F &= h - 1, F += h) : F = 0, _++, 0 == --y[f]) {
      if (f === p) break;
      f = e2[s + o[_]];
    }
    if (f > C && (F & b) !== d) {
      for (0 === g && (g = C), u += E, m = f - g, T = 1 << m; m + g < p && (T -= y[m + g], !(T <= 0)); ) m++, T <<= 1;
      if (A += 1 << m, 1 === t15 && A > 852 || 2 === t15 && A > 592) return 1;
      d = F & b, r[d] = C << 24 | m << 16 | u - n;
    }
  }
  return 0 !== F && (r[u + F] = f - g << 24 | 64 << 16), a.bits = C, 0;
};
var { Z_FINISH: Sr, Z_BLOCK: wr, Z_TREES: Nr, Z_OK: Lr, Z_STREAM_END: vr, Z_NEED_DICT: Mr, Z_STREAM_ERROR: Pr, Z_DATA_ERROR: xr, Z_MEM_ERROR: Ur, Z_BUF_ERROR: Dr, Z_DEFLATED: Vr } = ti;
var Br = 16180;
var Gr = 16190;
var zr = 16191;
var Yr = 16192;
var Hr = 16194;
var kr = 16199;
var Wr = 16200;
var jr = 16206;
var qr = 16209;
var Xr = (t15) => (t15 >>> 24 & 255) + (t15 >>> 8 & 65280) + ((65280 & t15) << 8) + ((255 & t15) << 24);
function Zr() {
  this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
var Kr = (t15) => {
  if (!t15) return 1;
  const e2 = t15.state;
  return !e2 || e2.strm !== t15 || e2.mode < Br || e2.mode > 16211 ? 1 : 0;
};
var $r = (t15) => {
  if (Kr(t15)) return Pr;
  const e2 = t15.state;
  return t15.total_in = t15.total_out = e2.total = 0, t15.msg = "", e2.wrap && (t15.adler = 1 & e2.wrap), e2.mode = Br, e2.last = 0, e2.havedict = 0, e2.flags = -1, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new Int32Array(852), e2.distcode = e2.distdyn = new Int32Array(592), e2.sane = 1, e2.back = -1, Lr;
};
var Qr = (t15) => {
  if (Kr(t15)) return Pr;
  const e2 = t15.state;
  return e2.wsize = 0, e2.whave = 0, e2.wnext = 0, $r(t15);
};
var Jr = (t15, e2) => {
  let s;
  if (Kr(t15)) return Pr;
  const i = t15.state;
  return e2 < 0 ? (s = 0, e2 = -e2) : (s = 5 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || e2 > 15) ? Pr : (null !== i.window && i.wbits !== e2 && (i.window = null), i.wrap = s, i.wbits = e2, Qr(t15));
};
var tn = (t15, e2) => {
  if (!t15) return Pr;
  const s = new Zr();
  t15.state = s, s.strm = t15, s.window = null, s.mode = Br;
  const i = Jr(t15, e2);
  return i !== Lr && (t15.state = null), i;
};
var en;
var sn;
var rn = true;
var nn = (t15) => {
  if (rn) {
    en = new Int32Array(512), sn = new Int32Array(32);
    let e2 = 0;
    for (; e2 < 144; ) t15.lens[e2++] = 8;
    for (; e2 < 256; ) t15.lens[e2++] = 9;
    for (; e2 < 280; ) t15.lens[e2++] = 7;
    for (; e2 < 288; ) t15.lens[e2++] = 8;
    for (Or(1, t15.lens, 0, 288, en, 0, t15.work, { bits: 9 }), e2 = 0; e2 < 32; ) t15.lens[e2++] = 5;
    Or(2, t15.lens, 0, 32, sn, 0, t15.work, { bits: 5 }), rn = false;
  }
  t15.lencode = en, t15.lenbits = 9, t15.distcode = sn, t15.distbits = 5;
};
var on = (t15, e2, s, i) => {
  let r;
  const n = t15.state;
  return null === n.window && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new Uint8Array(n.wsize)), i >= n.wsize ? (n.window.set(e2.subarray(s - n.wsize, s), 0), n.wnext = 0, n.whave = n.wsize) : (r = n.wsize - n.wnext, r > i && (r = i), n.window.set(e2.subarray(s - i, s - i + r), n.wnext), (i -= r) ? (n.window.set(e2.subarray(s - i, s), 0), n.wnext = i, n.whave = n.wsize) : (n.wnext += r, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += r))), 0;
};
var an = { inflateReset: Qr, inflateReset2: Jr, inflateResetKeep: $r, inflateInit: (t15) => tn(t15, 15), inflateInit2: tn, inflate: (t15, e2) => {
  let s, i, r, n, o, a, c, h, l, d, b, u, I, f, _, E, p, C, m, g, T, A, F = 0;
  const R = new Uint8Array(4);
  let y, O;
  const S = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (Kr(t15) || !t15.output || !t15.input && 0 !== t15.avail_in) return Pr;
  s = t15.state, s.mode === zr && (s.mode = Yr), o = t15.next_out, r = t15.output, c = t15.avail_out, n = t15.next_in, i = t15.input, a = t15.avail_in, h = s.hold, l = s.bits, d = a, b = c, A = Lr;
  t: for (; ; ) switch (s.mode) {
    case Br:
      if (0 === s.wrap) {
        s.mode = Yr;
        break;
      }
      for (; l < 16; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if (2 & s.wrap && 35615 === h) {
        0 === s.wbits && (s.wbits = 15), s.check = 0, R[0] = 255 & h, R[1] = h >>> 8 & 255, s.check = Qs(s.check, R, 2, 0), h = 0, l = 0, s.mode = 16181;
        break;
      }
      if (s.head && (s.head.done = false), !(1 & s.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
        t15.msg = "incorrect header check", s.mode = qr;
        break;
      }
      if ((15 & h) !== Vr) {
        t15.msg = "unknown compression method", s.mode = qr;
        break;
      }
      if (h >>>= 4, l -= 4, T = 8 + (15 & h), 0 === s.wbits && (s.wbits = T), T > 15 || T > s.wbits) {
        t15.msg = "invalid window size", s.mode = qr;
        break;
      }
      s.dmax = 1 << s.wbits, s.flags = 0, t15.adler = s.check = 1, s.mode = 512 & h ? 16189 : zr, h = 0, l = 0;
      break;
    case 16181:
      for (; l < 16; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if (s.flags = h, (255 & s.flags) !== Vr) {
        t15.msg = "unknown compression method", s.mode = qr;
        break;
      }
      if (57344 & s.flags) {
        t15.msg = "unknown header flags set", s.mode = qr;
        break;
      }
      s.head && (s.head.text = h >> 8 & 1), 512 & s.flags && 4 & s.wrap && (R[0] = 255 & h, R[1] = h >>> 8 & 255, s.check = Qs(s.check, R, 2, 0)), h = 0, l = 0, s.mode = 16182;
    case 16182:
      for (; l < 32; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      s.head && (s.head.time = h), 512 & s.flags && 4 & s.wrap && (R[0] = 255 & h, R[1] = h >>> 8 & 255, R[2] = h >>> 16 & 255, R[3] = h >>> 24 & 255, s.check = Qs(s.check, R, 4, 0)), h = 0, l = 0, s.mode = 16183;
    case 16183:
      for (; l < 16; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      s.head && (s.head.xflags = 255 & h, s.head.os = h >> 8), 512 & s.flags && 4 & s.wrap && (R[0] = 255 & h, R[1] = h >>> 8 & 255, s.check = Qs(s.check, R, 2, 0)), h = 0, l = 0, s.mode = 16184;
    case 16184:
      if (1024 & s.flags) {
        for (; l < 16; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        s.length = h, s.head && (s.head.extra_len = h), 512 & s.flags && 4 & s.wrap && (R[0] = 255 & h, R[1] = h >>> 8 & 255, s.check = Qs(s.check, R, 2, 0)), h = 0, l = 0;
      } else s.head && (s.head.extra = null);
      s.mode = 16185;
    case 16185:
      if (1024 & s.flags && (u = s.length, u > a && (u = a), u && (s.head && (T = s.head.extra_len - s.length, s.head.extra || (s.head.extra = new Uint8Array(s.head.extra_len)), s.head.extra.set(i.subarray(n, n + u), T)), 512 & s.flags && 4 & s.wrap && (s.check = Qs(s.check, i, u, n)), a -= u, n += u, s.length -= u), s.length)) break t;
      s.length = 0, s.mode = 16186;
    case 16186:
      if (2048 & s.flags) {
        if (0 === a) break t;
        u = 0;
        do {
          T = i[n + u++], s.head && T && s.length < 65536 && (s.head.name += String.fromCharCode(T));
        } while (T && u < a);
        if (512 & s.flags && 4 & s.wrap && (s.check = Qs(s.check, i, u, n)), a -= u, n += u, T) break t;
      } else s.head && (s.head.name = null);
      s.length = 0, s.mode = 16187;
    case 16187:
      if (4096 & s.flags) {
        if (0 === a) break t;
        u = 0;
        do {
          T = i[n + u++], s.head && T && s.length < 65536 && (s.head.comment += String.fromCharCode(T));
        } while (T && u < a);
        if (512 & s.flags && 4 & s.wrap && (s.check = Qs(s.check, i, u, n)), a -= u, n += u, T) break t;
      } else s.head && (s.head.comment = null);
      s.mode = 16188;
    case 16188:
      if (512 & s.flags) {
        for (; l < 16; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        if (4 & s.wrap && h !== (65535 & s.check)) {
          t15.msg = "header crc mismatch", s.mode = qr;
          break;
        }
        h = 0, l = 0;
      }
      s.head && (s.head.hcrc = s.flags >> 9 & 1, s.head.done = true), t15.adler = s.check = 0, s.mode = zr;
      break;
    case 16189:
      for (; l < 32; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      t15.adler = s.check = Xr(h), h = 0, l = 0, s.mode = Gr;
    case Gr:
      if (0 === s.havedict) return t15.next_out = o, t15.avail_out = c, t15.next_in = n, t15.avail_in = a, s.hold = h, s.bits = l, Mr;
      t15.adler = s.check = 1, s.mode = zr;
    case zr:
      if (e2 === wr || e2 === Nr) break t;
    case Yr:
      if (s.last) {
        h >>>= 7 & l, l -= 7 & l, s.mode = jr;
        break;
      }
      for (; l < 3; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      switch (s.last = 1 & h, h >>>= 1, l -= 1, 3 & h) {
        case 0:
          s.mode = 16193;
          break;
        case 1:
          if (nn(s), s.mode = kr, e2 === Nr) {
            h >>>= 2, l -= 2;
            break t;
          }
          break;
        case 2:
          s.mode = 16196;
          break;
        case 3:
          t15.msg = "invalid block type", s.mode = qr;
      }
      h >>>= 2, l -= 2;
      break;
    case 16193:
      for (h >>>= 7 & l, l -= 7 & l; l < 32; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if ((65535 & h) != (h >>> 16 ^ 65535)) {
        t15.msg = "invalid stored block lengths", s.mode = qr;
        break;
      }
      if (s.length = 65535 & h, h = 0, l = 0, s.mode = Hr, e2 === Nr) break t;
    case Hr:
      s.mode = 16195;
    case 16195:
      if (u = s.length, u) {
        if (u > a && (u = a), u > c && (u = c), 0 === u) break t;
        r.set(i.subarray(n, n + u), o), a -= u, n += u, c -= u, o += u, s.length -= u;
        break;
      }
      s.mode = zr;
      break;
    case 16196:
      for (; l < 14; ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if (s.nlen = 257 + (31 & h), h >>>= 5, l -= 5, s.ndist = 1 + (31 & h), h >>>= 5, l -= 5, s.ncode = 4 + (15 & h), h >>>= 4, l -= 4, s.nlen > 286 || s.ndist > 30) {
        t15.msg = "too many length or distance symbols", s.mode = qr;
        break;
      }
      s.have = 0, s.mode = 16197;
    case 16197:
      for (; s.have < s.ncode; ) {
        for (; l < 3; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        s.lens[S[s.have++]] = 7 & h, h >>>= 3, l -= 3;
      }
      for (; s.have < 19; ) s.lens[S[s.have++]] = 0;
      if (s.lencode = s.lendyn, s.lenbits = 7, y = { bits: s.lenbits }, A = Or(0, s.lens, 0, 19, s.lencode, 0, s.work, y), s.lenbits = y.bits, A) {
        t15.msg = "invalid code lengths set", s.mode = qr;
        break;
      }
      s.have = 0, s.mode = 16198;
    case 16198:
      for (; s.have < s.nlen + s.ndist; ) {
        for (; F = s.lencode[h & (1 << s.lenbits) - 1], _ = F >>> 24, E = F >>> 16 & 255, p = 65535 & F, !(_ <= l); ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        if (p < 16) h >>>= _, l -= _, s.lens[s.have++] = p;
        else {
          if (16 === p) {
            for (O = _ + 2; l < O; ) {
              if (0 === a) break t;
              a--, h += i[n++] << l, l += 8;
            }
            if (h >>>= _, l -= _, 0 === s.have) {
              t15.msg = "invalid bit length repeat", s.mode = qr;
              break;
            }
            T = s.lens[s.have - 1], u = 3 + (3 & h), h >>>= 2, l -= 2;
          } else if (17 === p) {
            for (O = _ + 3; l < O; ) {
              if (0 === a) break t;
              a--, h += i[n++] << l, l += 8;
            }
            h >>>= _, l -= _, T = 0, u = 3 + (7 & h), h >>>= 3, l -= 3;
          } else {
            for (O = _ + 7; l < O; ) {
              if (0 === a) break t;
              a--, h += i[n++] << l, l += 8;
            }
            h >>>= _, l -= _, T = 0, u = 11 + (127 & h), h >>>= 7, l -= 7;
          }
          if (s.have + u > s.nlen + s.ndist) {
            t15.msg = "invalid bit length repeat", s.mode = qr;
            break;
          }
          for (; u--; ) s.lens[s.have++] = T;
        }
      }
      if (s.mode === qr) break;
      if (0 === s.lens[256]) {
        t15.msg = "invalid code -- missing end-of-block", s.mode = qr;
        break;
      }
      if (s.lenbits = 9, y = { bits: s.lenbits }, A = Or(1, s.lens, 0, s.nlen, s.lencode, 0, s.work, y), s.lenbits = y.bits, A) {
        t15.msg = "invalid literal/lengths set", s.mode = qr;
        break;
      }
      if (s.distbits = 6, s.distcode = s.distdyn, y = { bits: s.distbits }, A = Or(2, s.lens, s.nlen, s.ndist, s.distcode, 0, s.work, y), s.distbits = y.bits, A) {
        t15.msg = "invalid distances set", s.mode = qr;
        break;
      }
      if (s.mode = kr, e2 === Nr) break t;
    case kr:
      s.mode = Wr;
    case Wr:
      if (a >= 6 && c >= 258) {
        t15.next_out = o, t15.avail_out = c, t15.next_in = n, t15.avail_in = a, s.hold = h, s.bits = l, gr(t15, b), o = t15.next_out, r = t15.output, c = t15.avail_out, n = t15.next_in, i = t15.input, a = t15.avail_in, h = s.hold, l = s.bits, s.mode === zr && (s.back = -1);
        break;
      }
      for (s.back = 0; F = s.lencode[h & (1 << s.lenbits) - 1], _ = F >>> 24, E = F >>> 16 & 255, p = 65535 & F, !(_ <= l); ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if (E && !(240 & E)) {
        for (C = _, m = E, g = p; F = s.lencode[g + ((h & (1 << C + m) - 1) >> C)], _ = F >>> 24, E = F >>> 16 & 255, p = 65535 & F, !(C + _ <= l); ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        h >>>= C, l -= C, s.back += C;
      }
      if (h >>>= _, l -= _, s.back += _, s.length = p, 0 === E) {
        s.mode = 16205;
        break;
      }
      if (32 & E) {
        s.back = -1, s.mode = zr;
        break;
      }
      if (64 & E) {
        t15.msg = "invalid literal/length code", s.mode = qr;
        break;
      }
      s.extra = 15 & E, s.mode = 16201;
    case 16201:
      if (s.extra) {
        for (O = s.extra; l < O; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        s.length += h & (1 << s.extra) - 1, h >>>= s.extra, l -= s.extra, s.back += s.extra;
      }
      s.was = s.length, s.mode = 16202;
    case 16202:
      for (; F = s.distcode[h & (1 << s.distbits) - 1], _ = F >>> 24, E = F >>> 16 & 255, p = 65535 & F, !(_ <= l); ) {
        if (0 === a) break t;
        a--, h += i[n++] << l, l += 8;
      }
      if (!(240 & E)) {
        for (C = _, m = E, g = p; F = s.distcode[g + ((h & (1 << C + m) - 1) >> C)], _ = F >>> 24, E = F >>> 16 & 255, p = 65535 & F, !(C + _ <= l); ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        h >>>= C, l -= C, s.back += C;
      }
      if (h >>>= _, l -= _, s.back += _, 64 & E) {
        t15.msg = "invalid distance code", s.mode = qr;
        break;
      }
      s.offset = p, s.extra = 15 & E, s.mode = 16203;
    case 16203:
      if (s.extra) {
        for (O = s.extra; l < O; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        s.offset += h & (1 << s.extra) - 1, h >>>= s.extra, l -= s.extra, s.back += s.extra;
      }
      if (s.offset > s.dmax) {
        t15.msg = "invalid distance too far back", s.mode = qr;
        break;
      }
      s.mode = 16204;
    case 16204:
      if (0 === c) break t;
      if (u = b - c, s.offset > u) {
        if (u = s.offset - u, u > s.whave && s.sane) {
          t15.msg = "invalid distance too far back", s.mode = qr;
          break;
        }
        u > s.wnext ? (u -= s.wnext, I = s.wsize - u) : I = s.wnext - u, u > s.length && (u = s.length), f = s.window;
      } else f = r, I = o - s.offset, u = s.length;
      u > c && (u = c), c -= u, s.length -= u;
      do {
        r[o++] = f[I++];
      } while (--u);
      0 === s.length && (s.mode = Wr);
      break;
    case 16205:
      if (0 === c) break t;
      r[o++] = s.length, c--, s.mode = Wr;
      break;
    case jr:
      if (s.wrap) {
        for (; l < 32; ) {
          if (0 === a) break t;
          a--, h |= i[n++] << l, l += 8;
        }
        if (b -= c, t15.total_out += b, s.total += b, 4 & s.wrap && b && (t15.adler = s.check = s.flags ? Qs(s.check, r, b, o - b) : Ks(s.check, r, b, o - b)), b = c, 4 & s.wrap && (s.flags ? h : Xr(h)) !== s.check) {
          t15.msg = "incorrect data check", s.mode = qr;
          break;
        }
        h = 0, l = 0;
      }
      s.mode = 16207;
    case 16207:
      if (s.wrap && s.flags) {
        for (; l < 32; ) {
          if (0 === a) break t;
          a--, h += i[n++] << l, l += 8;
        }
        if (4 & s.wrap && h !== (4294967295 & s.total)) {
          t15.msg = "incorrect length check", s.mode = qr;
          break;
        }
        h = 0, l = 0;
      }
      s.mode = 16208;
    case 16208:
      A = vr;
      break t;
    case qr:
      A = xr;
      break t;
    case 16210:
      return Ur;
    default:
      return Pr;
  }
  return t15.next_out = o, t15.avail_out = c, t15.next_in = n, t15.avail_in = a, s.hold = h, s.bits = l, (s.wsize || b !== t15.avail_out && s.mode < qr && (s.mode < jr || e2 !== Sr)) && on(t15, t15.output, t15.next_out, b - t15.avail_out), d -= t15.avail_in, b -= t15.avail_out, t15.total_in += d, t15.total_out += b, s.total += b, 4 & s.wrap && b && (t15.adler = s.check = s.flags ? Qs(s.check, r, b, t15.next_out - b) : Ks(s.check, r, b, t15.next_out - b)), t15.data_type = s.bits + (s.last ? 64 : 0) + (s.mode === zr ? 128 : 0) + (s.mode === kr || s.mode === Hr ? 256 : 0), (0 === d && 0 === b || e2 === Sr) && A === Lr && (A = Dr), A;
}, inflateEnd: (t15) => {
  if (Kr(t15)) return Pr;
  let e2 = t15.state;
  return e2.window && (e2.window = null), t15.state = null, Lr;
}, inflateGetHeader: (t15, e2) => {
  if (Kr(t15)) return Pr;
  const s = t15.state;
  return 2 & s.wrap ? (s.head = e2, e2.done = false, Lr) : Pr;
}, inflateSetDictionary: (t15, e2) => {
  const s = e2.length;
  let i, r, n;
  return Kr(t15) ? Pr : (i = t15.state, 0 !== i.wrap && i.mode !== Gr ? Pr : i.mode === Gr && (r = 1, r = Ks(r, e2, s, 0), r !== i.check) ? xr : (n = on(t15, e2, s, s), n ? (i.mode = 16210, Ur) : (i.havedict = 1, Lr)));
}, inflateInfo: "pako inflate (from Nodeca project)" };
var cn = function() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
};
var hn = Object.prototype.toString;
var { Z_NO_FLUSH: ln, Z_FINISH: dn, Z_OK: bn, Z_STREAM_END: un, Z_NEED_DICT: In, Z_STREAM_ERROR: fn, Z_DATA_ERROR: _n, Z_MEM_ERROR: En } = ti;
function pn(t15) {
  this.options = Ji({ chunkSize: 65536, windowBits: 15, to: "" }, t15 || {});
  const e2 = this.options;
  e2.raw && e2.windowBits >= 0 && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, 0 === e2.windowBits && (e2.windowBits = -15)), !(e2.windowBits >= 0 && e2.windowBits < 16) || t15 && t15.windowBits || (e2.windowBits += 32), e2.windowBits > 15 && e2.windowBits < 48 && (15 & e2.windowBits || (e2.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new or(), this.strm.avail_out = 0;
  let s = an.inflateInit2(this.strm, e2.windowBits);
  if (s !== bn) throw new Error(Js[s]);
  if (this.header = new cn(), an.inflateGetHeader(this.strm, this.header), e2.dictionary && ("string" == typeof e2.dictionary ? e2.dictionary = ir(e2.dictionary) : "[object ArrayBuffer]" === hn.call(e2.dictionary) && (e2.dictionary = new Uint8Array(e2.dictionary)), e2.raw && (s = an.inflateSetDictionary(this.strm, e2.dictionary), s !== bn))) throw new Error(Js[s]);
}
function Cn(t15, e2) {
  const s = new pn(e2);
  if (s.push(t15), s.err) throw s.msg || Js[s.err];
  return s.result;
}
pn.prototype.push = function(t15, e2) {
  const s = this.strm, i = this.options.chunkSize, r = this.options.dictionary;
  let n, o, a;
  if (this.ended) return false;
  for (o = e2 === ~~e2 ? e2 : true === e2 ? dn : ln, "[object ArrayBuffer]" === hn.call(t15) ? s.input = new Uint8Array(t15) : s.input = t15, s.next_in = 0, s.avail_in = s.input.length; ; ) {
    for (0 === s.avail_out && (s.output = new Uint8Array(i), s.next_out = 0, s.avail_out = i), n = an.inflate(s, o), n === In && r && (n = an.inflateSetDictionary(s, r), n === bn ? n = an.inflate(s, o) : n === _n && (n = In)); s.avail_in > 0 && n === un && s.state.wrap > 0 && 0 !== t15[s.next_in]; ) an.inflateReset(s), n = an.inflate(s, o);
    switch (n) {
      case fn:
      case _n:
      case In:
      case En:
        return this.onEnd(n), this.ended = true, false;
    }
    if (a = s.avail_out, s.next_out && (0 === s.avail_out || n === un)) if ("string" === this.options.to) {
      let t16 = nr(s.output, s.next_out), e3 = s.next_out - t16, r2 = rr(s.output, t16);
      s.next_out = e3, s.avail_out = i - e3, e3 && s.output.set(s.output.subarray(t16, t16 + e3), 0), this.onData(r2);
    } else this.onData(s.output.length === s.next_out ? s.output : s.output.subarray(0, s.next_out));
    if (n !== bn || 0 !== a) {
      if (n === un) return n = an.inflateEnd(this.strm), this.onEnd(n), this.ended = true, true;
      if (0 === s.avail_in) break;
    }
  }
  return true;
}, pn.prototype.onData = function(t15) {
  this.chunks.push(t15);
}, pn.prototype.onEnd = function(t15) {
  t15 === bn && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = tr(this.chunks)), this.chunks = [], this.err = t15, this.msg = this.strm.msg;
};
var mn = { Inflate: pn, inflate: Cn, inflateRaw: function(t15, e2) {
  return (e2 = e2 || {}).raw = true, Cn(t15, e2);
}, ungzip: Cn };
var { Deflate: gn, deflate: Tn, deflateRaw: An, gzip: Fn } = Cr;
var { Inflate: Rn, inflate: yn, inflateRaw: On, ungzip: Sn } = mn;
var Xn = class extends InstancedMesh {
  constructor(t15, s, i, r) {
    if (super(t15, s, i), e(this, "fragment"), e(this, "material"), e(this, "geometry"), Array.isArray(s) || (s = [s]), this.material = s, !t15.index) throw new Error("The geometry for fragments must be indexed!");
    this.geometry = t15, this.fragment = r;
    const n = t15.index.count;
    t15.groups.length || t15.groups.push({ start: 0, count: n, materialIndex: 0 });
  }
  exportData() {
    const t15 = this.geometry.attributes.position.array, e2 = this.geometry.attributes.normal.array, i = Array.from(this.geometry.index.array), r = [];
    for (const t16 of this.geometry.groups) {
      const e3 = t16.materialIndex || 0, { start: s, count: i2 } = t16;
      r.push(s, i2, e3);
    }
    const n = [];
    if (Array.isArray(this.material)) for (const t16 of this.material) {
      const e3 = t16.opacity, i2 = t16.transparent ? 1 : 0, r2 = new Color(t16.color).toArray();
      n.push(e3, i2, ...r2);
    }
    const o = Array.from(this.instanceMatrix.array);
    let a;
    return a = null !== this.instanceColor ? Array.from(this.instanceColor.array) : [], { position: t15, normal: e2, index: i, groups: r, materials: n, matrices: o, colors: a };
  }
  clone(t15) {
    throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!");
  }
};
var Zn = 1.25;
var Kn = 65535;
var $n = Math.pow(2, -24);
var Qn = Symbol("SKIP_GENERATION");
function Jn(t15) {
  return function(t16) {
    return t16.index ? t16.index.count : t16.attributes.position.count;
  }(t15) / 3;
}
function to(t15, e2) {
  if (!t15.index) {
    const s = t15.attributes.position.count, i = function(t16, e3 = ArrayBuffer) {
      return t16 > 65535 ? new Uint32Array(new e3(4 * t16)) : new Uint16Array(new e3(2 * t16));
    }(s, e2.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
    t15.setIndex(new BufferAttribute(i, 1));
    for (let t16 = 0; t16 < s; t16++) i[t16] = t16;
  }
}
function eo(t15) {
  const e2 = Jn(t15), s = t15.drawRange, i = s.start / 3, r = (s.start + s.count) / 3, n = Math.max(0, i), o = Math.min(e2, r) - n;
  return [{ offset: Math.floor(n), count: Math.floor(o) }];
}
function so(t15) {
  if (!t15.groups || !t15.groups.length) return eo(t15);
  const e2 = [], s = /* @__PURE__ */ new Set(), i = t15.drawRange, r = i.start / 3, n = (i.start + i.count) / 3;
  for (const e3 of t15.groups) {
    const t16 = e3.start / 3, i2 = (e3.start + e3.count) / 3;
    s.add(Math.max(r, t16)), s.add(Math.min(n, i2));
  }
  const o = Array.from(s.values()).sort((t16, e3) => t16 - e3);
  for (let t16 = 0; t16 < o.length - 1; t16++) {
    const s2 = o[t16], i2 = o[t16 + 1];
    e2.push({ offset: Math.floor(s2), count: Math.floor(i2 - s2) });
  }
  return e2;
}
function io(t15, e2, s) {
  return s.min.x = e2[t15], s.min.y = e2[t15 + 1], s.min.z = e2[t15 + 2], s.max.x = e2[t15 + 3], s.max.y = e2[t15 + 4], s.max.z = e2[t15 + 5], s;
}
function ro(t15) {
  let e2 = -1, s = -1 / 0;
  for (let i = 0; i < 3; i++) {
    const r = t15[i + 3] - t15[i];
    r > s && (s = r, e2 = i);
  }
  return e2;
}
function no(t15, e2) {
  e2.set(t15);
}
function oo(t15, e2, s) {
  let i, r;
  for (let n = 0; n < 3; n++) {
    const o = n + 3;
    i = t15[n], r = e2[n], s[n] = i < r ? i : r, i = t15[o], r = e2[o], s[o] = i > r ? i : r;
  }
}
function ao(t15, e2, s) {
  for (let i = 0; i < 3; i++) {
    const r = e2[t15 + 2 * i], n = e2[t15 + 2 * i + 1], o = r - n, a = r + n;
    o < s[i] && (s[i] = o), a > s[i + 3] && (s[i + 3] = a);
  }
}
function co(t15) {
  const e2 = t15[3] - t15[0], s = t15[4] - t15[1], i = t15[5] - t15[2];
  return 2 * (e2 * s + s * i + i * e2);
}
function ho(t15, e2, s, i, r = null) {
  let n = 1 / 0, o = 1 / 0, a = 1 / 0, c = -1 / 0, h = -1 / 0, l = -1 / 0, d = 1 / 0, b = 1 / 0, u = 1 / 0, I = -1 / 0, f = -1 / 0, _ = -1 / 0;
  const E = null !== r;
  for (let i2 = 6 * e2, r2 = 6 * (e2 + s); i2 < r2; i2 += 6) {
    const e3 = t15[i2 + 0], s2 = t15[i2 + 1], r3 = e3 - s2, p = e3 + s2;
    r3 < n && (n = r3), p > c && (c = p), E && e3 < d && (d = e3), E && e3 > I && (I = e3);
    const C = t15[i2 + 2], m = t15[i2 + 3], g = C - m, T = C + m;
    g < o && (o = g), T > h && (h = T), E && C < b && (b = C), E && C > f && (f = C);
    const A = t15[i2 + 4], F = t15[i2 + 5], R = A - F, y = A + F;
    R < a && (a = R), y > l && (l = y), E && A < u && (u = A), E && A > _ && (_ = A);
  }
  i[0] = n, i[1] = o, i[2] = a, i[3] = c, i[4] = h, i[5] = l, E && (r[0] = d, r[1] = b, r[2] = u, r[3] = I, r[4] = f, r[5] = _);
}
var lo = 32;
var bo = (t15, e2) => t15.candidate - e2.candidate;
var uo = new Array(lo).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 }));
var Io = new Float32Array(6);
var fo = class {
  constructor() {
  }
};
function _o(t15, e2, s, i, r, n) {
  let o = i, a = i + r - 1;
  const c = n.pos, h = 2 * n.axis;
  for (; ; ) {
    for (; o <= a && s[6 * o + h] < c; ) o++;
    for (; o <= a && s[6 * a + h] >= c; ) a--;
    if (!(o < a)) return o;
    for (let t16 = 0; t16 < 3; t16++) {
      let s2 = e2[3 * o + t16];
      e2[3 * o + t16] = e2[3 * a + t16], e2[3 * a + t16] = s2;
    }
    for (let t16 = 0; t16 < 6; t16++) {
      let e3 = s[6 * o + t16];
      s[6 * o + t16] = s[6 * a + t16], s[6 * a + t16] = e3;
    }
    o++, a--;
  }
}
function Eo(t15, e2, s, i, r, n) {
  let o = i, a = i + r - 1;
  const c = n.pos, h = 2 * n.axis;
  for (; ; ) {
    for (; o <= a && s[6 * o + h] < c; ) o++;
    for (; o <= a && s[6 * a + h] >= c; ) a--;
    if (!(o < a)) return o;
    {
      let e3 = t15[o];
      t15[o] = t15[a], t15[a] = e3;
      for (let t16 = 0; t16 < 6; t16++) {
        let e4 = s[6 * o + t16];
        s[6 * o + t16] = s[6 * a + t16], s[6 * a + t16] = e4;
      }
      o++, a--;
    }
  }
}
function po(t15, e2) {
  const s = t15.geometry, i = s.index ? s.index.array : null, r = e2.maxDepth, n = e2.verbose, o = e2.maxLeafTris, a = e2.strategy, c = e2.onProgress, h = Jn(s), l = t15._indirectBuffer;
  let d = false;
  const b = new Float32Array(6), u = new Float32Array(6), I = function(t16, e3) {
    var s2;
    (s2 = e3)[0] = s2[1] = s2[2] = 1 / 0, s2[3] = s2[4] = s2[5] = -1 / 0;
    const i2 = t16.attributes.position, r2 = t16.index ? t16.index.array : null, n2 = Jn(t16), o2 = new Float32Array(6 * n2), a2 = i2.normalized, c2 = i2.array, h2 = i2.offset || 0;
    let l2 = 3;
    i2.isInterleavedBufferAttribute && (l2 = i2.data.stride);
    const d2 = ["getX", "getY", "getZ"];
    for (let t17 = 0; t17 < n2; t17++) {
      const s3 = 3 * t17, n3 = 6 * t17;
      let b2 = s3 + 0, u2 = s3 + 1, I2 = s3 + 2;
      r2 && (b2 = r2[b2], u2 = r2[u2], I2 = r2[I2]), a2 || (b2 = b2 * l2 + h2, u2 = u2 * l2 + h2, I2 = I2 * l2 + h2);
      for (let t18 = 0; t18 < 3; t18++) {
        let s4, r3, h3;
        a2 ? (s4 = i2[d2[t18]](b2), r3 = i2[d2[t18]](u2), h3 = i2[d2[t18]](I2)) : (s4 = c2[b2 + t18], r3 = c2[u2 + t18], h3 = c2[I2 + t18]);
        let l3 = s4;
        r3 < l3 && (l3 = r3), h3 < l3 && (l3 = h3);
        let f2 = s4;
        r3 > f2 && (f2 = r3), h3 > f2 && (f2 = h3);
        const _2 = (f2 - l3) / 2, E2 = 2 * t18;
        o2[n3 + E2 + 0] = l3 + _2, o2[n3 + E2 + 1] = _2 + (Math.abs(l3) + _2) * $n, l3 < e3[t18] && (e3[t18] = l3), f2 > e3[t18 + 3] && (e3[t18 + 3] = f2);
      }
    }
    return o2;
  }(s, b), f = e2.indirect ? Eo : _o, _ = [], E = e2.indirect ? eo(s) : so(s);
  if (1 === E.length) {
    const t16 = E[0], e3 = new fo();
    e3.boundingData = b, function(t17, e4, s2, i2) {
      let r2 = 1 / 0, n2 = 1 / 0, o2 = 1 / 0, a2 = -1 / 0, c2 = -1 / 0, h2 = -1 / 0;
      for (let i3 = 6 * e4, l2 = 6 * (e4 + s2); i3 < l2; i3 += 6) {
        const e5 = t17[i3 + 0];
        e5 < r2 && (r2 = e5), e5 > a2 && (a2 = e5);
        const s3 = t17[i3 + 2];
        s3 < n2 && (n2 = s3), s3 > c2 && (c2 = s3);
        const l3 = t17[i3 + 4];
        l3 < o2 && (o2 = l3), l3 > h2 && (h2 = l3);
      }
      i2[0] = r2, i2[1] = n2, i2[2] = o2, i2[3] = a2, i2[4] = c2, i2[5] = h2;
    }(I, t16.offset, t16.count, u), C(e3, t16.offset, t16.count, u), _.push(e3);
  } else for (let t16 of E) {
    const e3 = new fo();
    e3.boundingData = new Float32Array(6), ho(I, t16.offset, t16.count, e3.boundingData, u), C(e3, t16.offset, t16.count, u), _.push(e3);
  }
  return _;
  function p(t16) {
    c && c(t16 / h);
  }
  function C(t16, e3, c2, h2 = null, b2 = 0) {
    if (!d && b2 >= r && (d = true, n && (console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`), console.warn(s))), c2 <= o || b2 >= r) return p(e3 + c2), t16.offset = e3, t16.count = c2, t16;
    const _2 = function(t17, e4, s2, i2, r2, n2) {
      let o2 = -1, a2 = 0;
      if (0 === n2) o2 = ro(e4), -1 !== o2 && (a2 = (e4[o2] + e4[o2 + 3]) / 2);
      else if (1 === n2) o2 = ro(t17), -1 !== o2 && (a2 = function(t18, e5, s3, i3) {
        let r3 = 0;
        for (let n3 = e5, o3 = e5 + s3; n3 < o3; n3++) r3 += t18[6 * n3 + 2 * i3];
        return r3 / s3;
      }(s2, i2, r2, o2));
      else if (2 === n2) {
        const n3 = co(t17);
        let c3 = Zn * r2;
        const h3 = 6 * i2, l2 = 6 * (i2 + r2);
        for (let t18 = 0; t18 < 3; t18++) {
          const i3 = e4[t18], d2 = (e4[t18 + 3] - i3) / lo;
          if (r2 < 8) {
            const e5 = [...uo];
            e5.length = r2;
            let i4 = 0;
            for (let r3 = h3; r3 < l2; r3 += 6, i4++) {
              const n4 = e5[i4];
              n4.candidate = s2[r3 + 2 * t18], n4.count = 0;
              const { bounds: o3, leftCacheBounds: a3, rightCacheBounds: c4 } = n4;
              for (let t19 = 0; t19 < 3; t19++) c4[t19] = 1 / 0, c4[t19 + 3] = -1 / 0, a3[t19] = 1 / 0, a3[t19 + 3] = -1 / 0, o3[t19] = 1 / 0, o3[t19 + 3] = -1 / 0;
              ao(r3, s2, o3);
            }
            e5.sort(bo);
            let d3 = r2;
            for (let t19 = 0; t19 < d3; t19++) {
              const s3 = e5[t19];
              for (; t19 + 1 < d3 && e5[t19 + 1].candidate === s3.candidate; ) e5.splice(t19 + 1, 1), d3--;
            }
            for (let i5 = h3; i5 < l2; i5 += 6) {
              const r3 = s2[i5 + 2 * t18];
              for (let t19 = 0; t19 < d3; t19++) {
                const n4 = e5[t19];
                r3 >= n4.candidate ? ao(i5, s2, n4.rightCacheBounds) : (ao(i5, s2, n4.leftCacheBounds), n4.count++);
              }
            }
            for (let s3 = 0; s3 < d3; s3++) {
              const i5 = e5[s3], h4 = i5.count, l3 = r2 - i5.count, d4 = i5.leftCacheBounds, b3 = i5.rightCacheBounds;
              let u2 = 0;
              0 !== h4 && (u2 = co(d4) / n3);
              let I2 = 0;
              0 !== l3 && (I2 = co(b3) / n3);
              const f2 = 1 + Zn * (u2 * h4 + I2 * l3);
              f2 < c3 && (o2 = t18, c3 = f2, a2 = i5.candidate);
            }
          } else {
            for (let t19 = 0; t19 < lo; t19++) {
              const e6 = uo[t19];
              e6.count = 0, e6.candidate = i3 + d2 + t19 * d2;
              const s3 = e6.bounds;
              for (let t20 = 0; t20 < 3; t20++) s3[t20] = 1 / 0, s3[t20 + 3] = -1 / 0;
            }
            for (let e6 = h3; e6 < l2; e6 += 6) {
              let r3 = ~~((s2[e6 + 2 * t18] - i3) / d2);
              r3 >= lo && (r3 = 31);
              const n4 = uo[r3];
              n4.count++, ao(e6, s2, n4.bounds);
            }
            const e5 = uo[31];
            no(e5.bounds, e5.rightCacheBounds);
            for (let t19 = 30; t19 >= 0; t19--) {
              const e6 = uo[t19], s3 = uo[t19 + 1];
              oo(e6.bounds, s3.rightCacheBounds, e6.rightCacheBounds);
            }
            let b3 = 0;
            for (let e6 = 0; e6 < 31; e6++) {
              const s3 = uo[e6], i4 = s3.count, h4 = s3.bounds, l3 = uo[e6 + 1].rightCacheBounds;
              0 !== i4 && (0 === b3 ? no(h4, Io) : oo(h4, Io, Io)), b3 += i4;
              let d3 = 0, u2 = 0;
              0 !== b3 && (d3 = co(Io) / n3);
              const I2 = r2 - b3;
              0 !== I2 && (u2 = co(l3) / n3);
              const f2 = 1 + Zn * (d3 * b3 + u2 * I2);
              f2 < c3 && (o2 = t18, c3 = f2, a2 = s3.candidate);
            }
          }
        }
      } else console.warn(`MeshBVH: Invalid build strategy value ${n2} used.`);
      return { axis: o2, pos: a2 };
    }(t16.boundingData, h2, I, e3, c2, a);
    if (-1 === _2.axis) return p(e3 + c2), t16.offset = e3, t16.count = c2, t16;
    const E2 = f(l, i, I, e3, c2, _2);
    if (E2 === e3 || E2 === e3 + c2) p(e3 + c2), t16.offset = e3, t16.count = c2;
    else {
      t16.splitAxis = _2.axis;
      const s2 = new fo(), i2 = e3, r2 = E2 - e3;
      t16.left = s2, s2.boundingData = new Float32Array(6), ho(I, i2, r2, s2.boundingData, u), C(s2, i2, r2, u, b2 + 1);
      const n2 = new fo(), o2 = E2, a2 = c2 - r2;
      t16.right = n2, n2.boundingData = new Float32Array(6), ho(I, o2, a2, n2.boundingData, u), C(n2, o2, a2, u, b2 + 1);
    }
    return t16;
  }
}
function Co(t15, e2) {
  const s = t15.geometry;
  e2.indirect && (t15._indirectBuffer = function(t16, e3) {
    const s2 = (t16.index ? t16.index.count : t16.attributes.position.count) / 3, i2 = s2 > 65536, r2 = i2 ? 4 : 2, n2 = e3 ? new SharedArrayBuffer(s2 * r2) : new ArrayBuffer(s2 * r2), o2 = i2 ? new Uint32Array(n2) : new Uint16Array(n2);
    for (let t17 = 0, e4 = o2.length; t17 < e4; t17++) o2[t17] = t17;
    return o2;
  }(s, e2.useSharedArrayBuffer), function(t16) {
    if (0 === t16.groups.length) return false;
    const e3 = Jn(t16), s2 = so(t16).sort((t17, e4) => t17.offset - e4.offset), i2 = s2[s2.length - 1];
    i2.count = Math.min(e3 - i2.offset, i2.count);
    let r2 = 0;
    return s2.forEach(({ count: t17 }) => r2 += t17), e3 !== r2;
  }(s) && !e2.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), t15._indirectBuffer || to(s, e2);
  const i = po(t15, e2);
  let r, n, o;
  const a = [], c = e2.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let t16 = 0; t16 < i.length; t16++) {
    const e3 = i[t16];
    const s2 = new c(32 * h(e3));
    r = new Float32Array(s2), n = new Uint32Array(s2), o = new Uint16Array(s2), l(0, e3), a.push(s2);
  }
  return void (t15._roots = a);
  function h(t16) {
    return t16.count ? 1 : 1 + h(t16.left) + h(t16.right);
  }
  function l(t16, e3) {
    const s2 = t16 / 4, i2 = t16 / 2, a2 = !!e3.count, c2 = e3.boundingData;
    for (let t17 = 0; t17 < 6; t17++) r[s2 + t17] = c2[t17];
    if (a2) {
      const r2 = e3.offset, a3 = e3.count;
      return n[s2 + 6] = r2, o[i2 + 14] = a3, o[i2 + 15] = Kn, t16 + 32;
    }
    {
      const i3 = e3.left, r2 = e3.right, o2 = e3.splitAxis;
      let a3;
      if (a3 = l(t16 + 32, i3), a3 / 4 > Math.pow(2, 32)) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return n[s2 + 6] = a3 / 4, a3 = l(a3, r2), n[s2 + 7] = o2, a3;
    }
  }
}
var mo = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t15, e2) {
    let s = 1 / 0, i = -1 / 0;
    for (let r = 0, n = t15.length; r < n; r++) {
      const n2 = t15[r][e2];
      s = n2 < s ? n2 : s, i = n2 > i ? n2 : i;
    }
    this.min = s, this.max = i;
  }
  setFromPoints(t15, e2) {
    let s = 1 / 0, i = -1 / 0;
    for (let r = 0, n = e2.length; r < n; r++) {
      const n2 = e2[r], o = t15.dot(n2);
      s = o < s ? o : s, i = o > i ? o : i;
    }
    this.min = s, this.max = i;
  }
  isSeparated(t15) {
    return this.min > t15.max || t15.min > this.max;
  }
};
mo.prototype.setFromBox = function() {
  const t15 = new Vector3();
  return function(e2, s) {
    const i = s.min, r = s.max;
    let n = 1 / 0, o = -1 / 0;
    for (let s2 = 0; s2 <= 1; s2++) for (let a = 0; a <= 1; a++) for (let c = 0; c <= 1; c++) {
      t15.x = i.x * s2 + r.x * (1 - s2), t15.y = i.y * a + r.y * (1 - a), t15.z = i.z * c + r.z * (1 - c);
      const h = e2.dot(t15);
      n = Math.min(h, n), o = Math.max(h, o);
    }
    this.min = n, this.max = o;
  };
}();
var go = function() {
  const t15 = new Vector3(), e2 = new Vector3(), s = new Vector3();
  return function(i, r, n) {
    const o = i.start, a = t15, c = r.start, h = e2;
    s.subVectors(o, c), t15.subVectors(i.end, i.start), e2.subVectors(r.end, r.start);
    const l = s.dot(h), d = h.dot(a), b = h.dot(h), u = s.dot(a), I = a.dot(a) * b - d * d;
    let f, _;
    f = 0 !== I ? (l * d - u * b) / I : 0, _ = (l + f * d) / b, n.x = f, n.y = _;
  };
}();
var To = function() {
  const t15 = new Vector2(), e2 = new Vector3(), s = new Vector3();
  return function(i, r, n, o) {
    go(i, r, t15);
    let a = t15.x, c = t15.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) return i.at(a, n), void r.at(c, o);
    if (a >= 0 && a <= 1) return c < 0 ? r.at(0, o) : r.at(1, o), void i.closestPointToPoint(o, true, n);
    if (c >= 0 && c <= 1) return a < 0 ? i.at(0, n) : i.at(1, n), void r.closestPointToPoint(n, true, o);
    {
      let t16, h;
      t16 = a < 0 ? i.start : i.end, h = c < 0 ? r.start : r.end;
      const l = e2, d = s;
      return i.closestPointToPoint(h, true, e2), r.closestPointToPoint(t16, true, s), l.distanceToSquared(h) <= d.distanceToSquared(t16) ? (n.copy(l), void o.copy(h)) : (n.copy(t16), void o.copy(d));
    }
  };
}();
var Ao = function() {
  const t15 = new Vector3(), e2 = new Vector3(), s = new Plane(), i = new Line3();
  return function(r, n) {
    const { radius: o, center: a } = r, { a: c, b: h, c: l } = n;
    i.start = c, i.end = h;
    if (i.closestPointToPoint(a, true, t15).distanceTo(a) <= o) return true;
    i.start = c, i.end = l;
    if (i.closestPointToPoint(a, true, t15).distanceTo(a) <= o) return true;
    i.start = h, i.end = l;
    if (i.closestPointToPoint(a, true, t15).distanceTo(a) <= o) return true;
    const d = n.getPlane(s);
    if (Math.abs(d.distanceToPoint(a)) <= o) {
      const t16 = d.projectPoint(a, e2);
      if (n.containsPoint(t16)) return true;
    }
    return false;
  };
}();
function Fo(t15) {
  return Math.abs(t15) < 1e-15;
}
var Ro = class extends Triangle {
  constructor(...t15) {
    super(...t15), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new mo()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(t15) {
    return Ao(t15, this);
  }
  update() {
    const t15 = this.a, e2 = this.b, s = this.c, i = this.points, r = this.satAxes, n = this.satBounds, o = r[0], a = n[0];
    this.getNormal(o), a.setFromPoints(o, i);
    const c = r[1], h = n[1];
    c.subVectors(t15, e2), h.setFromPoints(c, i);
    const l = r[2], d = n[2];
    l.subVectors(e2, s), d.setFromPoints(l, i);
    const b = r[3], u = n[3];
    b.subVectors(s, t15), u.setFromPoints(b, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t15), this.needsUpdate = false;
  }
};
Ro.prototype.closestPointToSegment = function() {
  const t15 = new Vector3(), e2 = new Vector3(), s = new Line3();
  return function(i, r = null, n = null) {
    const { start: o, end: a } = i, c = this.points;
    let h, l = 1 / 0;
    for (let o2 = 0; o2 < 3; o2++) {
      const a2 = (o2 + 1) % 3;
      s.start.copy(c[o2]), s.end.copy(c[a2]), To(s, i, t15, e2), h = t15.distanceToSquared(e2), h < l && (l = h, r && r.copy(t15), n && n.copy(e2));
    }
    return this.closestPointToPoint(o, t15), h = o.distanceToSquared(t15), h < l && (l = h, r && r.copy(t15), n && n.copy(o)), this.closestPointToPoint(a, t15), h = a.distanceToSquared(t15), h < l && (l = h, r && r.copy(t15), n && n.copy(a)), Math.sqrt(l);
  };
}(), Ro.prototype.intersectsTriangle = function() {
  const t15 = new Ro(), e2 = new Array(3), s = new Array(3), i = new mo(), r = new mo(), n = new Vector3(), o = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Vector3(), d = new Line3(), b = new Line3(), u = new Line3(), I = new Vector3();
  function f(t16, e3, s2) {
    const i2 = t16.points;
    let r2 = 0, n2 = -1;
    for (let t17 = 0; t17 < 3; t17++) {
      const { start: a2, end: c2 } = d;
      a2.copy(i2[t17]), c2.copy(i2[(t17 + 1) % 3]), d.delta(o);
      const h2 = Fo(e3.distanceToPoint(a2));
      if (Fo(e3.normal.dot(o)) && h2) {
        s2.copy(d), r2 = 2;
        break;
      }
      const l = e3.intersectLine(d, I);
      if (!l && h2 && I.copy(a2), (l || h2) && !Fo(I.distanceTo(c2))) {
        if (r2 <= 1) {
          (1 === r2 ? s2.start : s2.end).copy(I), h2 && (n2 = r2);
        } else if (r2 >= 2) {
          (1 === n2 ? s2.start : s2.end).copy(I), r2 = 2;
          break;
        }
        if (r2++, 2 === r2 && -1 === n2) break;
      }
    }
    return r2;
  }
  return function(o2, l = null, d2 = false) {
    this.needsUpdate && this.update(), o2.isExtendedTriangle ? o2.needsUpdate && o2.update() : (t15.copy(o2), t15.update(), o2 = t15);
    const I2 = this.plane, _ = o2.plane;
    if (Math.abs(I2.normal.dot(_.normal)) > 1 - 1e-10) {
      const t16 = this.satBounds, a2 = this.satAxes;
      s[0] = o2.a, s[1] = o2.b, s[2] = o2.c;
      for (let e3 = 0; e3 < 4; e3++) {
        const r2 = t16[e3], n2 = a2[e3];
        if (i.setFromPoints(n2, s), r2.isSeparated(i)) return false;
      }
      const c2 = o2.satBounds, h2 = o2.satAxes;
      e2[0] = this.a, e2[1] = this.b, e2[2] = this.c;
      for (let t17 = 0; t17 < 4; t17++) {
        const s2 = c2[t17], r2 = h2[t17];
        if (i.setFromPoints(r2, e2), s2.isSeparated(i)) return false;
      }
      for (let t17 = 0; t17 < 4; t17++) {
        const o3 = a2[t17];
        for (let t18 = 0; t18 < 4; t18++) {
          const a3 = h2[t18];
          if (n.crossVectors(o3, a3), i.setFromPoints(n, e2), r.setFromPoints(n, s), i.isSeparated(r)) return false;
        }
      }
      return l && (d2 || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), l.start.set(0, 0, 0), l.end.set(0, 0, 0)), true;
    }
    {
      const t16 = f(this, _, b);
      if (1 === t16 && o2.containsPoint(b.end)) return l && (l.start.copy(b.end), l.end.copy(b.end)), true;
      if (2 !== t16) return false;
      const e3 = f(o2, I2, u);
      if (1 === e3 && this.containsPoint(u.end)) return l && (l.start.copy(u.end), l.end.copy(u.end)), true;
      if (2 !== e3) return false;
      if (b.delta(a), u.delta(c), a.dot(c) < 0) {
        let t17 = u.start;
        u.start = u.end, u.end = t17;
      }
      const s2 = b.start.dot(a), i2 = b.end.dot(a), r2 = u.start.dot(a), n2 = u.end.dot(a);
      return (s2 === n2 || r2 === i2 || i2 < r2 !== s2 < n2) && (l && (h.subVectors(b.start, u.start), h.dot(a) > 0 ? l.start.copy(b.start) : l.start.copy(u.start), h.subVectors(b.end, u.end), h.dot(a) < 0 ? l.end.copy(b.end) : l.end.copy(u.end)), true);
    }
  };
}(), Ro.prototype.distanceToPoint = function() {
  const t15 = new Vector3();
  return function(e2) {
    return this.closestPointToPoint(e2, t15), e2.distanceTo(t15);
  };
}(), Ro.prototype.distanceToTriangle = function() {
  const t15 = new Vector3(), e2 = new Vector3(), s = ["a", "b", "c"], i = new Line3(), r = new Line3();
  return function(n, o = null, a = null) {
    const c = o || a ? i : null;
    if (this.intersectsTriangle(n, c)) return (o || a) && (o && c.getCenter(o), a && c.getCenter(a)), 0;
    let h = 1 / 0;
    for (let e3 = 0; e3 < 3; e3++) {
      let i2;
      const r2 = s[e3], c2 = n[r2];
      this.closestPointToPoint(c2, t15), i2 = c2.distanceToSquared(t15), i2 < h && (h = i2, o && o.copy(t15), a && a.copy(c2));
      const l = this[r2];
      n.closestPointToPoint(l, t15), i2 = l.distanceToSquared(t15), i2 < h && (h = i2, o && o.copy(l), a && a.copy(t15));
    }
    for (let c2 = 0; c2 < 3; c2++) {
      const l = s[c2], d = s[(c2 + 1) % 3];
      i.set(this[l], this[d]);
      for (let c3 = 0; c3 < 3; c3++) {
        const l2 = s[c3], d2 = s[(c3 + 1) % 3];
        r.set(n[l2], n[d2]), To(i, r, t15, e2);
        const b = t15.distanceToSquared(e2);
        b < h && (h = b, o && o.copy(t15), a && a.copy(e2));
      }
    }
    return Math.sqrt(h);
  };
}();
var yo = class {
  constructor(t15, e2, s) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new mo()), this.alignedSatBounds = new Array(3).fill().map(() => new mo()), this.needsUpdate = false, t15 && this.min.copy(t15), e2 && this.max.copy(e2), s && this.matrix.copy(s);
  }
  set(t15, e2, s) {
    this.min.copy(t15), this.max.copy(e2), this.matrix.copy(s), this.needsUpdate = true;
  }
  copy(t15) {
    this.min.copy(t15.min), this.max.copy(t15.max), this.matrix.copy(t15.matrix), this.needsUpdate = true;
  }
};
yo.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const t15 = this.matrix, e2 = this.min, s = this.max, i = this.points;
    for (let r2 = 0; r2 <= 1; r2++) for (let n2 = 0; n2 <= 1; n2++) for (let o2 = 0; o2 <= 1; o2++) {
      const a2 = i[1 * r2 | 2 * n2 | 4 * o2];
      a2.x = r2 ? s.x : e2.x, a2.y = n2 ? s.y : e2.y, a2.z = o2 ? s.z : e2.z, a2.applyMatrix4(t15);
    }
    const r = this.satBounds, n = this.satAxes, o = i[0];
    for (let t16 = 0; t16 < 3; t16++) {
      const e3 = n[t16], s2 = r[t16], a2 = i[1 << t16];
      e3.subVectors(o, a2), s2.setFromPoints(e3, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}(), yo.prototype.intersectsBox = function() {
  const t15 = new mo();
  return function(e2) {
    this.needsUpdate && this.update();
    const s = e2.min, i = e2.max, r = this.satBounds, n = this.satAxes, o = this.alignedSatBounds;
    if (t15.min = s.x, t15.max = i.x, o[0].isSeparated(t15)) return false;
    if (t15.min = s.y, t15.max = i.y, o[1].isSeparated(t15)) return false;
    if (t15.min = s.z, t15.max = i.z, o[2].isSeparated(t15)) return false;
    for (let s2 = 0; s2 < 3; s2++) {
      const i2 = n[s2], o2 = r[s2];
      if (t15.setFromBox(i2, e2), o2.isSeparated(t15)) return false;
    }
    return true;
  };
}(), yo.prototype.intersectsTriangle = function() {
  const t15 = new Ro(), e2 = new Array(3), s = new mo(), i = new mo(), r = new Vector3();
  return function(n) {
    this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (t15.copy(n), t15.update(), n = t15);
    const o = this.satBounds, a = this.satAxes;
    e2[0] = n.a, e2[1] = n.b, e2[2] = n.c;
    for (let t16 = 0; t16 < 3; t16++) {
      const i2 = o[t16], r2 = a[t16];
      if (s.setFromPoints(r2, e2), i2.isSeparated(s)) return false;
    }
    const c = n.satBounds, h = n.satAxes, l = this.points;
    for (let t16 = 0; t16 < 3; t16++) {
      const e3 = c[t16], i2 = h[t16];
      if (s.setFromPoints(i2, l), e3.isSeparated(s)) return false;
    }
    for (let t16 = 0; t16 < 3; t16++) {
      const n2 = a[t16];
      for (let t17 = 0; t17 < 4; t17++) {
        const o2 = h[t17];
        if (r.crossVectors(n2, o2), s.setFromPoints(r, e2), i.setFromPoints(r, l), s.isSeparated(i)) return false;
      }
    }
    return true;
  };
}(), yo.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(t15, e2) {
    return this.needsUpdate && this.update(), e2.copy(t15).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e2;
  };
}(), yo.prototype.distanceToPoint = function() {
  const t15 = new Vector3();
  return function(e2) {
    return this.closestPointToPoint(e2, t15), e2.distanceTo(t15);
  };
}(), yo.prototype.distanceToBox = function() {
  const t15 = ["x", "y", "z"], e2 = new Array(12).fill().map(() => new Line3()), s = new Array(12).fill().map(() => new Line3()), i = new Vector3(), r = new Vector3();
  return function(n, o = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(n)) return (a || c) && (n.getCenter(r), this.closestPointToPoint(r, i), n.closestPointToPoint(i, r), a && a.copy(i), c && c.copy(r)), 0;
    const h = o * o, l = n.min, d = n.max, b = this.points;
    let u = 1 / 0;
    for (let t16 = 0; t16 < 8; t16++) {
      const e3 = b[t16];
      r.copy(e3).clamp(l, d);
      const s2 = e3.distanceToSquared(r);
      if (s2 < u && (u = s2, a && a.copy(e3), c && c.copy(r), s2 < h)) return Math.sqrt(s2);
    }
    let I = 0;
    for (let i2 = 0; i2 < 3; i2++) for (let r2 = 0; r2 <= 1; r2++) for (let n2 = 0; n2 <= 1; n2++) {
      const o2 = (i2 + 1) % 3, a2 = (i2 + 2) % 3, c2 = 1 << i2 | r2 << o2 | n2 << a2, h2 = b[r2 << o2 | n2 << a2], u2 = b[c2];
      e2[I].set(h2, u2);
      const f = t15[i2], _ = t15[o2], E = t15[a2], p = s[I], C = p.start, m = p.end;
      C[f] = l[f], C[_] = r2 ? l[_] : d[_], C[E] = n2 ? l[E] : d[_], m[f] = d[f], m[_] = r2 ? l[_] : d[_], m[E] = n2 ? l[E] : d[_], I++;
    }
    for (let t16 = 0; t16 <= 1; t16++) for (let e3 = 0; e3 <= 1; e3++) for (let s2 = 0; s2 <= 1; s2++) {
      r.x = t16 ? d.x : l.x, r.y = e3 ? d.y : l.y, r.z = s2 ? d.z : l.z, this.closestPointToPoint(r, i);
      const n2 = r.distanceToSquared(i);
      if (n2 < u && (u = n2, a && a.copy(i), c && c.copy(r), n2 < h)) return Math.sqrt(n2);
    }
    for (let t16 = 0; t16 < 12; t16++) {
      const n2 = e2[t16];
      for (let t17 = 0; t17 < 12; t17++) {
        const e3 = s[t17];
        To(n2, e3, i, r);
        const o2 = i.distanceToSquared(r);
        if (o2 < u && (u = o2, a && a.copy(i), c && c.copy(r), o2 < h)) return Math.sqrt(o2);
      }
    }
    return Math.sqrt(u);
  };
}();
var Oo = class {
  constructor(t15) {
    this._getNewPrimitive = t15, this._primitives = [];
  }
  getPrimitive() {
    const t15 = this._primitives;
    return 0 === t15.length ? this._getNewPrimitive() : t15.pop();
  }
  releasePrimitive(t15) {
    this._primitives.push(t15);
  }
};
var So = class extends Oo {
  constructor() {
    super(() => new Ro());
  }
};
var wo = new So();
function No(t15, e2) {
  return 65535 === e2[t15 + 15];
}
function Lo(t15, e2) {
  return e2[t15 + 6];
}
function vo(t15, e2) {
  return e2[t15 + 14];
}
function Mo(t15) {
  return t15 + 8;
}
function Po(t15, e2) {
  return e2[t15 + 6];
}
function xo(t15, e2) {
  return e2[t15 + 7];
}
var Uo = new class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t15 = [];
    let e2 = null;
    this.setBuffer = (s) => {
      e2 && t15.push(e2), e2 = s, this.float32Array = new Float32Array(s), this.uint16Array = new Uint16Array(s), this.uint32Array = new Uint32Array(s);
    }, this.clearBuffer = () => {
      e2 = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, 0 !== t15.length && this.setBuffer(t15.pop());
    };
  }
}();
var Do;
var Vo;
var Bo = [];
var Go = new Oo(() => new Box3());
function zo(t15, e2, s, i, r, n) {
  Do = Go.getPrimitive(), Vo = Go.getPrimitive(), Bo.push(Do, Vo), Uo.setBuffer(t15._roots[e2]);
  const o = Yo(0, t15.geometry, s, i, r, n);
  Uo.clearBuffer(), Go.releasePrimitive(Do), Go.releasePrimitive(Vo), Bo.pop(), Bo.pop();
  const a = Bo.length;
  return a > 0 && (Vo = Bo[a - 1], Do = Bo[a - 2]), o;
}
function Yo(t15, e2, s, i, r = null, n = 0, o = 0) {
  const { float32Array: a, uint16Array: c, uint32Array: h } = Uo;
  let l = 2 * t15;
  if (No(l, c)) {
    const e3 = Lo(t15, h), s2 = vo(l, c);
    return io(t15, a, Do), i(e3, s2, false, o, n + t15, Do);
  }
  {
    let l2 = function(t16) {
      const { uint16Array: e3, uint32Array: s2 } = Uo;
      let i2 = 2 * t16;
      for (; !No(i2, e3); ) i2 = 2 * (t16 = Mo(t16));
      return Lo(t16, s2);
    }, d = function(t16) {
      const { uint16Array: e3, uint32Array: s2 } = Uo;
      let i2 = 2 * t16;
      for (; !No(i2, e3); ) i2 = 2 * (t16 = Po(t16, s2));
      return Lo(t16, s2) + vo(i2, e3);
    };
    const b = Mo(t15), u = Po(t15, h);
    let I, f, _, E, p = b, C = u;
    if (r && (_ = Do, E = Vo, io(p, a, _), io(C, a, E), I = r(_), f = r(E), f < I)) {
      p = u, C = b;
      const t16 = I;
      I = f, f = t16, _ = E;
    }
    _ || (_ = Do, io(p, a, _));
    const m = s(_, No(2 * p, c), I, o + 1, n + p);
    let g;
    if (2 === m) {
      const t16 = l2(p);
      g = i(t16, d(p) - t16, true, o + 1, n + p, _);
    } else g = m && Yo(p, e2, s, i, r, n, o + 1);
    if (g) return true;
    E = Vo, io(C, a, E);
    const T = s(E, No(2 * C, c), f, o + 1, n + C);
    let A;
    if (2 === T) {
      const t16 = l2(C);
      A = i(t16, d(C) - t16, true, o + 1, n + C, E);
    } else A = T && Yo(C, e2, s, i, r, n, o + 1);
    return !!A;
  }
}
var Ho = new Vector3();
var ko = new Vector3();
var Wo = new Vector3();
var jo = new Vector3();
var qo = new Vector3();
var Xo = new Vector2();
var Zo = new Vector2();
var Ko = new Vector2();
var $o = new Vector3();
var Qo = new Vector3();
var Jo = new Vector3();
var ta = new Vector3();
function ea(t15, e2, s, i, r, n, o, a, c) {
  Wo.fromBufferAttribute(e2, n), jo.fromBufferAttribute(e2, o), qo.fromBufferAttribute(e2, a);
  const h = function(t16, e3, s2, i2, r2, n2) {
    let o2;
    return o2 = n2 === BackSide ? t16.intersectTriangle(i2, s2, e3, true, r2) : t16.intersectTriangle(e3, s2, i2, n2 !== DoubleSide, r2), null === o2 ? null : { distance: t16.origin.distanceTo(r2), point: r2.clone() };
  }(t15, Wo, jo, qo, ta, c);
  if (h) {
    i && (Xo.fromBufferAttribute(i, n), Zo.fromBufferAttribute(i, o), Ko.fromBufferAttribute(i, a), h.uv = Triangle.getInterpolation(ta, Wo, jo, qo, Xo, Zo, Ko, new Vector2())), r && (Xo.fromBufferAttribute(r, n), Zo.fromBufferAttribute(r, o), Ko.fromBufferAttribute(r, a), h.uv1 = Triangle.getInterpolation(ta, Wo, jo, qo, Xo, Zo, Ko, new Vector2())), s && ($o.fromBufferAttribute(s, n), Qo.fromBufferAttribute(s, o), Jo.fromBufferAttribute(s, a), h.normal = Triangle.getInterpolation(ta, Wo, jo, qo, $o, Qo, Jo, new Vector3()), h.normal.dot(t15.direction) > 0 && h.normal.multiplyScalar(-1));
    const e3 = { a: n, b: o, c: a, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(Wo, jo, qo, e3.normal), h.face = e3, h.faceIndex = n;
  }
  return h;
}
function sa(t15, e2, s, i, r) {
  const n = 3 * i;
  let o = n + 0, a = n + 1, c = n + 2;
  const h = t15.index;
  t15.index && (o = h.getX(o), a = h.getX(a), c = h.getX(c));
  const { position: l, normal: d, uv: b, uv1: u } = t15.attributes, I = ea(s, l, d, b, u, o, a, c, e2);
  return I ? (I.faceIndex = i, r && r.push(I), I) : null;
}
function ia(t15, e2, s, i) {
  const r = t15.a, n = t15.b, o = t15.c;
  let a = e2, c = e2 + 1, h = e2 + 2;
  s && (a = s.getX(a), c = s.getX(c), h = s.getX(h)), r.x = i.getX(a), r.y = i.getY(a), r.z = i.getZ(a), n.x = i.getX(c), n.y = i.getY(c), n.z = i.getZ(c), o.x = i.getX(h), o.y = i.getY(h), o.z = i.getZ(h);
}
function ra(t15, e2, s, i, r, n, o) {
  const { geometry: a } = s, { index: c } = a, h = a.attributes.position;
  for (let s2 = t15, a2 = e2 + t15; s2 < a2; s2++) {
    let t16;
    if (t16 = s2, ia(o, 3 * t16, c, h), o.needsUpdate = true, i(o, t16, r, n)) return true;
  }
  return false;
}
function na(t15, e2 = null) {
  e2 && Array.isArray(e2) && (e2 = new Set(e2));
  const s = t15.geometry, i = s.index ? s.index.array : null, r = s.attributes.position;
  let n, o, a, c, h = 0;
  const l = t15._roots;
  for (let t16 = 0, e3 = l.length; t16 < e3; t16++) n = l[t16], o = new Uint32Array(n), a = new Uint16Array(n), c = new Float32Array(n), d(0, h), h += n.byteLength;
  function d(t16, s2, n2 = false) {
    const h2 = 2 * t16;
    if (a[h2 + 15] === Kn) {
      const e3 = o[t16 + 6];
      let s3 = 1 / 0, n3 = 1 / 0, l2 = 1 / 0, d2 = -1 / 0, b = -1 / 0, u = -1 / 0;
      for (let t17 = 3 * e3, o2 = 3 * (e3 + a[h2 + 14]); t17 < o2; t17++) {
        let e4 = i[t17];
        const o3 = r.getX(e4), a2 = r.getY(e4), c2 = r.getZ(e4);
        o3 < s3 && (s3 = o3), o3 > d2 && (d2 = o3), a2 < n3 && (n3 = a2), a2 > b && (b = a2), c2 < l2 && (l2 = c2), c2 > u && (u = c2);
      }
      return (c[t16 + 0] !== s3 || c[t16 + 1] !== n3 || c[t16 + 2] !== l2 || c[t16 + 3] !== d2 || c[t16 + 4] !== b || c[t16 + 5] !== u) && (c[t16 + 0] = s3, c[t16 + 1] = n3, c[t16 + 2] = l2, c[t16 + 3] = d2, c[t16 + 4] = b, c[t16 + 5] = u, true);
    }
    {
      const i2 = t16 + 8, r2 = o[t16 + 6], a2 = i2 + s2, h3 = r2 + s2;
      let l2 = n2, b = false, u = false;
      e2 ? l2 || (b = e2.has(a2), u = e2.has(h3), l2 = !b && !u) : (b = true, u = true);
      const I = l2 || u;
      let f = false;
      (l2 || b) && (f = d(i2, s2, l2));
      let _ = false;
      I && (_ = d(r2, s2, l2));
      const E = f || _;
      if (E) for (let e3 = 0; e3 < 3; e3++) {
        const s3 = i2 + e3, n3 = r2 + e3, o2 = c[s3], a3 = c[s3 + 3], h4 = c[n3], l3 = c[n3 + 3];
        c[t16 + e3] = o2 < h4 ? o2 : h4, c[t16 + e3 + 3] = a3 > l3 ? a3 : l3;
      }
      return E;
    }
  }
}
var oa = new Box3();
function aa(t15, e2, s, i) {
  return io(t15, e2, oa), s.intersectBox(oa, i);
}
function ca(t15, e2, s, i, r, n, o) {
  const { geometry: a } = s, { index: c } = a, h = a.attributes.position;
  for (let a2 = t15, l = e2 + t15; a2 < l; a2++) {
    let t16;
    if (t16 = s.resolveTriangleIndex(a2), ia(o, 3 * t16, c, h), o.needsUpdate = true, i(o, t16, r, n)) return true;
  }
  return false;
}
var ha = new Vector3();
function la(t15, e2, s, i, r) {
  Uo.setBuffer(t15._roots[e2]), da(0, t15, s, i, r), Uo.clearBuffer();
}
function da(t15, e2, s, i, r) {
  const { float32Array: n, uint16Array: o, uint32Array: a } = Uo, c = 2 * t15;
  if (No(c, o)) {
    !function(t16, e3, s2, i2, r2, n2) {
      const { geometry: o2, _indirectBuffer: a2 } = t16;
      for (let t17 = i2, a3 = i2 + r2; t17 < a3; t17++) sa(o2, e3, s2, t17, n2);
    }(e2, s, i, Lo(t15, a), vo(c, o), r);
  } else {
    const o2 = Mo(t15);
    aa(o2, n, i, ha) && da(o2, e2, s, i, r);
    const c2 = Po(t15, a);
    aa(c2, n, i, ha) && da(c2, e2, s, i, r);
  }
}
var ba = new Vector3();
var ua = ["x", "y", "z"];
function Ia(t15, e2, s, i) {
  Uo.setBuffer(t15._roots[e2]);
  const r = fa(0, t15, s, i);
  return Uo.clearBuffer(), r;
}
function fa(t15, e2, s, i) {
  const { float32Array: r, uint16Array: n, uint32Array: o } = Uo;
  let a = 2 * t15;
  if (No(a, n)) {
    return function(t16, e3, s2, i2, r2) {
      const { geometry: n2, _indirectBuffer: o2 } = t16;
      let a2 = 1 / 0, c = null;
      for (let t17 = i2, o3 = i2 + r2; t17 < o3; t17++) {
        let i3;
        i3 = sa(n2, e3, s2, t17), i3 && i3.distance < a2 && (c = i3, a2 = i3.distance);
      }
      return c;
    }(e2, s, i, Lo(t15, o), vo(a, n));
  }
  {
    const n2 = xo(t15, o), a2 = ua[n2], c = i.direction[a2] >= 0;
    let h, l;
    c ? (h = Mo(t15), l = Po(t15, o)) : (h = Po(t15, o), l = Mo(t15));
    const d = aa(h, r, i, ba) ? fa(h, e2, s, i) : null;
    if (d) {
      const t16 = d.point[a2];
      if (c ? t16 <= r[l + n2] : t16 >= r[l + n2 + 3]) return d;
    }
    const b = aa(l, r, i, ba) ? fa(l, e2, s, i) : null;
    return d && b ? d.distance <= b.distance ? d : b : d || b || null;
  }
}
var _a = new Box3();
var Ea = new Ro();
var pa = new Ro();
var Ca = new Matrix4();
var ma = new yo();
var ga = new yo();
function Ta(t15, e2, s, i) {
  Uo.setBuffer(t15._roots[e2]);
  const r = Aa(0, t15, s, i);
  return Uo.clearBuffer(), r;
}
function Aa(t15, e2, s, i, r = null) {
  const { float32Array: n, uint16Array: o, uint32Array: a } = Uo;
  let c = 2 * t15;
  null === r && (s.boundingBox || s.computeBoundingBox(), ma.set(s.boundingBox.min, s.boundingBox.max, i), r = ma);
  if (!No(c, o)) {
    const o2 = t15 + 8, c2 = a[t15 + 6];
    io(o2, n, _a);
    if (r.intersectsBox(_a) && Aa(o2, e2, s, i, r)) return true;
    io(c2, n, _a);
    return !!(r.intersectsBox(_a) && Aa(c2, e2, s, i, r));
  }
  {
    const r2 = e2.geometry, h = r2.index, l = r2.attributes.position, d = s.index, b = s.attributes.position, u = Lo(t15, a), I = vo(c, o);
    if (Ca.copy(i).invert(), s.boundsTree) {
      io(t15, n, ga), ga.matrix.copy(Ca), ga.needsUpdate = true;
      return s.boundsTree.shapecast({ intersectsBounds: (t16) => ga.intersectsBox(t16), intersectsTriangle: (t16) => {
        t16.a.applyMatrix4(i), t16.b.applyMatrix4(i), t16.c.applyMatrix4(i), t16.needsUpdate = true;
        for (let e3 = 3 * u, s2 = 3 * (I + u); e3 < s2; e3 += 3) if (ia(pa, e3, h, l), pa.needsUpdate = true, t16.intersectsTriangle(pa)) return true;
        return false;
      } });
    }
    for (let t16 = 3 * u, e3 = 3 * (I + u); t16 < e3; t16 += 3) {
      ia(Ea, t16, h, l), Ea.a.applyMatrix4(Ca), Ea.b.applyMatrix4(Ca), Ea.c.applyMatrix4(Ca), Ea.needsUpdate = true;
      for (let t17 = 0, e4 = d.count; t17 < e4; t17 += 3) if (ia(pa, t17, d, b), pa.needsUpdate = true, Ea.intersectsTriangle(pa)) return true;
    }
  }
}
var Fa = new Matrix4();
var Ra = new yo();
var ya = new yo();
var Oa = new Vector3();
var Sa = new Vector3();
var wa = new Vector3();
var Na = new Vector3();
function La(t15, e2, s, i = {}, r = {}, n = 0, o = 1 / 0) {
  e2.boundingBox || e2.computeBoundingBox(), Ra.set(e2.boundingBox.min, e2.boundingBox.max, s), Ra.needsUpdate = true;
  const a = t15.geometry, c = a.attributes.position, h = a.index, l = e2.attributes.position, d = e2.index, b = wo.getPrimitive(), u = wo.getPrimitive();
  let I = Oa, f = Sa, _ = null, E = null;
  r && (_ = wa, E = Na);
  let p = 1 / 0, C = null, m = null;
  return Fa.copy(s).invert(), ya.matrix.copy(Fa), t15.shapecast({ boundsTraverseOrder: (t16) => Ra.distanceToBox(t16), intersectsBounds: (t16, e3, s2) => s2 < p && s2 < o && (e3 && (ya.min.copy(t16.min), ya.max.copy(t16.max), ya.needsUpdate = true), true), intersectsRange: (t16, i2) => {
    if (e2.boundsTree) {
      return e2.boundsTree.shapecast({ boundsTraverseOrder: (t17) => ya.distanceToBox(t17), intersectsBounds: (t17, e3, s2) => s2 < p && s2 < o, intersectsRange: (e3, r2) => {
        for (let o2 = e3, a2 = e3 + r2; o2 < a2; o2++) {
          ia(u, 3 * o2, d, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = true;
          for (let e4 = t16, s2 = t16 + i2; e4 < s2; e4++) {
            ia(b, 3 * e4, h, c), b.needsUpdate = true;
            const t17 = b.distanceToTriangle(u, I, _);
            if (t17 < p && (f.copy(I), E && E.copy(_), p = t17, C = e4, m = o2), t17 < n) return true;
          }
        }
      } });
    }
    for (let r2 = 0, o2 = Jn(e2); r2 < o2; r2++) {
      ia(u, 3 * r2, d, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = true;
      for (let e3 = t16, s2 = t16 + i2; e3 < s2; e3++) {
        ia(b, 3 * e3, h, c), b.needsUpdate = true;
        const t17 = b.distanceToTriangle(u, I, _);
        if (t17 < p && (f.copy(I), E && E.copy(_), p = t17, C = e3, m = r2), t17 < n) return true;
      }
    }
  } }), wo.releasePrimitive(b), wo.releasePrimitive(u), p === 1 / 0 ? null : (i.point ? i.point.copy(f) : i.point = f.clone(), i.distance = p, i.faceIndex = C, r && (r.point ? r.point.copy(E) : r.point = E.clone(), r.point.applyMatrix4(Fa), f.applyMatrix4(Fa), r.distance = f.sub(r.point).length(), r.faceIndex = m), i);
}
function va(t15, e2 = null) {
  e2 && Array.isArray(e2) && (e2 = new Set(e2));
  const s = t15.geometry, i = s.index ? s.index.array : null, r = s.attributes.position;
  let n, o, a, c, h = 0;
  const l = t15._roots;
  for (let t16 = 0, e3 = l.length; t16 < e3; t16++) n = l[t16], o = new Uint32Array(n), a = new Uint16Array(n), c = new Float32Array(n), d(0, h), h += n.byteLength;
  function d(s2, n2, h2 = false) {
    const l2 = 2 * s2;
    if (a[l2 + 15] === Kn) {
      const e3 = o[s2 + 6];
      let n3 = 1 / 0, h3 = 1 / 0, d2 = 1 / 0, b = -1 / 0, u = -1 / 0, I = -1 / 0;
      for (let s3 = e3, o2 = e3 + a[l2 + 14]; s3 < o2; s3++) {
        const e4 = 3 * t15.resolveTriangleIndex(s3);
        for (let t16 = 0; t16 < 3; t16++) {
          let s4 = e4 + t16;
          s4 = i ? i[s4] : s4;
          const o3 = r.getX(s4), a2 = r.getY(s4), c2 = r.getZ(s4);
          o3 < n3 && (n3 = o3), o3 > b && (b = o3), a2 < h3 && (h3 = a2), a2 > u && (u = a2), c2 < d2 && (d2 = c2), c2 > I && (I = c2);
        }
      }
      return (c[s2 + 0] !== n3 || c[s2 + 1] !== h3 || c[s2 + 2] !== d2 || c[s2 + 3] !== b || c[s2 + 4] !== u || c[s2 + 5] !== I) && (c[s2 + 0] = n3, c[s2 + 1] = h3, c[s2 + 2] = d2, c[s2 + 3] = b, c[s2 + 4] = u, c[s2 + 5] = I, true);
    }
    {
      const t16 = s2 + 8, i2 = o[s2 + 6], r2 = t16 + n2, a2 = i2 + n2;
      let l3 = h2, b = false, u = false;
      e2 ? l3 || (b = e2.has(r2), u = e2.has(a2), l3 = !b && !u) : (b = true, u = true);
      const I = l3 || u;
      let f = false;
      (l3 || b) && (f = d(t16, n2, l3));
      let _ = false;
      I && (_ = d(i2, n2, l3));
      const E = f || _;
      if (E) for (let e3 = 0; e3 < 3; e3++) {
        const r3 = t16 + e3, n3 = i2 + e3, o2 = c[r3], a3 = c[r3 + 3], h3 = c[n3], l4 = c[n3 + 3];
        c[s2 + e3] = o2 < h3 ? o2 : h3, c[s2 + e3 + 3] = a3 > l4 ? a3 : l4;
      }
      return E;
    }
  }
}
var Ma = new Vector3();
function Pa(t15, e2, s, i, r) {
  Uo.setBuffer(t15._roots[e2]), xa(0, t15, s, i, r), Uo.clearBuffer();
}
function xa(t15, e2, s, i, r) {
  const { float32Array: n, uint16Array: o, uint32Array: a } = Uo, c = 2 * t15;
  if (No(c, o)) {
    !function(t16, e3, s2, i2, r2, n2) {
      const { geometry: o2, _indirectBuffer: a2 } = t16;
      for (let t17 = i2, c2 = i2 + r2; t17 < c2; t17++) sa(o2, e3, s2, a2 ? a2[t17] : t17, n2);
    }(e2, s, i, Lo(t15, a), vo(c, o), r);
  } else {
    const o2 = Mo(t15);
    aa(o2, n, i, Ma) && xa(o2, e2, s, i, r);
    const c2 = Po(t15, a);
    aa(c2, n, i, Ma) && xa(c2, e2, s, i, r);
  }
}
var Ua = new Vector3();
var Da = ["x", "y", "z"];
function Va(t15, e2, s, i) {
  Uo.setBuffer(t15._roots[e2]);
  const r = Ba(0, t15, s, i);
  return Uo.clearBuffer(), r;
}
function Ba(t15, e2, s, i) {
  const { float32Array: r, uint16Array: n, uint32Array: o } = Uo;
  let a = 2 * t15;
  if (No(a, n)) {
    return function(t16, e3, s2, i2, r2) {
      const { geometry: n2, _indirectBuffer: o2 } = t16;
      let a2 = 1 / 0, c = null;
      for (let t17 = i2, h = i2 + r2; t17 < h; t17++) {
        let i3;
        i3 = sa(n2, e3, s2, o2 ? o2[t17] : t17), i3 && i3.distance < a2 && (c = i3, a2 = i3.distance);
      }
      return c;
    }(e2, s, i, Lo(t15, o), vo(a, n));
  }
  {
    const n2 = xo(t15, o), a2 = Da[n2], c = i.direction[a2] >= 0;
    let h, l;
    c ? (h = Mo(t15), l = Po(t15, o)) : (h = Po(t15, o), l = Mo(t15));
    const d = aa(h, r, i, Ua) ? Ba(h, e2, s, i) : null;
    if (d) {
      const t16 = d.point[a2];
      if (c ? t16 <= r[l + n2] : t16 >= r[l + n2 + 3]) return d;
    }
    const b = aa(l, r, i, Ua) ? Ba(l, e2, s, i) : null;
    return d && b ? d.distance <= b.distance ? d : b : d || b || null;
  }
}
var Ga = new Box3();
var za = new Ro();
var Ya = new Ro();
var Ha = new Matrix4();
var ka = new yo();
var Wa = new yo();
function ja(t15, e2, s, i) {
  Uo.setBuffer(t15._roots[e2]);
  const r = qa(0, t15, s, i);
  return Uo.clearBuffer(), r;
}
function qa(t15, e2, s, i, r = null) {
  const { float32Array: n, uint16Array: o, uint32Array: a } = Uo;
  let c = 2 * t15;
  null === r && (s.boundingBox || s.computeBoundingBox(), ka.set(s.boundingBox.min, s.boundingBox.max, i), r = ka);
  if (!No(c, o)) {
    const o2 = t15 + 8, c2 = a[t15 + 6];
    io(o2, n, Ga);
    if (r.intersectsBox(Ga) && qa(o2, e2, s, i, r)) return true;
    io(c2, n, Ga);
    return !!(r.intersectsBox(Ga) && qa(c2, e2, s, i, r));
  }
  {
    const r2 = e2.geometry, h = r2.index, l = r2.attributes.position, d = s.index, b = s.attributes.position, u = Lo(t15, a), I = vo(c, o);
    if (Ha.copy(i).invert(), s.boundsTree) {
      io(t15, n, Wa), Wa.matrix.copy(Ha), Wa.needsUpdate = true;
      return s.boundsTree.shapecast({ intersectsBounds: (t16) => Wa.intersectsBox(t16), intersectsTriangle: (t16) => {
        t16.a.applyMatrix4(i), t16.b.applyMatrix4(i), t16.c.applyMatrix4(i), t16.needsUpdate = true;
        for (let s2 = u, i2 = I + u; s2 < i2; s2++) if (ia(Ya, 3 * e2.resolveTriangleIndex(s2), h, l), Ya.needsUpdate = true, t16.intersectsTriangle(Ya)) return true;
        return false;
      } });
    }
    for (let t16 = u, s2 = I + u; t16 < s2; t16++) {
      const s3 = e2.resolveTriangleIndex(t16);
      ia(za, 3 * s3, h, l), za.a.applyMatrix4(Ha), za.b.applyMatrix4(Ha), za.c.applyMatrix4(Ha), za.needsUpdate = true;
      for (let t17 = 0, e3 = d.count; t17 < e3; t17 += 3) if (ia(Ya, t17, d, b), Ya.needsUpdate = true, za.intersectsTriangle(Ya)) return true;
    }
  }
}
var Xa = new Matrix4();
var Za = new yo();
var Ka = new yo();
var $a = new Vector3();
var Qa = new Vector3();
var Ja = new Vector3();
var tc = new Vector3();
function ec(t15, e2, s, i = {}, r = {}, n = 0, o = 1 / 0) {
  e2.boundingBox || e2.computeBoundingBox(), Za.set(e2.boundingBox.min, e2.boundingBox.max, s), Za.needsUpdate = true;
  const a = t15.geometry, c = a.attributes.position, h = a.index, l = e2.attributes.position, d = e2.index, b = wo.getPrimitive(), u = wo.getPrimitive();
  let I = $a, f = Qa, _ = null, E = null;
  r && (_ = Ja, E = tc);
  let p = 1 / 0, C = null, m = null;
  return Xa.copy(s).invert(), Ka.matrix.copy(Xa), t15.shapecast({ boundsTraverseOrder: (t16) => Za.distanceToBox(t16), intersectsBounds: (t16, e3, s2) => s2 < p && s2 < o && (e3 && (Ka.min.copy(t16.min), Ka.max.copy(t16.max), Ka.needsUpdate = true), true), intersectsRange: (i2, r2) => {
    if (e2.boundsTree) {
      const a2 = e2.boundsTree;
      return a2.shapecast({ boundsTraverseOrder: (t16) => Ka.distanceToBox(t16), intersectsBounds: (t16, e3, s2) => s2 < p && s2 < o, intersectsRange: (e3, o2) => {
        for (let g = e3, T = e3 + o2; g < T; g++) {
          const e4 = a2.resolveTriangleIndex(g);
          ia(u, 3 * e4, d, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = true;
          for (let e5 = i2, s2 = i2 + r2; e5 < s2; e5++) {
            const s3 = t15.resolveTriangleIndex(e5);
            ia(b, 3 * s3, h, c), b.needsUpdate = true;
            const i3 = b.distanceToTriangle(u, I, _);
            if (i3 < p && (f.copy(I), E && E.copy(_), p = i3, C = e5, m = g), i3 < n) return true;
          }
        }
      } });
    }
    for (let o2 = 0, a2 = Jn(e2); o2 < a2; o2++) {
      ia(u, 3 * o2, d, l), u.a.applyMatrix4(s), u.b.applyMatrix4(s), u.c.applyMatrix4(s), u.needsUpdate = true;
      for (let e3 = i2, s2 = i2 + r2; e3 < s2; e3++) {
        const s3 = t15.resolveTriangleIndex(e3);
        ia(b, 3 * s3, h, c), b.needsUpdate = true;
        const i3 = b.distanceToTriangle(u, I, _);
        if (i3 < p && (f.copy(I), E && E.copy(_), p = i3, C = e3, m = o2), i3 < n) return true;
      }
    }
  } }), wo.releasePrimitive(b), wo.releasePrimitive(u), p === 1 / 0 ? null : (i.point ? i.point.copy(f) : i.point = f.clone(), i.distance = p, i.faceIndex = C, r && (r.point ? r.point.copy(E) : r.point = E.clone(), r.point.applyMatrix4(Xa), f.applyMatrix4(Xa), r.distance = f.sub(r.point).length(), r.faceIndex = m), i);
}
var sc = new Uo.constructor();
var ic = new Uo.constructor();
var rc = new Oo(() => new Box3());
var nc = new Box3();
var oc = new Box3();
var ac = new Box3();
var cc = new Box3();
var hc = false;
function lc(t15, e2, s, i, r, n = 0, o = 0, a = 0, c = 0, h = null, l = false) {
  let d, b;
  l ? (d = ic, b = sc) : (d = sc, b = ic);
  const u = d.float32Array, I = d.uint32Array, f = d.uint16Array, _ = b.float32Array, E = b.uint32Array, p = b.uint16Array, C = 2 * e2, m = No(2 * t15, f), g = No(C, p);
  let T = false;
  if (g && m) T = l ? r(Lo(e2, E), vo(2 * e2, p), Lo(t15, I), vo(2 * t15, f), c, o + e2, a, n + t15) : r(Lo(t15, I), vo(2 * t15, f), Lo(e2, E), vo(2 * e2, p), a, n + t15, c, o + e2);
  else if (g) {
    const h2 = rc.getPrimitive();
    io(e2, _, h2), h2.applyMatrix4(s);
    const d2 = Mo(t15), b2 = Po(t15, I);
    io(d2, u, nc), io(b2, u, oc);
    const f2 = h2.intersectsBox(nc), E2 = h2.intersectsBox(oc);
    T = f2 && lc(e2, d2, i, s, r, o, n, c, a + 1, h2, !l) || E2 && lc(e2, b2, i, s, r, o, n, c, a + 1, h2, !l), rc.releasePrimitive(h2);
  } else {
    const d2 = Mo(e2), b2 = Po(e2, E);
    io(d2, _, ac), io(b2, _, cc);
    const f2 = h.intersectsBox(ac), p2 = h.intersectsBox(cc);
    if (f2 && p2) T = lc(t15, d2, s, i, r, n, o, a, c + 1, h, l) || lc(t15, b2, s, i, r, n, o, a, c + 1, h, l);
    else if (f2) if (m) T = lc(t15, d2, s, i, r, n, o, a, c + 1, h, l);
    else {
      const e3 = rc.getPrimitive();
      e3.copy(ac).applyMatrix4(s);
      const h2 = Mo(t15), b3 = Po(t15, I);
      io(h2, u, nc), io(b3, u, oc);
      const f3 = e3.intersectsBox(nc), _2 = e3.intersectsBox(oc);
      T = f3 && lc(d2, h2, i, s, r, o, n, c, a + 1, e3, !l) || _2 && lc(d2, b3, i, s, r, o, n, c, a + 1, e3, !l), rc.releasePrimitive(e3);
    }
    else if (p2) if (m) T = lc(t15, b2, s, i, r, n, o, a, c + 1, h, l);
    else {
      const e3 = rc.getPrimitive();
      e3.copy(cc).applyMatrix4(s);
      const h2 = Mo(t15), d3 = Po(t15, I);
      io(h2, u, nc), io(d3, u, oc);
      const f3 = e3.intersectsBox(nc), _2 = e3.intersectsBox(oc);
      T = f3 && lc(b2, h2, i, s, r, o, n, c, a + 1, e3, !l) || _2 && lc(b2, d3, i, s, r, o, n, c, a + 1, e3, !l), rc.releasePrimitive(e3);
    }
  }
  return T;
}
var dc = new yo();
var bc = new Box3();
var uc = class _uc {
  static serialize(t15, e2 = {}) {
    e2 = { cloneBuffers: true, ...e2 };
    const s = t15.geometry, i = t15._roots, r = t15._indirectBuffer, n = s.getIndex();
    let o;
    return o = e2.cloneBuffers ? { roots: i.map((t16) => t16.slice()), index: n.array.slice(), indirectBuffer: r ? r.slice() : null } : { roots: i, index: n.array, indirectBuffer: r }, o;
  }
  static deserialize(t15, e2, s = {}) {
    s = { setIndex: true, indirect: Boolean(t15.indirectBuffer), ...s };
    const { index: i, roots: r, indirectBuffer: n } = t15, o = new _uc(e2, { ...s, [Qn]: true });
    if (o._roots = r, o._indirectBuffer = n || null, s.setIndex) {
      const s2 = e2.getIndex();
      if (null === s2) {
        const s3 = new BufferAttribute(t15.index, 1, false);
        e2.setIndex(s3);
      } else s2.array !== i && (s2.array.set(i), s2.needsUpdate = true);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t15, e2 = {}) {
    if (!t15.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t15.index && t15.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    if ((e2 = Object.assign({ strategy: 0, maxDepth: 40, maxLeafTris: 10, verbose: true, useSharedArrayBuffer: false, setBoundingBox: true, onProgress: null, indirect: false, [Qn]: false }, e2)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t15, this._roots = null, this._indirectBuffer = null, e2[Qn] || (Co(this, e2), !t15.boundingBox && e2.setBoundingBox && (t15.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: s } = this;
    this.resolveTriangleIndex = e2.indirect ? (t16) => s[t16] : (t16) => t16;
  }
  refit(t15 = null) {
    return (this.indirect ? va : na)(this, t15);
  }
  traverse(t15, e2 = 0) {
    const s = this._roots[e2], i = new Uint32Array(s), r = new Uint16Array(s);
    !function e3(n, o = 0) {
      const a = 2 * n, c = r[a + 15] === Kn;
      if (c) {
        const e4 = i[n + 6], h = r[a + 14];
        t15(o, c, new Float32Array(s, 4 * n, 6), e4, h);
      } else {
        const r2 = n + 8, a2 = i[n + 6], h = i[n + 7];
        t15(o, c, new Float32Array(s, 4 * n, 6), h) || (e3(r2, o + 1), e3(a2, o + 1));
      }
    }(0);
  }
  raycast(t15, e2 = FrontSide) {
    const s = this._roots, i = this.geometry, r = [], n = e2.isMaterial, o = Array.isArray(e2), a = i.groups, c = n ? e2.side : e2, h = this.indirect ? Pa : la;
    for (let i2 = 0, n2 = s.length; i2 < n2; i2++) {
      const s2 = o ? e2[a[i2].materialIndex].side : c, n3 = r.length;
      if (h(this, i2, s2, t15, r), o) {
        const t16 = a[i2].materialIndex;
        for (let e3 = n3, s3 = r.length; e3 < s3; e3++) r[e3].face.materialIndex = t16;
      }
    }
    return r;
  }
  raycastFirst(t15, e2 = FrontSide) {
    const s = this._roots, i = this.geometry, r = e2.isMaterial, n = Array.isArray(e2);
    let o = null;
    const a = i.groups, c = r ? e2.side : e2, h = this.indirect ? Va : Ia;
    for (let i2 = 0, r2 = s.length; i2 < r2; i2++) {
      const s2 = h(this, i2, n ? e2[a[i2].materialIndex].side : c, t15);
      null != s2 && (null == o || s2.distance < o.distance) && (o = s2, n && (s2.face.materialIndex = a[i2].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t15, e2) {
    let s = false;
    const i = this._roots, r = this.indirect ? ja : Ta;
    for (let n = 0, o = i.length; n < o && (s = r(this, n, t15, e2), !s); n++) ;
    return s;
  }
  shapecast(t15) {
    const e2 = wo.getPrimitive(), s = this.indirect ? ca : ra;
    let { boundsTraverseOrder: i, intersectsBounds: r, intersectsRange: n, intersectsTriangle: o } = t15;
    if (n && o) {
      const t16 = n;
      n = (i2, r2, n2, a2, c2) => !!t16(i2, r2, n2, a2, c2) || s(i2, r2, this, o, n2, a2, e2);
    } else n || (n = o ? (t16, i2, r2, n2) => s(t16, i2, this, o, r2, n2, e2) : (t16, e3, s2) => s2);
    let a = false, c = 0;
    const h = this._roots;
    for (let t16 = 0, e3 = h.length; t16 < e3; t16++) {
      const e4 = h[t16];
      if (a = zo(this, t16, r, n, i, c), a) break;
      c += e4.byteLength;
    }
    return wo.releasePrimitive(e2), a;
  }
  bvhcast(t15, e2, s) {
    let { intersectsRanges: i, intersectsTriangles: r } = s;
    const n = wo.getPrimitive(), o = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (t16) => {
      const e3 = this.resolveTriangleIndex(t16);
      ia(n, 3 * e3, o, a);
    } : (t16) => {
      ia(n, 3 * t16, o, a);
    }, h = wo.getPrimitive(), l = t15.geometry.index, d = t15.geometry.attributes.position, b = t15.indirect ? (e3) => {
      const s2 = t15.resolveTriangleIndex(e3);
      ia(h, 3 * s2, l, d);
    } : (t16) => {
      ia(h, 3 * t16, l, d);
    };
    if (r) {
      const t16 = (t17, s2, i2, o2, a2, l2, d2, u) => {
        for (let I = i2, f = i2 + o2; I < f; I++) {
          b(I), h.a.applyMatrix4(e2), h.b.applyMatrix4(e2), h.c.applyMatrix4(e2), h.needsUpdate = true;
          for (let e3 = t17, i3 = t17 + s2; e3 < i3; e3++) if (c(e3), n.needsUpdate = true, r(n, h, e3, I, a2, l2, d2, u)) return true;
        }
        return false;
      };
      if (i) {
        const e3 = i;
        i = function(s2, i2, r2, n2, o2, a2, c2, h2) {
          return !!e3(s2, i2, r2, n2, o2, a2, c2, h2) || t16(s2, i2, r2, n2, o2, a2, c2, h2);
        };
      } else i = t16;
    }
    return function(t16, e3, s2, i2) {
      if (hc) throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
      hc = true;
      const r2 = t16._roots, n2 = e3._roots;
      let o2, a2 = 0, c2 = 0;
      const h2 = new Matrix4().copy(s2).invert();
      for (let t17 = 0, e4 = r2.length; t17 < e4; t17++) {
        sc.setBuffer(r2[t17]), c2 = 0;
        const e5 = rc.getPrimitive();
        io(0, sc.float32Array, e5), e5.applyMatrix4(h2);
        for (let r3 = 0, l2 = n2.length; r3 < l2 && (ic.setBuffer(n2[t17]), o2 = lc(0, 0, s2, h2, i2, a2, c2, 0, 0, e5), ic.clearBuffer(), c2 += n2[r3].length, !o2); r3++) ;
        if (rc.releasePrimitive(e5), sc.clearBuffer(), a2 += r2[t17].length, o2) break;
      }
      return hc = false, o2;
    }(this, t15, e2, i);
  }
  intersectsBox(t15, e2) {
    return dc.set(t15.min, t15.max, e2), dc.needsUpdate = true, this.shapecast({ intersectsBounds: (t16) => dc.intersectsBox(t16), intersectsTriangle: (t16) => dc.intersectsTriangle(t16) });
  }
  intersectsSphere(t15) {
    return this.shapecast({ intersectsBounds: (e2) => t15.intersectsBox(e2), intersectsTriangle: (e2) => e2.intersectsSphere(t15) });
  }
  closestPointToGeometry(t15, e2, s = {}, i = {}, r = 0, n = 1 / 0) {
    return (this.indirect ? ec : La)(this, t15, e2, s, i, r, n);
  }
  closestPointToPoint(t15, e2 = {}, s = 0, i = 1 / 0) {
    return function(t16, e3, s2 = {}, i2 = 0, r = 1 / 0) {
      const n = i2 * i2, o = r * r;
      let a = 1 / 0, c = null;
      if (t16.shapecast({ boundsTraverseOrder: (t17) => (Ho.copy(e3).clamp(t17.min, t17.max), Ho.distanceToSquared(e3)), intersectsBounds: (t17, e4, s3) => s3 < a && s3 < o, intersectsTriangle: (t17, s3) => {
        t17.closestPointToPoint(e3, Ho);
        const i3 = e3.distanceToSquared(Ho);
        return i3 < a && (ko.copy(Ho), a = i3, c = s3), i3 < n;
      } }), a === 1 / 0) return null;
      const h = Math.sqrt(a);
      return s2.point ? s2.point.copy(ko) : s2.point = ko.clone(), s2.distance = h, s2.faceIndex = c, s2;
    }(this, t15, e2, s, i);
  }
  getBoundingBox(t15) {
    t15.makeEmpty();
    return this._roots.forEach((e2) => {
      io(0, new Float32Array(e2), bc), t15.union(bc);
    }), t15;
  }
};
function Ic(t15, e2, s) {
  return null === t15 ? null : (t15.point.applyMatrix4(e2.matrixWorld), t15.distance = t15.point.distanceTo(s.ray.origin), t15.object = e2, t15.distance < s.near || t15.distance > s.far ? null : t15);
}
var fc = new Ray();
var _c = new Matrix4();
var Ec = Mesh.prototype.raycast;
function pc(t15, e2) {
  if (this.geometry.boundsTree) {
    if (void 0 === this.material) return;
    _c.copy(this.matrixWorld).invert(), fc.copy(t15.ray).applyMatrix4(_c);
    const s = this.geometry.boundsTree;
    if (true === t15.firstHitOnly) {
      const i = Ic(s.raycastFirst(fc, this.material), this, t15);
      i && e2.push(i);
    } else {
      const i = s.raycast(fc, this.material);
      for (let s2 = 0, r = i.length; s2 < r; s2++) {
        const r2 = Ic(i[s2], this, t15);
        r2 && e2.push(r2);
      }
    }
  } else Ec.call(this, t15, e2);
}
function Cc(t15) {
  return this.boundsTree = new uc(this, t15), this.boundsTree;
}
function mc() {
  this.boundsTree = null;
}
var gc = class t5 {
  static apply(e2) {
    t5.initialized || (BufferGeometry.prototype.computeBoundsTree = Cc, BufferGeometry.prototype.disposeBoundsTree = mc, Mesh.prototype.raycast = pc, t5.initialized = true), e2.boundsTree || e2.computeBoundsTree();
  }
  static dispose(t15) {
    t15 && t15.disposeBoundsTree && t15.disposeBoundsTree();
  }
};
e(gc, "initialized", false);
var Tc = gc;
var Ac = class t6 {
  constructor(t15, s, i) {
    e(this, "ids", /* @__PURE__ */ new Set()), e(this, "itemToInstances", /* @__PURE__ */ new Map()), e(this, "instanceToItem", /* @__PURE__ */ new Map()), e(this, "hiddenItems", /* @__PURE__ */ new Set()), e(this, "id"), e(this, "mesh"), e(this, "capacity", 0), e(this, "capacityOffset", 10), e(this, "group"), e(this, "_originalColors", /* @__PURE__ */ new Map()), e(this, "_settingVisibility", false), this.mesh = new Xn(t15, s, i, this), this.id = this.mesh.uuid, this.capacity = i, this.mesh.count = 0, this.mesh.geometry.index.count && Tc.apply(this.mesh.geometry);
  }
  get uniqueVertices() {
    const t15 = [], e2 = this.mesh.geometry.getAttribute("position");
    if (!e2) return t15;
    const i = /* @__PURE__ */ new Set();
    for (let r = 0; r < e2.count; r++) {
      const n = e2.getX(r), o = e2.getY(r), a = e2.getZ(r), c = `${n},${o},${a}`;
      i.has(c) || (i.add(c), t15.push(new Vector3(n, o, a)));
    }
    return t15;
  }
  dispose(t15 = true) {
    if (this.clear(), this.group = void 0, this._originalColors.clear(), this.mesh) {
      if (t15) {
        for (const t16 of this.mesh.material) t16.dispose();
        this.mesh.material = [], Tc.dispose(this.mesh.geometry), this.mesh.geometry && this.mesh.geometry.dispose(), this.mesh.geometry = null;
      }
      this.mesh.removeFromParent(), this.mesh.userData = {}, this.mesh.dispose(), this.mesh.fragment = null, this.mesh = null;
    }
  }
  get(t15) {
    const e2 = this.getInstancesIDs(t15);
    if (!e2) throw new Error("Item not found!");
    const i = [], r = [];
    for (const t16 of e2) {
      const e3 = new Matrix4();
      if (this.mesh.getMatrixAt(t16, e3), i.push(e3), this.mesh.instanceColor) {
        const e4 = new Color();
        this.mesh.getColorAt(t16, e4), r.push(e4);
      }
    }
    return { id: t15, transforms: i, colors: r.length ? r : void 0 };
  }
  getItemID(t15) {
    return this.instanceToItem.get(t15) || null;
  }
  getInstancesIDs(t15) {
    return this.itemToInstances.get(t15) || null;
  }
  update() {
    this.mesh.instanceColor && (this.mesh.instanceColor.needsUpdate = true), this.mesh.instanceMatrix.needsUpdate = true;
  }
  add(t15) {
    var e2;
    let i = 0;
    for (const e3 of t15) i += e3.transforms.length;
    const r = this.mesh.count + i;
    if (r > this.capacity) {
      const t16 = r + this.capacityOffset, i2 = new Xn(this.mesh.geometry, this.mesh.material, t16, this);
      i2.count = this.mesh.count, this.capacity = t16;
      const n = this.mesh;
      null == (e2 = n.parent) || e2.add(i2), n.removeFromParent(), this.mesh = i2;
      const o = new Matrix4();
      for (let t17 = 0; t17 < n.instanceMatrix.count; t17++) n.getMatrixAt(t17, o), i2.setMatrixAt(t17, o);
      if (n.instanceColor) {
        const t17 = new Color();
        for (let e3 = 0; e3 < n.instanceColor.count; e3++) n.getColorAt(e3, t17), i2.setColorAt(e3, t17);
      }
      n.dispose();
    }
    for (let e3 = 0; e3 < t15.length; e3++) {
      const { transforms: s, colors: i2, id: r2 } = t15[e3];
      this.itemToInstances.has(r2) || this.itemToInstances.set(r2, /* @__PURE__ */ new Set());
      const n = this.itemToInstances.get(r2);
      this.ids.add(r2);
      for (let t16 = 0; t16 < s.length; t16++) {
        const e4 = s[t16], o = this.mesh.count;
        if (this.mesh.setMatrixAt(o, e4), i2) {
          const e5 = i2[t16];
          this.mesh.setColorAt(o, e5);
        }
        n.add(o), this.instanceToItem.set(o, r2), this.mesh.count++;
      }
    }
    this.update();
  }
  remove(t15) {
    if (0 !== this.mesh.count) {
      for (const e2 of t15) {
        const t16 = this.itemToInstances.get(e2);
        if (void 0 === t16) throw new Error("Instances not found!");
        for (const e3 of t16) {
          if (0 === this.mesh.count) throw new Error("Error with mesh count!");
          this.putLast(e3), this.instanceToItem.delete(e3), this.mesh.count--;
        }
        this.itemToInstances.delete(e2), this.ids.delete(e2);
      }
      this.update();
    }
  }
  clear() {
    this.hiddenItems.clear(), this.ids.clear(), this.instanceToItem.clear(), this.itemToInstances.clear(), this.mesh.count = 0;
  }
  setVisibility(t15, e2 = this.ids) {
    if (!this._settingVisibility) {
      if (this._settingVisibility = true, t15) for (const t16 of e2) {
        if (!this.ids.has(t16)) continue;
        if (!this.hiddenItems.has(t16)) continue;
        const e3 = this.itemToInstances.get(t16);
        if (!e3) throw new Error("Instances not found!");
        for (const t17 of new Set(e3)) this.mesh.count++, this.putLast(t17);
        this.hiddenItems.delete(t16);
      }
      else for (const t16 of e2) {
        if (!this.ids.has(t16)) continue;
        if (this.hiddenItems.has(t16)) continue;
        const e3 = this.itemToInstances.get(t16);
        if (!e3) throw new Error("Instances not found!");
        for (const t17 of new Set(e3)) this.putLast(t17), this.mesh.count--;
        this.hiddenItems.add(t16);
      }
      this.update(), this._settingVisibility = false;
    }
  }
  setColor(t15, e2 = this.ids, i = false) {
    if (!this.mesh.instanceColor) throw new Error("This fragment doesn't have color per instance!");
    for (const r of e2) {
      if (!this.ids.has(r)) continue;
      const e3 = this.itemToInstances.get(r);
      if (!e3) throw new Error("Instances not found!");
      const n = this._originalColors.has(r);
      n || this._originalColors.set(r, /* @__PURE__ */ new Map());
      const o = this._originalColors.get(r);
      for (const r2 of new Set(e3)) {
        if (!n) {
          const t16 = new Color();
          this.mesh.getColorAt(r2, t16), o.set(r2, t16);
        }
        this.mesh.setColorAt(r2, t15), i && o.set(r2, t15);
      }
    }
    this.mesh.instanceColor.needsUpdate = true;
  }
  resetColor(t15 = this.ids) {
    if (!this.mesh.instanceColor) throw new Error("This fragment doesn't have color per instance!");
    for (const e2 of t15) {
      if (!this.ids.has(e2)) continue;
      const t16 = this.itemToInstances.get(e2);
      if (!t16) throw new Error("Instances not found!");
      const s = this._originalColors.get(e2);
      if (s) for (const e3 of new Set(t16)) {
        const t17 = s.get(e3);
        if (!t17) throw new Error("Original color not found!");
        this.mesh.setColorAt(e3, t17);
      }
    }
    this.mesh.instanceColor.needsUpdate = true;
  }
  applyTransform(t15, e2) {
    const i = new Matrix4();
    for (const s of t15) {
      const t16 = this.getInstancesIDs(s);
      if (null !== t16) for (const s2 of t16) this.mesh.getMatrixAt(s2, i), i.premultiply(e2), this.mesh.setMatrixAt(s2, i);
    }
    this.update();
  }
  exportData() {
    return { ...this.mesh.exportData(), ids: Array.from(this.ids), id: this.id };
  }
  clone(e2 = this.ids) {
    const i = new t6(this.mesh.geometry, this.mesh.material, this.capacity), r = [];
    for (const t15 of e2) {
      const e3 = this.getInstancesIDs(t15);
      if (null === e3) continue;
      const i2 = [], n = [];
      for (const t16 of e3) {
        const e4 = new Matrix4(), r2 = new Color();
        this.mesh.getMatrixAt(t16, e4), this.mesh.getColorAt(t16, r2), i2.push(e4), n.push(r2);
      }
      r.push({ id: t15, transforms: i2, colors: n });
    }
    return i.add(r), i;
  }
  putLast(t15) {
    if (0 === this.mesh.count) return;
    const e2 = this.instanceToItem.get(t15), i = this.mesh.count - 1;
    if (i === t15) return;
    const r = this.instanceToItem.get(i);
    if (void 0 === e2 || void 0 === r) throw new Error("Keys not found");
    if (e2 !== r) {
      const s = this.itemToInstances.get(e2), n2 = this.itemToInstances.get(r);
      if (!s || !n2) throw new Error("Instances not found");
      if (!s.has(t15) || !n2.has(i)) throw new Error("Malformed fragment structure");
      s.delete(t15), n2.delete(i), s.add(i), n2.add(t15), this.instanceToItem.set(t15, r), this.instanceToItem.set(i, e2);
    }
    const n = new Matrix4(), o = new Matrix4();
    if (this.mesh.getMatrixAt(t15, n), this.mesh.getMatrixAt(i, o), this.mesh.setMatrixAt(t15, o), this.mesh.setMatrixAt(i, n), null !== this.mesh.instanceColor) {
      const n2 = new Color(), o2 = new Color();
      this.mesh.getColorAt(t15, n2), this.mesh.getColorAt(i, o2), this.mesh.setColorAt(t15, o2), this.mesh.setColorAt(i, n2);
      const a = this._originalColors.get(e2);
      if (a) {
        const e3 = a.get(t15);
        e3 && (a.delete(t15), a.set(i, e3));
      }
      const c = this._originalColors.get(r);
      if (c) {
        const e3 = c.get(i);
        e3 && (c.delete(i), c.set(t15, e3));
      }
    }
  }
};
var Fc = class t7 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsCivilCurve(e2, s) {
    return (s || new t7()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsCivilCurve(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t7()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  points(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  pointsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  pointsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  data(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  static startCivilCurve(t15) {
    t15.startObject(2);
  }
  static addPoints(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createPointsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startPointsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addData(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static endCivilCurve(t15) {
    return t15.endObject();
  }
  static createCivilCurve(e2, s, i) {
    return t7.startCivilCurve(e2), t7.addPoints(e2, s), t7.addData(e2, i), t7.endCivilCurve(e2);
  }
};
var Rc = class t8 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsAlignment(e2, s) {
    return (s || new t8()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsAlignment(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t8()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  vertical(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Fc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  verticalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  horizontal(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? (e2 || new Fc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  horizontalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  absolute(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? (e2 || new Fc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  absoluteLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  initialPk() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.readFloat32(this.bb_pos + t15) : 0;
  }
  static startAlignment(t15) {
    t15.startObject(4);
  }
  static addVertical(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createVerticalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startVerticalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addHorizontal(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createHorizontalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startHorizontalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addAbsolute(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createAbsoluteVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startAbsoluteVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addInitialPk(t15, e2) {
    t15.addFieldFloat32(3, e2, 0);
  }
  static endAlignment(t15) {
    return t15.endObject();
  }
  static createAlignment(e2, s, i, r, n) {
    return t8.startAlignment(e2), t8.addVertical(e2, s), t8.addHorizontal(e2, i), t8.addAbsolute(e2, r), t8.addInitialPk(e2, n), t8.endAlignment(e2);
  }
};
var yc = class t9 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsCivilData(e2, s) {
    return (s || new t9()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsCivilData(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t9()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  alignments(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Rc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  alignmentsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrix(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  coordinationMatrixLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrixArray() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  static startCivilData(t15) {
    t15.startObject(2);
  }
  static addAlignments(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createAlignmentsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startAlignmentsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addCoordinationMatrix(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endCivilData(t15) {
    return t15.endObject();
  }
  static createCivilData(e2, s, i) {
    return t9.startCivilData(e2), t9.addAlignments(e2, s), t9.addCoordinationMatrix(e2, i), t9.endCivilData(e2);
  }
};
var Oc = class t10 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsFragment(e2, s) {
    return (s || new t10()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsFragment(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t10()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  position(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  positionLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  positionArray() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  normal(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  normalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  normalArray() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  index(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  indexLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  indexArray() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  groups(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  groupsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  groupsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  materials(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 12);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  materialsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  materialsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  matrices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 14);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  matricesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  matricesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  colors(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 16);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  colorsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  colorsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsSize(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 18);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsSizeLength() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsSizeArray() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  ids(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 20);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  idsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 20);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  idsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 20);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  id(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 22);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  capacity() {
    const t15 = this.bb.__offset(this.bb_pos, 24);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  capacityOffset() {
    const t15 = this.bb.__offset(this.bb_pos, 26);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  static startFragment(t15) {
    t15.startObject(12);
  }
  static addPosition(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createPositionVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startPositionVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addNormal(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createNormalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startNormalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIndex(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createIndexVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIndexVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addGroups(t15, e2) {
    t15.addFieldOffset(3, e2, 0);
  }
  static createGroupsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startGroupsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addMaterials(t15, e2) {
    t15.addFieldOffset(4, e2, 0);
  }
  static createMaterialsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startMaterialsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addMatrices(t15, e2) {
    t15.addFieldOffset(5, e2, 0);
  }
  static createMatricesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startMatricesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addColors(t15, e2) {
    t15.addFieldOffset(6, e2, 0);
  }
  static createColorsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startColorsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsSize(t15, e2) {
    t15.addFieldOffset(7, e2, 0);
  }
  static createItemsSizeVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsSizeVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIds(t15, e2) {
    t15.addFieldOffset(8, e2, 0);
  }
  static createIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addId(t15, e2) {
    t15.addFieldOffset(9, e2, 0);
  }
  static addCapacity(t15, e2) {
    t15.addFieldInt32(10, e2, 0);
  }
  static addCapacityOffset(t15, e2) {
    t15.addFieldInt32(11, e2, 0);
  }
  static endFragment(t15) {
    return t15.endObject();
  }
  static createFragment(e2, s, i, r, n, o, a, c, h, l, d, b, u) {
    return t10.startFragment(e2), t10.addPosition(e2, s), t10.addNormal(e2, i), t10.addIndex(e2, r), t10.addGroups(e2, n), t10.addMaterials(e2, o), t10.addMatrices(e2, a), t10.addColors(e2, c), t10.addItemsSize(e2, h), t10.addIds(e2, l), t10.addId(e2, d), t10.addCapacity(e2, b), t10.addCapacityOffset(e2, u), t10.endFragment(e2);
  }
};
var Sc = class t11 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsFragmentsGroup(e2, s) {
    return (s || new t11()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsFragmentsGroup(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t11()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  items(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Oc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  itemsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  civil(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? (t15 || new yc()).__init(this.bb.__indirect(this.bb_pos + e2), this.bb) : null;
  }
  coordinationMatrix(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  coordinationMatrixLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrixArray() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  ids(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  idsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  idsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsKeys(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 12);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsKeysLength() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsKeysArray() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsKeysIndices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 14);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsKeysIndicesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsKeysIndicesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsRels(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 16);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsRelsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsRelsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsRelsIndices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 18);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsRelsIndicesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsRelsIndicesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  fragmentKeys(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 20);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  id(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 22);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  name(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 24);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcName(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 26);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcDescription(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 28);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcSchema(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 30);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  maxExpressId() {
    const t15 = this.bb.__offset(this.bb_pos, 32);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  boundingBox(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 34);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  boundingBoxLength() {
    const t15 = this.bb.__offset(this.bb_pos, 34);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  boundingBoxArray() {
    const t15 = this.bb.__offset(this.bb_pos, 34);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  opaqueGeometriesIds(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 36);
    return e2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  opaqueGeometriesIdsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 36);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  opaqueGeometriesIdsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 36);
    return t15 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  transparentGeometriesIds(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 38);
    return e2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  transparentGeometriesIdsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 38);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  transparentGeometriesIdsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 38);
    return t15 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  static startFragmentsGroup(t15) {
    t15.startObject(18);
  }
  static addItems(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createItemsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startItemsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addCivil(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static addCoordinationMatrix(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIds(t15, e2) {
    t15.addFieldOffset(3, e2, 0);
  }
  static createIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsKeys(t15, e2) {
    t15.addFieldOffset(4, e2, 0);
  }
  static createItemsKeysVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsKeysVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsKeysIndices(t15, e2) {
    t15.addFieldOffset(5, e2, 0);
  }
  static createItemsKeysIndicesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsKeysIndicesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsRels(t15, e2) {
    t15.addFieldOffset(6, e2, 0);
  }
  static createItemsRelsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsRelsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsRelsIndices(t15, e2) {
    t15.addFieldOffset(7, e2, 0);
  }
  static createItemsRelsIndicesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsRelsIndicesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addFragmentKeys(t15, e2) {
    t15.addFieldOffset(8, e2, 0);
  }
  static addId(t15, e2) {
    t15.addFieldOffset(9, e2, 0);
  }
  static addName(t15, e2) {
    t15.addFieldOffset(10, e2, 0);
  }
  static addIfcName(t15, e2) {
    t15.addFieldOffset(11, e2, 0);
  }
  static addIfcDescription(t15, e2) {
    t15.addFieldOffset(12, e2, 0);
  }
  static addIfcSchema(t15, e2) {
    t15.addFieldOffset(13, e2, 0);
  }
  static addMaxExpressId(t15, e2) {
    t15.addFieldInt32(14, e2, 0);
  }
  static addBoundingBox(t15, e2) {
    t15.addFieldOffset(15, e2, 0);
  }
  static createBoundingBoxVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startBoundingBoxVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addOpaqueGeometriesIds(t15, e2) {
    t15.addFieldOffset(16, e2, 0);
  }
  static createOpaqueGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startOpaqueGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addTransparentGeometriesIds(t15, e2) {
    t15.addFieldOffset(17, e2, 0);
  }
  static createTransparentGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startTransparentGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endFragmentsGroup(t15) {
    return t15.endObject();
  }
  static finishFragmentsGroupBuffer(t15, e2) {
    t15.finish(e2);
  }
  static finishSizePrefixedFragmentsGroupBuffer(t15, e2) {
    t15.finish(e2, void 0, true);
  }
};
var wc = class {
  constructor() {
    e(this, "version", 1), e(this, "fragmentIDSeparator", "|");
  }
  import(t15) {
    const e2 = new Y(t15), s = Sc.getRootAsFragmentsGroup(e2), i = this.constructFragmentGroup(s), r = s.itemsLength();
    for (let t16 = 0; t16 < r; t16++) {
      const e3 = s.items(t16);
      if (!e3) continue;
      const r2 = this.constructGeometry(e3), n = this.constructMaterials(e3), o = e3.capacity(), a = new Ac(r2, n, o);
      a.capacityOffset = e3.capacityOffset(), this.setInstances(e3, a), this.setID(e3, a), i.items.push(a), i.add(a.mesh);
    }
    return i;
  }
  export(t15) {
    const e2 = new H(1024), s = [], i = Sc, r = Oc;
    let n = null;
    if (t15.civilData) {
      const s2 = [], i2 = Rc, r2 = yc;
      for (const [r3, n2] of t15.civilData.alignments) {
        const { absolute: t16, horizontal: r4, vertical: o3 } = n2, a3 = this.saveCivilCurves(r4, e2), c2 = this.saveCivilCurves(o3, e2), h2 = this.saveCivilCurves(t16, e2), l2 = i2.createHorizontalVector(e2, a3), d2 = i2.createVerticalVector(e2, c2), b2 = i2.createAbsoluteVector(e2, h2);
        i2.startAlignment(e2), i2.addHorizontal(e2, l2), i2.addVertical(e2, d2), i2.addAbsolute(e2, b2), i2.addInitialPk(e2, n2.initialKP);
        const u2 = i2.endAlignment(e2);
        s2.push(u2);
      }
      const o2 = r2.createAlignmentsVector(e2, s2), a2 = r2.createCoordinationMatrixVector(e2, t15.coordinationMatrix.elements);
      r2.startCivilData(e2), r2.addAlignments(e2, o2), r2.addCoordinationMatrix(e2, a2), n = r2.endCivilData(e2);
    }
    for (const i2 of t15.items) {
      const t16 = i2.exportData(), n2 = [];
      for (const t17 of i2.ids) {
        const e3 = i2.getInstancesIDs(t17);
        if (!e3) throw new Error("Instances not found!");
        n2.push(e3.size);
      }
      const o2 = r.createPositionVector(e2, t16.position), a2 = r.createNormalVector(e2, t16.normal), c2 = r.createIndexVector(e2, t16.index), h2 = r.createGroupsVector(e2, t16.groups), l2 = r.createMaterialsVector(e2, t16.materials), d2 = r.createMatricesVector(e2, t16.matrices), b2 = r.createColorsVector(e2, t16.colors), u2 = r.createIdsVector(e2, t16.ids), I2 = r.createItemsSizeVector(e2, n2), f2 = e2.createString(t16.id);
      r.startFragment(e2), r.addPosition(e2, o2), r.addNormal(e2, a2), r.addIndex(e2, c2), r.addGroups(e2, h2), r.addMaterials(e2, l2), r.addMatrices(e2, d2), r.addColors(e2, b2), r.addIds(e2, u2), r.addItemsSize(e2, I2), r.addId(e2, f2), r.addCapacity(e2, i2.capacity), r.addCapacityOffset(e2, i2.capacityOffset);
      const _2 = Oc.endFragment(e2);
      s.push(_2);
    }
    const o = i.createItemsVector(e2, s), a = i.createCoordinationMatrixVector(e2, t15.coordinationMatrix.elements);
    let c = "";
    for (const e3 of t15.keyFragments.values()) c.length && (c += this.fragmentIDSeparator), c += e3;
    const h = e2.createString(c), l = [], d = [], b = [], u = [], I = [];
    let f = 0, _ = 0;
    for (const [e3, [s2, i2]] of t15.data) {
      l.push(f), b.push(_), I.push(e3);
      for (const t16 of s2) d.push(t16);
      for (const t16 of i2) u.push(t16);
      f += s2.length, _ += i2.length;
    }
    const E = [], p = [];
    for (const [e3, s2] of t15.geometryIDs.opaque) E.push(e3, s2);
    for (const [e3, s2] of t15.geometryIDs.transparent) p.push(e3, s2);
    const C = e2.createString(t15.uuid), m = e2.createString(t15.name), g = e2.createString(t15.ifcMetadata.name), T = e2.createString(t15.ifcMetadata.description), A = e2.createString(t15.ifcMetadata.schema), F = i.createItemsKeysIndicesVector(e2, l), R = i.createItemsKeysVector(e2, d), y = i.createItemsRelsIndicesVector(e2, b), O = i.createItemsRelsVector(e2, u), S = i.createIdsVector(e2, I), w = i.createOpaqueGeometriesIdsVector(e2, E), N = i.createTransparentGeometriesIdsVector(e2, p), { min: L, max: v } = t15.boundingBox, M = [L.x, L.y, L.z, v.x, v.y, v.z], P = i.createBoundingBoxVector(e2, M);
    i.startFragmentsGroup(e2), i.addId(e2, C), i.addName(e2, m), i.addIfcName(e2, g), i.addIfcDescription(e2, T), i.addIfcSchema(e2, A), i.addMaxExpressId(e2, t15.ifcMetadata.maxExpressID), i.addItems(e2, o), i.addFragmentKeys(e2, h), i.addIds(e2, S), i.addItemsKeysIndices(e2, F), i.addItemsKeys(e2, R), i.addItemsRelsIndices(e2, y), i.addItemsRels(e2, O), i.addCoordinationMatrix(e2, a), i.addBoundingBox(e2, P), i.addOpaqueGeometriesIds(e2, w), i.addTransparentGeometriesIds(e2, N), null !== n && i.addCivil(e2, n);
    const x = Sc.endFragmentsGroup(e2);
    return e2.finish(x), e2.asUint8Array();
  }
  setID(t15, e2) {
    const s = t15.id();
    s && (e2.id = s, e2.mesh.uuid = s);
  }
  setInstances(t15, e2) {
    const i = t15.matricesArray(), r = t15.colorsArray(), n = t15.idsArray(), o = t15.itemsSizeArray();
    if (!i || !n || !o) throw new Error("Error: Can't load empty fragment!");
    const a = [];
    let c = 0;
    for (let t16 = 0; t16 < o.length; t16++) {
      const e3 = n[t16], h = o[t16], l = [], d = [];
      for (let t17 = 0; t17 < h; t17++) {
        const t18 = 16 * c, e4 = i.subarray(t18, t18 + 17), n2 = new Matrix4().fromArray(e4);
        if (l.push(n2), r) {
          const t19 = 3 * c, [e5, i2, n3] = r.subarray(t19, t19 + 4), o2 = new Color(e5, i2, n3);
          d.push(o2);
        }
        c++;
      }
      const b = d.length ? d : void 0;
      a.push({ id: e3, transforms: l, colors: b });
    }
    e2.add(a);
  }
  constructMaterials(t15) {
    const e2 = t15.materialsArray(), i = [];
    if (!e2) return i;
    for (let t16 = 0; t16 < e2.length; t16 += 5) {
      const r = e2[t16], n = Boolean(e2[t16 + 1]), o = e2[t16 + 2], a = e2[t16 + 3], c = e2[t16 + 4], h = new Color(o, a, c), l = new MeshLambertMaterial({ color: h, opacity: r, transparent: n });
      i.push(l);
    }
    return i;
  }
  constructFragmentGroup(t15) {
    const e2 = new Bc(), i = t15.civil();
    if (i) {
      const t16 = i.coordinationMatrixArray(), r2 = new Matrix4();
      t16 && r2.fromArray(t16), e2.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix: r2 };
      const n2 = i.alignmentsLength();
      for (let t17 = 0; t17 < n2; t17++) {
        const r3 = new LineBasicMaterial({ color: 16777215 }), n3 = new Gc(), o2 = i.alignments(t17);
        if (!o2) throw new Error("Alignment not found!");
        const a2 = o2.horizontalLength();
        n3.horizontal = this.constructCivilCurves(o2, n3, "horizontal", a2, r3);
        const c2 = o2.verticalLength();
        n3.vertical = this.constructCivilCurves(o2, n3, "vertical", c2, r3);
        const h2 = o2.horizontalLength();
        n3.absolute = this.constructCivilCurves(o2, n3, "absolute", h2, r3), n3.initialKP = o2.initialPk(), e2.civilData.alignments.set(t17, n3);
      }
    }
    e2.uuid = t15.id() || e2.uuid, e2.name = t15.name() || "", e2.ifcMetadata = { name: t15.ifcName() || "", description: t15.ifcDescription() || "", schema: t15.ifcSchema() || "IFC2X3", maxExpressID: t15.maxExpressId() || 0 };
    const r = new Matrix4().elements, n = t15.coordinationMatrixArray() || r, o = t15.idsArray() || new Uint32Array(), a = t15.itemsKeysIndicesArray() || new Uint32Array(), c = t15.itemsKeysArray() || new Uint32Array(), h = t15.itemsRelsArray() || new Uint32Array(), l = t15.itemsRelsIndicesArray() || new Uint32Array(), d = (t15.fragmentKeys() || "").split(this.fragmentIDSeparator);
    this.setGroupData(e2, o, a, c, 0), this.setGroupData(e2, o, l, h, 1);
    const b = t15.opaqueGeometriesIdsArray() || new Uint32Array(), u = t15.transparentGeometriesIdsArray() || new Uint32Array(), I = /* @__PURE__ */ new Map();
    for (let t16 = 0; t16 < b.length - 1; t16 += 2) {
      const e3 = b[t16], s = b[t16 + 1];
      I.set(e3, s);
    }
    const f = /* @__PURE__ */ new Map();
    for (let t16 = 0; t16 < u.length - 1; t16 += 2) {
      const e3 = u[t16], s = u[t16 + 1];
      f.set(e3, s);
    }
    e2.geometryIDs = { opaque: I, transparent: f };
    const _ = t15.boundingBoxArray() || [0, 0, 0, 0, 0, 0], [E, p, C, m, g, T] = _;
    e2.boundingBox.min.set(E, p, C), e2.boundingBox.max.set(m, g, T);
    for (let t16 = 0; t16 < d.length; t16++) e2.keyFragments.set(t16, d[t16]);
    return 16 === n.length && e2.coordinationMatrix.fromArray(n), e2;
  }
  setGroupData(t15, e2, s, i, r) {
    for (let n = 0; n < s.length; n++) {
      const o = e2[n], a = s[n], c = s[n + 1] || i.length, h = [];
      for (let t16 = a; t16 < c; t16++) h.push(i[t16]);
      t15.data.has(o) || t15.data.set(o, [[], []]);
      const l = t15.data.get(o);
      l && (l[r] = h);
    }
  }
  constructGeometry(t15) {
    const e2 = t15.positionArray() || new Float32Array(), i = t15.normalArray() || new Float32Array(), r = t15.indexArray(), n = t15.groupsArray();
    if (!r) throw new Error("Index not found!");
    const o = new BufferGeometry();
    if (o.setIndex(Array.from(r)), o.setAttribute("position", new BufferAttribute(e2, 3)), o.setAttribute("normal", new BufferAttribute(i, 3)), n) for (let t16 = 0; t16 < n.length; t16 += 3) {
      const e3 = n[t16], s = n[t16 + 1], i2 = n[t16 + 2];
      o.addGroup(e3, s, i2);
    }
    return o;
  }
  constructCivilCurves(t15, e2, i, r, n) {
    const o = [];
    for (let a = 0; a < r; a++) {
      const r2 = t15[i](a);
      if (!r2) throw new Error("Curve not found!");
      const c = r2.pointsArray();
      if (null === c) throw new Error("Curve points not found!");
      let h = {};
      const l = r2.data();
      l && (h = JSON.parse(l));
      const d = new EdgesGeometry(), b = new BufferAttribute(c, 3);
      d.setAttribute("position", b);
      const u = [];
      for (let t16 = 0; t16 < c.length / 3 - 1; t16++) u.push(t16, t16 + 1);
      d.setIndex(u);
      const I = new Yc(a, h, e2, d, n);
      o.push(I.curve);
    }
    return o;
  }
  saveCivilCurves(t15, e2) {
    const s = Fc, i = [];
    for (const r of t15) {
      const t16 = r.mesh.geometry.attributes.position.array, n = s.createPointsVector(e2, t16), o = e2.createString(JSON.stringify(r.data));
      s.startCivilCurve(e2), s.addPoints(e2, n), s.addData(e2, o);
      const a = s.endCivilCurve(e2);
      i.push(a);
    }
    return i;
  }
};
var Nc = class t12 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsCivilCurve(e2, s) {
    return (s || new t12()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsCivilCurve(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t12()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  points(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  pointsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  pointsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  data(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  static startCivilCurve(t15) {
    t15.startObject(2);
  }
  static addPoints(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createPointsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startPointsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addData(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static endCivilCurve(t15) {
    return t15.endObject();
  }
  static createCivilCurve(e2, s, i) {
    return t12.startCivilCurve(e2), t12.addPoints(e2, s), t12.addData(e2, i), t12.endCivilCurve(e2);
  }
};
var Lc = class _Lc {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsAlignment(t15, e2) {
    return (e2 || new _Lc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  static getSizePrefixedRootAsAlignment(t15, e2) {
    return t15.setPosition(t15.position() + 4), (e2 || new _Lc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  vertical(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Nc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  verticalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  horizontal(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 6);
    return s ? (e2 || new Nc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  horizontalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  absolute(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 8);
    return s ? (e2 || new Nc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  absoluteLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  initialPk() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.readFloat32(this.bb_pos + t15) : 0;
  }
  static startAlignment(t15) {
    t15.startObject(4);
  }
  static addVertical(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createVerticalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startVerticalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addHorizontal(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createHorizontalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startHorizontalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addAbsolute(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createAbsoluteVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startAbsoluteVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addInitialPk(t15, e2) {
    t15.addFieldFloat32(3, e2, 0);
  }
  static endAlignment(t15) {
    return t15.endObject();
  }
  static createAlignment(t15, e2, s, i, r) {
    return _Lc.startAlignment(t15), _Lc.addVertical(t15, e2), _Lc.addHorizontal(t15, s), _Lc.addAbsolute(t15, i), _Lc.addInitialPk(t15, r), _Lc.endAlignment(t15);
  }
};
var vc = class _vc {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsCivilData(t15, e2) {
    return (e2 || new _vc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  static getSizePrefixedRootAsCivilData(t15, e2) {
    return t15.setPosition(t15.position() + 4), (e2 || new _vc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  alignments(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Lc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  alignmentsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrix(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  coordinationMatrixLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrixArray() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  static startCivilData(t15) {
    t15.startObject(2);
  }
  static addAlignments(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createAlignmentsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startAlignmentsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addCoordinationMatrix(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endCivilData(t15) {
    return t15.endObject();
  }
  static createCivilData(t15, e2, s) {
    return _vc.startCivilData(t15), _vc.addAlignments(t15, e2), _vc.addCoordinationMatrix(t15, s), _vc.endCivilData(t15);
  }
};
var Mc = class _Mc {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsFragment(t15, e2) {
    return (e2 || new _Mc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  static getSizePrefixedRootAsFragment(t15, e2) {
    return t15.setPosition(t15.position() + 4), (e2 || new _Mc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  position(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  positionLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  positionArray() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  normal(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  normalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  normalArray() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  index(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  indexLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  indexArray() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  groups(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  groupsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  groupsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  materials(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 12);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  materialsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  materialsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  matrices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 14);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  matricesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  matricesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  colors(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 16);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  colorsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  colorsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsSize(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 18);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsSizeLength() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsSizeArray() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  ids(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 20);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  idsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 20);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  idsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 20);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  id(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 22);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  capacity() {
    const t15 = this.bb.__offset(this.bb_pos, 24);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  capacityOffset() {
    const t15 = this.bb.__offset(this.bb_pos, 26);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  static startFragment(t15) {
    t15.startObject(12);
  }
  static addPosition(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createPositionVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startPositionVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addNormal(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createNormalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startNormalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIndex(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createIndexVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIndexVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addGroups(t15, e2) {
    t15.addFieldOffset(3, e2, 0);
  }
  static createGroupsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startGroupsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addMaterials(t15, e2) {
    t15.addFieldOffset(4, e2, 0);
  }
  static createMaterialsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startMaterialsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addMatrices(t15, e2) {
    t15.addFieldOffset(5, e2, 0);
  }
  static createMatricesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startMatricesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addColors(t15, e2) {
    t15.addFieldOffset(6, e2, 0);
  }
  static createColorsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startColorsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsSize(t15, e2) {
    t15.addFieldOffset(7, e2, 0);
  }
  static createItemsSizeVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsSizeVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIds(t15, e2) {
    t15.addFieldOffset(8, e2, 0);
  }
  static createIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addId(t15, e2) {
    t15.addFieldOffset(9, e2, 0);
  }
  static addCapacity(t15, e2) {
    t15.addFieldInt32(10, e2, 0);
  }
  static addCapacityOffset(t15, e2) {
    t15.addFieldInt32(11, e2, 0);
  }
  static endFragment(t15) {
    return t15.endObject();
  }
  static createFragment(t15, e2, s, i, r, n, o, a, c, h, l, d, b) {
    return _Mc.startFragment(t15), _Mc.addPosition(t15, e2), _Mc.addNormal(t15, s), _Mc.addIndex(t15, i), _Mc.addGroups(t15, r), _Mc.addMaterials(t15, n), _Mc.addMatrices(t15, o), _Mc.addColors(t15, a), _Mc.addItemsSize(t15, c), _Mc.addIds(t15, h), _Mc.addId(t15, l), _Mc.addCapacity(t15, d), _Mc.addCapacityOffset(t15, b), _Mc.endFragment(t15);
  }
};
var Pc = class t13 {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsFragmentsGroup(e2, s) {
    return (s || new t13()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  static getSizePrefixedRootAsFragmentsGroup(e2, s) {
    return e2.setPosition(e2.position() + 4), (s || new t13()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  items(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Mc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  itemsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  civil(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? (t15 || new vc()).__init(this.bb.__indirect(this.bb_pos + e2), this.bb) : null;
  }
  coordinationMatrix(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  coordinationMatrixLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  coordinationMatrixArray() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  ids(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  idsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  idsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsKeys(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 12);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsKeysLength() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsKeysArray() {
    const t15 = this.bb.__offset(this.bb_pos, 12);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsKeysIndices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 14);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsKeysIndicesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsKeysIndicesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 14);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsRels(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 16);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsRelsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsRelsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 16);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  itemsRelsIndices(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 18);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  itemsRelsIndicesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  itemsRelsIndicesArray() {
    const t15 = this.bb.__offset(this.bb_pos, 18);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  fragmentKeys(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 20);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  globalIds(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 22);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  id(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 24);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  name(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 26);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcName(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 28);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcDescription(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 30);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  ifcSchema(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 32);
    return e2 ? this.bb.__string(this.bb_pos + e2, t15) : null;
  }
  maxExpressId() {
    const t15 = this.bb.__offset(this.bb_pos, 34);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  boundingBox(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 36);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  boundingBoxLength() {
    const t15 = this.bb.__offset(this.bb_pos, 36);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  boundingBoxArray() {
    const t15 = this.bb.__offset(this.bb_pos, 36);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  opaqueGeometriesIds(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 38);
    return e2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  opaqueGeometriesIdsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 38);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  opaqueGeometriesIdsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 38);
    return t15 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  transparentGeometriesIds(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 40);
    return e2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  transparentGeometriesIdsLength() {
    const t15 = this.bb.__offset(this.bb_pos, 40);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  transparentGeometriesIdsArray() {
    const t15 = this.bb.__offset(this.bb_pos, 40);
    return t15 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  static startFragmentsGroup(t15) {
    t15.startObject(19);
  }
  static addItems(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createItemsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startItemsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addCivil(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static addCoordinationMatrix(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startCoordinationMatrixVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIds(t15, e2) {
    t15.addFieldOffset(3, e2, 0);
  }
  static createIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsKeys(t15, e2) {
    t15.addFieldOffset(4, e2, 0);
  }
  static createItemsKeysVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsKeysVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsKeysIndices(t15, e2) {
    t15.addFieldOffset(5, e2, 0);
  }
  static createItemsKeysIndicesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsKeysIndicesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsRels(t15, e2) {
    t15.addFieldOffset(6, e2, 0);
  }
  static createItemsRelsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsRelsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addItemsRelsIndices(t15, e2) {
    t15.addFieldOffset(7, e2, 0);
  }
  static createItemsRelsIndicesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startItemsRelsIndicesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addFragmentKeys(t15, e2) {
    t15.addFieldOffset(8, e2, 0);
  }
  static addGlobalIds(t15, e2) {
    t15.addFieldOffset(9, e2, 0);
  }
  static addId(t15, e2) {
    t15.addFieldOffset(10, e2, 0);
  }
  static addName(t15, e2) {
    t15.addFieldOffset(11, e2, 0);
  }
  static addIfcName(t15, e2) {
    t15.addFieldOffset(12, e2, 0);
  }
  static addIfcDescription(t15, e2) {
    t15.addFieldOffset(13, e2, 0);
  }
  static addIfcSchema(t15, e2) {
    t15.addFieldOffset(14, e2, 0);
  }
  static addMaxExpressId(t15, e2) {
    t15.addFieldInt32(15, e2, 0);
  }
  static addBoundingBox(t15, e2) {
    t15.addFieldOffset(16, e2, 0);
  }
  static createBoundingBoxVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startBoundingBoxVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addOpaqueGeometriesIds(t15, e2) {
    t15.addFieldOffset(17, e2, 0);
  }
  static createOpaqueGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startOpaqueGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addTransparentGeometriesIds(t15, e2) {
    t15.addFieldOffset(18, e2, 0);
  }
  static createTransparentGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startTransparentGeometriesIdsVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endFragmentsGroup(t15) {
    return t15.endObject();
  }
  static finishFragmentsGroupBuffer(t15, e2) {
    t15.finish(e2);
  }
  static finishSizePrefixedFragmentsGroupBuffer(t15, e2) {
    t15.finish(e2, void 0, true);
  }
};
var xc = class {
  constructor() {
    e(this, "version", 2), e(this, "separator", "|");
  }
  import(t15) {
    const e2 = new Y(t15), s = Pc.getRootAsFragmentsGroup(e2), i = this.constructFragmentGroup(s), r = s.itemsLength();
    for (let t16 = 0; t16 < r; t16++) {
      const e3 = s.items(t16);
      if (!e3) continue;
      const r2 = this.constructGeometry(e3), n = this.constructMaterials(e3), o = e3.capacity(), a = new Ac(r2, n, o);
      a.capacityOffset = e3.capacityOffset(), this.setInstances(e3, a), this.setID(e3, a), i.items.push(a), i.add(a.mesh);
    }
    return i;
  }
  export(t15) {
    const e2 = new H(1024), s = [], i = Pc, r = Mc;
    let n = null;
    if (t15.civilData) {
      const s2 = [], i2 = Lc, r2 = vc;
      for (const [r3, n2] of t15.civilData.alignments) {
        const { absolute: t16, horizontal: r4, vertical: o3 } = n2, a3 = this.saveCivilCurves(r4, e2), c2 = this.saveCivilCurves(o3, e2), h2 = this.saveCivilCurves(t16, e2), l2 = i2.createHorizontalVector(e2, a3), d2 = i2.createVerticalVector(e2, c2), b2 = i2.createAbsoluteVector(e2, h2);
        i2.startAlignment(e2), i2.addHorizontal(e2, l2), i2.addVertical(e2, d2), i2.addAbsolute(e2, b2), i2.addInitialPk(e2, n2.initialKP);
        const u2 = i2.endAlignment(e2);
        s2.push(u2);
      }
      const o2 = r2.createAlignmentsVector(e2, s2), a2 = r2.createCoordinationMatrixVector(e2, t15.coordinationMatrix.elements);
      r2.startCivilData(e2), r2.addAlignments(e2, o2), r2.addCoordinationMatrix(e2, a2), n = r2.endCivilData(e2);
    }
    for (const i2 of t15.items) {
      const t16 = i2.exportData(), n2 = [];
      for (const t17 of i2.ids) {
        const e3 = i2.getInstancesIDs(t17);
        if (!e3) throw new Error("Instances not found!");
        n2.push(e3.size);
      }
      const o2 = r.createPositionVector(e2, t16.position), a2 = r.createNormalVector(e2, t16.normal), c2 = r.createIndexVector(e2, t16.index), h2 = r.createGroupsVector(e2, t16.groups), l2 = r.createMaterialsVector(e2, t16.materials), d2 = r.createMatricesVector(e2, t16.matrices), b2 = r.createColorsVector(e2, t16.colors), u2 = r.createIdsVector(e2, t16.ids), I2 = r.createItemsSizeVector(e2, n2), f2 = e2.createString(t16.id);
      r.startFragment(e2), r.addPosition(e2, o2), r.addNormal(e2, a2), r.addIndex(e2, c2), r.addGroups(e2, h2), r.addMaterials(e2, l2), r.addMatrices(e2, d2), r.addColors(e2, b2), r.addIds(e2, u2), r.addItemsSize(e2, I2), r.addId(e2, f2), r.addCapacity(e2, i2.capacity), r.addCapacityOffset(e2, i2.capacityOffset);
      const _2 = Mc.endFragment(e2);
      s.push(_2);
    }
    const o = i.createItemsVector(e2, s), a = i.createCoordinationMatrixVector(e2, t15.coordinationMatrix.elements);
    let c = "";
    for (const e3 of t15.keyFragments.values()) c.length && (c += this.separator), c += e3;
    let h = "";
    for (const [e3] of t15.globalToExpressIDs) h.length && (h += this.separator), h += e3;
    const l = e2.createString(c), d = e2.createString(h), b = [], u = [], I = [], f = [], _ = [];
    let E = 0, p = 0;
    for (const [e3, [s2, i2]] of t15.data) {
      b.push(E), I.push(p), _.push(e3);
      for (const t16 of s2) u.push(t16);
      for (const t16 of i2) f.push(t16);
      E += s2.length, p += i2.length;
    }
    const C = [], m = [];
    for (const [e3, s2] of t15.geometryIDs.opaque) C.push(e3, s2);
    for (const [e3, s2] of t15.geometryIDs.transparent) m.push(e3, s2);
    const g = e2.createString(t15.uuid), T = e2.createString(t15.name), A = e2.createString(t15.ifcMetadata.name), F = e2.createString(t15.ifcMetadata.description), R = e2.createString(t15.ifcMetadata.schema), y = i.createItemsKeysIndicesVector(e2, b), O = i.createItemsKeysVector(e2, u), S = i.createItemsRelsIndicesVector(e2, I), w = i.createItemsRelsVector(e2, f), N = i.createIdsVector(e2, _), L = i.createOpaqueGeometriesIdsVector(e2, C), v = i.createTransparentGeometriesIdsVector(e2, m), { min: M, max: P } = t15.boundingBox, x = [M.x, M.y, M.z, P.x, P.y, P.z], U2 = i.createBoundingBoxVector(e2, x);
    i.startFragmentsGroup(e2), i.addId(e2, g), i.addName(e2, T), i.addIfcName(e2, A), i.addIfcDescription(e2, F), i.addIfcSchema(e2, R), i.addMaxExpressId(e2, t15.ifcMetadata.maxExpressID), i.addItems(e2, o), i.addFragmentKeys(e2, l), i.addGlobalIds(e2, d), i.addIds(e2, N), i.addItemsKeysIndices(e2, y), i.addItemsKeys(e2, O), i.addItemsRelsIndices(e2, S), i.addItemsRels(e2, w), i.addCoordinationMatrix(e2, a), i.addBoundingBox(e2, U2), i.addOpaqueGeometriesIds(e2, L), i.addTransparentGeometriesIds(e2, v), null !== n && i.addCivil(e2, n);
    const D2 = Pc.endFragmentsGroup(e2);
    return e2.finish(D2), e2.asUint8Array();
  }
  setID(t15, e2) {
    const s = t15.id();
    s && (e2.id = s, e2.mesh.uuid = s);
  }
  setInstances(t15, e2) {
    const i = t15.matricesArray(), r = t15.colorsArray(), n = t15.idsArray(), o = t15.itemsSizeArray();
    if (!i || !n || !o) throw new Error("Error: Can't load empty fragment!");
    const a = [];
    let c = 0;
    for (let t16 = 0; t16 < o.length; t16++) {
      const e3 = n[t16], h = o[t16], l = [], d = [];
      for (let t17 = 0; t17 < h; t17++) {
        const t18 = 16 * c, e4 = i.subarray(t18, t18 + 17), n2 = new Matrix4().fromArray(e4);
        if (l.push(n2), r) {
          const t19 = 3 * c, [e5, i2, n3] = r.subarray(t19, t19 + 4), o2 = new Color(e5, i2, n3);
          d.push(o2);
        }
        c++;
      }
      const b = d.length ? d : void 0;
      a.push({ id: e3, transforms: l, colors: b });
    }
    e2.add(a);
  }
  constructMaterials(t15) {
    const e2 = t15.materialsArray(), i = [];
    if (!e2) return i;
    for (let t16 = 0; t16 < e2.length; t16 += 5) {
      const r = e2[t16], n = Boolean(e2[t16 + 1]), o = e2[t16 + 2], a = e2[t16 + 3], c = e2[t16 + 4], h = new Color(o, a, c), l = new MeshLambertMaterial({ color: h, opacity: r, transparent: n });
      i.push(l);
    }
    return i;
  }
  constructFragmentGroup(t15) {
    const e2 = new Bc(), i = t15.civil();
    if (i) {
      const t16 = i.coordinationMatrixArray(), r2 = new Matrix4();
      t16 && r2.fromArray(t16), e2.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix: r2 };
      const n2 = i.alignmentsLength();
      for (let t17 = 0; t17 < n2; t17++) {
        const r3 = new LineBasicMaterial({ color: 16777215 }), n3 = new Gc(), o2 = i.alignments(t17);
        if (!o2) throw new Error("Alignment not found!");
        const a2 = o2.horizontalLength();
        n3.horizontal = this.constructCivilCurves(o2, n3, "horizontal", a2, r3);
        const c2 = o2.verticalLength();
        n3.vertical = this.constructCivilCurves(o2, n3, "vertical", c2, r3);
        const h2 = o2.horizontalLength();
        n3.absolute = this.constructCivilCurves(o2, n3, "absolute", h2, r3), n3.initialKP = o2.initialPk(), e2.civilData.alignments.set(t17, n3);
      }
    }
    e2.uuid = t15.id() || e2.uuid, e2.name = t15.name() || "", e2.ifcMetadata = { name: t15.ifcName() || "", description: t15.ifcDescription() || "", schema: t15.ifcSchema() || "IFC2X3", maxExpressID: t15.maxExpressId() || 0 };
    const r = new Matrix4().elements, n = t15.coordinationMatrixArray() || r, o = t15.idsArray() || new Uint32Array(), a = t15.itemsKeysIndicesArray() || new Uint32Array(), c = t15.itemsKeysArray() || new Uint32Array(), h = t15.itemsRelsArray() || new Uint32Array(), l = t15.itemsRelsIndicesArray() || new Uint32Array(), d = (t15.fragmentKeys() || "").split(this.separator), b = (t15.globalIds() || "").split(this.separator);
    this.setGroupData(e2, o, a, c, 0), this.setGroupData(e2, o, l, h, 1);
    const u = t15.opaqueGeometriesIdsArray() || new Uint32Array(), I = t15.transparentGeometriesIdsArray() || new Uint32Array(), f = /* @__PURE__ */ new Map();
    for (let t16 = 0; t16 < u.length - 1; t16 += 2) {
      const e3 = u[t16], s = u[t16 + 1];
      f.set(e3, s);
    }
    const _ = /* @__PURE__ */ new Map();
    for (let t16 = 0; t16 < I.length - 1; t16 += 2) {
      const e3 = I[t16], s = I[t16 + 1];
      _.set(e3, s);
    }
    e2.geometryIDs = { opaque: f, transparent: _ };
    const E = t15.boundingBoxArray() || [0, 0, 0, 0, 0, 0], [p, C, m, g, T, A] = E;
    e2.boundingBox.min.set(p, C, m), e2.boundingBox.max.set(g, T, A);
    for (let t16 = 0; t16 < d.length; t16++) e2.keyFragments.set(t16, d[t16]);
    16 === n.length && e2.coordinationMatrix.fromArray(n);
    for (let t16 = 0; t16 < o.length; t16++) e2.globalToExpressIDs.set(b[t16], o[t16]);
    return e2;
  }
  setGroupData(t15, e2, s, i, r) {
    for (let n = 0; n < s.length; n++) {
      const o = e2[n], a = s[n], c = s[n + 1], h = void 0 === c ? i.length : c, l = [];
      for (let t16 = a; t16 < h; t16++) l.push(i[t16]);
      t15.data.has(o) || t15.data.set(o, [[], []]);
      const d = t15.data.get(o);
      d && (d[r] = l);
    }
  }
  constructGeometry(t15) {
    const e2 = t15.positionArray() || new Float32Array(), i = t15.normalArray() || new Float32Array(), r = t15.indexArray(), n = t15.groupsArray();
    if (!r) throw new Error("Index not found!");
    const o = new BufferGeometry();
    if (o.setIndex(Array.from(r)), o.setAttribute("position", new BufferAttribute(e2, 3)), o.setAttribute("normal", new BufferAttribute(i, 3)), n) for (let t16 = 0; t16 < n.length; t16 += 3) {
      const e3 = n[t16], s = n[t16 + 1], i2 = n[t16 + 2];
      o.addGroup(e3, s, i2);
    }
    return o;
  }
  constructCivilCurves(t15, e2, i, r, n) {
    const o = [];
    for (let a = 0; a < r; a++) {
      const r2 = t15[i](a);
      if (!r2) throw new Error("Curve not found!");
      const c = r2.pointsArray();
      if (null === c) throw new Error("Curve points not found!");
      let h = {};
      const l = r2.data();
      l && (h = JSON.parse(l));
      const d = new EdgesGeometry(), b = new BufferAttribute(c, 3);
      d.setAttribute("position", b);
      const u = [];
      for (let t16 = 0; t16 < c.length / 3 - 1; t16++) u.push(t16, t16 + 1);
      d.setIndex(u);
      const I = new Yc(a, h, e2, d, n);
      o.push(I.curve);
    }
    return o;
  }
  saveCivilCurves(t15, e2) {
    const s = Nc, i = [];
    for (const r of t15) {
      const t16 = r.mesh.geometry.attributes.position.array, n = s.createPointsVector(e2, t16), o = e2.createString(JSON.stringify(r.data));
      s.startCivilCurve(e2), s.addPoints(e2, n), s.addData(e2, o);
      const a = s.endCivilCurve(e2);
      i.push(a);
    }
    return i;
  }
};
var Uc = class {
  constructor() {
    e(this, "parsers", [new xc(), new wc()]), e(this, "version", "auto");
  }
  import(t15) {
    const e2 = this.parsers.length;
    if ("auto" === this.version) {
      for (let s2 = 0; s2 < this.parsers.length; s2++) {
        const i2 = this.parsers[s2].import(t15);
        if (0 !== Object.keys(i2).length) {
          if (0 !== s2) {
            const t16 = this.parsers.length - s2;
            this.warnVersion(t16, e2);
          }
          return i2;
        }
      }
      throw new Error("No valid parser found for this file");
    }
    this.checkCurrentVersionValid(this.version);
    const s = this.parsers.length - this.version, i = this.parsers[s].import(t15);
    if (0 === Object.keys(i).length) throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);
    return i;
  }
  export(t15) {
    if ("auto" === this.version) {
      return this.parsers[0].export(t15);
    }
    this.checkCurrentVersionValid(this.version);
    const e2 = this.parsers.length - this.version;
    return this.parsers[e2].export(t15);
  }
  checkCurrentVersionValid(t15) {
    if ("auto" === this.version) return;
    this.version !== t15 && this.warnVersion(this.version, t15);
    if (!Number.isInteger(this.version)) throw new Error("Invalid version. Non-automatic versions must an integer.");
    if (this.version < 1 || this.version > t15) throw new Error(`Invalid version. Versions range from 1 to ${t15}.`);
  }
  warnVersion(t15, e2) {
    console.warn(`This fragment file version is ${t15}. The latest version is ${e2}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`);
  }
};
var Dc = class {
  constructor(t15) {
    e(this, "baseDirectory"), e(this, "maxDeadTime", 6e4), e(this, "mode", "buffer"), e(this, "_memoryCleanTime", 1e4), e(this, "_intervalID", null), e(this, "_isCleaningMemory", false), e(this, "cleanMemory", async () => {
      if (this._isCleaningMemory) return;
      this._isCleaningMemory = true;
      const t16 = await this.getDir(this.baseDirectory), e2 = /* @__PURE__ */ new Set(), s = (/* @__PURE__ */ new Date()).getTime();
      for await (const i of t16.values()) {
        const t17 = localStorage.getItem(i.name) || "0";
        s - parseInt(t17, 10) > this.maxDeadTime && (e2.add(i.name), localStorage.removeItem(i.name));
      }
      for (const s2 of e2) t16.removeEntry(s2);
      this._isCleaningMemory = false;
    }), this.baseDirectory = t15, this.setupMemoryCleanup();
  }
  get memoryCleanTime() {
    return this._memoryCleanTime;
  }
  set memoryCleanTime(t15) {
    this._memoryCleanTime = t15, this.dispose(), this.setupMemoryCleanup();
  }
  isCached(t15) {
    const e2 = this.encodeName(t15);
    return null !== localStorage.getItem(e2);
  }
  async get(t15) {
    const e2 = this.encodeName(t15), s = await this.getDir(this.baseDirectory);
    try {
      const t16 = await s.getFileHandle(e2), i = await t16.getFile();
      return this.updateLastAccessTime(e2), i;
    } catch (t16) {
      return null;
    }
  }
  async add(t15, e2) {
    const s = this.encodeName(t15), i = await this.getDir(this.baseDirectory), r = await i.getFileHandle(s, { create: true }), n = await r.createWritable();
    await n.write(e2), await n.close(), this.updateLastAccessTime(s);
  }
  async clear() {
    const t15 = await this.getDir(this.baseDirectory);
    for await (const [e2] of t15.entries()) await t15.removeEntry(e2);
  }
  dispose() {
    null !== this._intervalID && window.clearInterval(this._intervalID);
  }
  setupMemoryCleanup() {
    this._intervalID = window.setInterval(this.cleanMemory, this.memoryCleanTime);
  }
  async getDir(t15) {
    return (await navigator.storage.getDirectory()).getDirectoryHandle(t15, { create: true });
  }
  encodeName(t15) {
    return t15.replace(/[\\/:*?"<>|]/g, "ñ");
  }
  updateLastAccessTime(t15) {
    const e2 = (/* @__PURE__ */ new Date()).getTime().toString();
    localStorage.setItem(t15, e2);
  }
};
var Vc = class t14 extends Group {
  constructor() {
    super(...arguments), e(this, "items", []), e(this, "boundingBox", new Box3()), e(this, "coordinationMatrix", new Matrix4()), e(this, "keyFragments", /* @__PURE__ */ new Map()), e(this, "globalToExpressIDs", /* @__PURE__ */ new Map()), e(this, "data", /* @__PURE__ */ new Map()), e(this, "geometryIDs", { opaque: /* @__PURE__ */ new Map(), transparent: /* @__PURE__ */ new Map() }), e(this, "ifcMetadata", { name: "", description: "", schema: "IFC2X3", maxExpressID: 0 }), e(this, "civilData"), e(this, "streamSettings", { baseFileName: "", ids: /* @__PURE__ */ new Map(), types: /* @__PURE__ */ new Map() }), e(this, "isStreamed", false), e(this, "_properties");
  }
  get hasProperties() {
    const t15 = void 0 !== this._properties, e2 = 0 !== this.streamSettings.ids.size;
    return t15 || e2;
  }
  getFragmentMap(t15 = this.data.keys()) {
    const e2 = {};
    for (const s of t15) {
      const t16 = this.data.get(s);
      if (t16) for (const i of t16[0]) {
        const t17 = this.keyFragments.get(i);
        void 0 !== t17 && (e2[t17] || (e2[t17] = /* @__PURE__ */ new Set()), e2[t17].add(s));
      }
    }
    return e2;
  }
  getItemVertices(t15) {
    const e2 = [], i = this.getFragmentMap([t15]);
    for (const r in i) {
      const i2 = this.items.find((t16) => t16.id === r);
      if (!i2) continue;
      const n = i2.getInstancesIDs(t15);
      if (n) for (const t16 of n) {
        const r2 = new Matrix4();
        i2.mesh.getMatrixAt(t16, r2);
        for (const t17 of i2.uniqueVertices) {
          const s = t17.clone().applyMatrix4(r2);
          e2.push(s);
        }
      }
    }
    return e2;
  }
  static setPropertiesDB(e2) {
    e2 ? t14.propertiesDB || (t14.propertiesDB = new Dc("that-open-company-streaming-properties")) : e2 || t14.propertiesDB && t14.propertiesDB.dispose();
  }
  dispose(t15 = true) {
    for (const e2 of this.items) e2.dispose(t15);
    if (this.coordinationMatrix = new Matrix4(), this.keyFragments.clear(), this.data.clear(), this._properties = {}, this.removeFromParent(), this.items = [], this.civilData) {
      const { alignments: t16 } = this.civilData;
      for (const [e2, s] of t16) this.disposeAlignment(s.vertical), this.disposeAlignment(s.horizontal), this.disposeAlignment(s.absolute);
    }
    this.civilData = void 0;
  }
  setLocalProperties(t15) {
    this._properties = t15;
  }
  getLocalProperties() {
    return this._properties;
  }
  getAllPropertiesIDs() {
    return this._properties ? Object.keys(this._properties).map((t15) => parseInt(t15, 10)) : Array.from(this.streamSettings.ids.keys());
  }
  getAllPropertiesTypes() {
    if (this._properties) {
      const t15 = /* @__PURE__ */ new Set();
      for (const e2 in this._properties) {
        const s = this._properties[e2];
        void 0 !== s.type && t15.add(s.type);
      }
      return Array.from(t15);
    }
    return Array.from(this.streamSettings.types.keys());
  }
  async getProperties(t15) {
    if (this._properties) return this._properties[t15] || null;
    const e2 = this.getPropsURL(t15), s = await this.getPropertiesData(e2);
    return s ? s[t15] : null;
  }
  async setProperties(t15, e2) {
    if (!this._properties) throw new Error("Writing streamed properties not supported yet!");
    null !== e2 ? this._properties[t15] = e2 : delete this._properties[t15];
  }
  async getAllPropertiesOfType(t15) {
    if (this._properties) {
      const e3 = {};
      let s2 = false;
      for (const i2 in this._properties) {
        const r = this._properties[i2];
        r.type === t15 && (e3[r.expressID] = r, s2 = true);
      }
      return s2 ? e3 : null;
    }
    const { types: e2 } = this.streamSettings, s = e2.get(t15);
    if (void 0 === s) return null;
    const i = {};
    for (const t16 of s) {
      const e3 = this.constructFileName(t16), s2 = await this.getPropertiesData(e3);
      for (const t17 in s2) i[parseInt(t17, 10)] = s2[t17];
    }
    return i;
  }
  clone(t15) {
    throw new Error("Use FragmentsGroup.cloneGroup instead!");
  }
  cloneGroup(e2) {
    const s = new t14();
    s.coordinationMatrix = this.coordinationMatrix, s.position.copy(this.position), s.rotation.copy(this.rotation), s.scale.copy(this.scale), s.updateMatrix(), s.ifcMetadata = { ...this.ifcMetadata }, e2 || (e2 = this.getFragmentMap(this.data.keys()));
    const i = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map();
    for (const t15 of this.items) {
      if (!e2[t15.id]) continue;
      const n = e2[t15.id], o = t15.clone(n);
      r.set(t15.id, o.id), s.items.push(o), s.add(o.mesh);
      for (const t16 of n) i.add(t16);
    }
    for (const t15 of i) {
      const e3 = this.data.get(t15);
      e3 && s.data.set(t15, e3);
    }
    for (const [t15, e3] of this.keyFragments) if (r.has(e3)) {
      const i2 = r.get(e3);
      if (void 0 === i2) throw new Error("Malformed fragment ID map during clone!");
      s.keyFragments.set(t15, i2);
    }
    for (const [t15, e3] of this.globalToExpressIDs) i.has(e3) && s.globalToExpressIDs.set(t15, e3);
    return this.civilData && (s.civilData = { coordinationMatrix: this.coordinationMatrix, alignments: /* @__PURE__ */ new Map() }), s;
  }
  getPropsURL(t15) {
    const { ids: e2 } = this.streamSettings, s = e2.get(t15);
    if (void 0 === s) throw new Error("ID not found");
    return this.constructFileName(s);
  }
  async getPropertiesData(e2) {
    var s;
    let i;
    if ((null == (s = this.streamSettings.baseUrl) ? void 0 : s.length) && (console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."), t14.url = this.streamSettings.baseUrl), t14.useCache) {
      let s2 = null;
      if (t14.propertiesDB && (s2 = await t14.propertiesDB.get(e2)), s2) i = await s2.text();
      else {
        const s3 = await t14.fetch(e2);
        if (i = await s3.text(), t14.propertiesDB) {
          const s4 = new TextEncoder().encode(i);
          await t14.propertiesDB.add(e2, s4);
        }
      }
    } else {
      const s2 = await t14.fetch(e2);
      i = await s2.text();
    }
    return JSON.parse(i);
  }
  constructFileName(e2) {
    if (t14.constructFileName) return t14.constructFileName(e2);
    const { baseFileName: s } = this.streamSettings;
    return `${s}-${e2}`;
  }
  disposeAlignment(t15) {
    for (const e2 of t15) if (e2.mesh.geometry.dispose(), Array.isArray(e2.mesh.material)) for (const t16 of e2.mesh.material) t16.dispose();
    else e2.mesh.material.dispose();
    t15.length = 0;
  }
};
e(Vc, "fetch", async (t15) => fetch(`${Vc.url}${t15}`)), e(Vc, "constructFileName", null), e(Vc, "url", ""), e(Vc, "useCache", true), e(Vc, "propertiesDB", null);
var Bc = Vc;
var Gc = class {
  constructor() {
    e(this, "vertical", []), e(this, "horizontal", []), e(this, "absolute", []), e(this, "initialKP", 0);
  }
  getLength(t15) {
    let e2 = 0;
    for (const s of this[t15]) e2 += s.getLength();
    return e2;
  }
  getPointAt(t15, e2) {
    const s = this.getCurveAt(t15, e2);
    return s.curve.getPointAt(s.percentage);
  }
  getPercentageAt(t15, e2, s = 0.01) {
    const i = this[e2];
    let r = 0;
    for (const n of i) {
      const i2 = n.getPercentageAt(t15, s), o = n.getLength();
      if (null !== i2) {
        return (r + i2 * o) / this.getLength(e2);
      }
      r += o;
    }
    return null;
  }
  getCurveAt(t15, e2) {
    t15 < 0 ? t15 = 0 : t15 > 1 && (t15 = 1);
    const s = this[e2], i = this.getLength(e2) * t15;
    let r = 0;
    for (const t16 of s) {
      const e3 = t16.getLength();
      if (r + e3 >= i) {
        return { curve: t16, percentage: (i - r) / e3 };
      }
      r += e3;
    }
    throw new Error("Could not compute point!");
  }
};
var zc = class {
  constructor(t15, s, i, r) {
    e(this, "index"), e(this, "mesh"), e(this, "data"), e(this, "alignment"), this.index = t15, this.mesh = s, this.data = i, this.alignment = r;
  }
  get _index() {
    return this.mesh.geometry.index;
  }
  get _pos() {
    return this.mesh.geometry.attributes.position.array;
  }
  getLength() {
    let t15 = 0;
    for (let e2 = 0; e2 < this._index.array.length - 1; e2 += 2) {
      const { startPoint: s, endPoint: i } = this.getSegment(e2);
      t15 += s.distanceTo(i);
    }
    return t15;
  }
  getPointAt(t15) {
    const { startPoint: e2, endPoint: s, distanceToStart: i } = this.getSegmentAt(t15), r = s.clone();
    return r.sub(e2), r.normalize(), r.multiplyScalar(i), r.add(e2), r;
  }
  getSegmentAt(t15) {
    t15 < 0 ? t15 = 0 : t15 > 1 && (t15 = 1);
    const e2 = this.getLength() * t15;
    let s = 0;
    for (let t16 = 0; t16 < this._index.array.length - 1; t16 += 2) {
      const { startPoint: i, endPoint: r } = this.getSegment(t16), n = i.distanceTo(r);
      if (s + n >= e2) {
        return { distanceToStart: e2 - s, index: t16, startPoint: i, endPoint: r };
      }
      s += n;
    }
    throw new Error("Could not compute point");
  }
  getPercentageAt(t15, e2 = 0.01) {
    let s = 0;
    for (let i = 0; i < this._index.array.length - 1; i += 2) {
      const { startPoint: r, endPoint: n } = this.getSegment(i), o = r.distanceTo(n), a = t15.distanceTo(r);
      if (a + t15.distanceTo(n) - o <= e2) {
        return (s + a) / this.getLength();
      }
      s += o;
    }
    return null;
  }
  getSegment(t15) {
    const e2 = 3 * this._index.array[t15], i = 3 * this._index.array[t15 + 1];
    return { startPoint: new Vector3(this._pos[e2], this._pos[e2 + 1], this._pos[e2 + 2]), endPoint: new Vector3(this._pos[i], this._pos[i + 1], this._pos[i + 2]) };
  }
};
var Yc = class extends LineSegments {
  constructor(t15, s, i, r, n) {
    super(r, n), e(this, "curve"), this.curve = new zc(t15, this, s, i);
  }
};
var Hc = class _Hc {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsStreamedGeometry(t15, e2) {
    return (e2 || new _Hc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  static getSizePrefixedRootAsStreamedGeometry(t15, e2) {
    return t15.setPosition(t15.position() + 4), (e2 || new _Hc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  geometryId() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.readUint32(this.bb_pos + t15) : 0;
  }
  position(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  positionLength() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  positionArray() {
    const t15 = this.bb.__offset(this.bb_pos, 6);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  normal(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  normalLength() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  normalArray() {
    const t15 = this.bb.__offset(this.bb_pos, 8);
    return t15 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  index(t15) {
    const e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t15) : 0;
  }
  indexLength() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  indexArray() {
    const t15 = this.bb.__offset(this.bb_pos, 10);
    return t15 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t15), this.bb.__vector_len(this.bb_pos + t15)) : null;
  }
  static startStreamedGeometry(t15) {
    t15.startObject(4);
  }
  static addGeometryId(t15, e2) {
    t15.addFieldInt32(0, e2, 0);
  }
  static addPosition(t15, e2) {
    t15.addFieldOffset(1, e2, 0);
  }
  static createPositionVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startPositionVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addNormal(t15, e2) {
    t15.addFieldOffset(2, e2, 0);
  }
  static createNormalVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addFloat32(e2[s]);
    return t15.endVector();
  }
  static startNormalVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static addIndex(t15, e2) {
    t15.addFieldOffset(3, e2, 0);
  }
  static createIndexVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addInt32(e2[s]);
    return t15.endVector();
  }
  static startIndexVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endStreamedGeometry(t15) {
    return t15.endObject();
  }
  static createStreamedGeometry(t15, e2, s, i, r) {
    return _Hc.startStreamedGeometry(t15), _Hc.addGeometryId(t15, e2), _Hc.addPosition(t15, s), _Hc.addNormal(t15, i), _Hc.addIndex(t15, r), _Hc.endStreamedGeometry(t15);
  }
};
var kc = class _kc {
  constructor() {
    e(this, "bb", null), e(this, "bb_pos", 0);
  }
  __init(t15, e2) {
    return this.bb_pos = t15, this.bb = e2, this;
  }
  static getRootAsStreamedGeometries(t15, e2) {
    return (e2 || new _kc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  static getSizePrefixedRootAsStreamedGeometries(t15, e2) {
    return t15.setPosition(t15.position() + 4), (e2 || new _kc()).__init(t15.readInt32(t15.position()) + t15.position(), t15);
  }
  geometries(t15, e2) {
    const s = this.bb.__offset(this.bb_pos, 4);
    return s ? (e2 || new Hc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s) + 4 * t15), this.bb) : null;
  }
  geometriesLength() {
    const t15 = this.bb.__offset(this.bb_pos, 4);
    return t15 ? this.bb.__vector_len(this.bb_pos + t15) : 0;
  }
  static startStreamedGeometries(t15) {
    t15.startObject(1);
  }
  static addGeometries(t15, e2) {
    t15.addFieldOffset(0, e2, 0);
  }
  static createGeometriesVector(t15, e2) {
    t15.startVector(4, e2.length, 4);
    for (let s = e2.length - 1; s >= 0; s--) t15.addOffset(e2[s]);
    return t15.endVector();
  }
  static startGeometriesVector(t15, e2) {
    t15.startVector(4, e2, 4);
  }
  static endStreamedGeometries(t15) {
    return t15.endObject();
  }
  static finishStreamedGeometriesBuffer(t15, e2) {
    t15.finish(e2);
  }
  static finishSizePrefixedStreamedGeometriesBuffer(t15, e2) {
    t15.finish(e2, void 0, true);
  }
  static createStreamedGeometries(t15, e2) {
    return _kc.startStreamedGeometries(t15), _kc.addGeometries(t15, e2), _kc.endStreamedGeometries(t15);
  }
};
var Wc = class {
  import(t15) {
    const e2 = new Y(t15), s = kc.getRootAsStreamedGeometries(e2), i = /* @__PURE__ */ new Map(), r = s.geometriesLength();
    for (let t16 = 0; t16 < r; t16++) {
      const e3 = s.geometries(t16);
      if (!e3) continue;
      const r2 = e3.geometryId();
      if (null === r2) throw new Error("Error finding ID!");
      const n = e3.positionArray(), o = e3.normalArray(), a = e3.indexArray();
      n && o && a && i.set(r2, { position: n, normal: o, index: a });
    }
    return i;
  }
  export(t15) {
    const e2 = new H(1024), s = [], i = kc, r = Hc;
    for (const [i2, { index: n2, position: o2, normal: a }] of t15) {
      const t16 = r.createIndexVector(e2, n2), c = r.createPositionVector(e2, o2), h = r.createNormalVector(e2, a);
      r.startStreamedGeometry(e2), r.addGeometryId(e2, i2), r.addIndex(e2, t16), r.addPosition(e2, c), r.addNormal(e2, h);
      const l = r.endStreamedGeometry(e2);
      s.push(l);
    }
    const n = i.createGeometriesVector(e2, s);
    i.startStreamedGeometries(e2), i.addGeometries(e2, n);
    const o = i.endStreamedGeometries(e2);
    return e2.finish(o), e2.asUint8Array();
  }
};
var jc = class {
  static combine(t15) {
    if (0 === t15.length) return {};
    if (1 === t15.length) return t15[0];
    const e2 = {};
    for (const s of t15) for (const t16 in s) {
      e2[t16] || (e2[t16] = /* @__PURE__ */ new Set());
      for (const i of s[t16]) e2[t16].add(i);
    }
    return e2;
  }
  static intersect(t15) {
    if (0 === t15.length) return {};
    if (1 === t15.length) return t15[0];
    const e2 = /* @__PURE__ */ new Map();
    let s = 0;
    for (const i2 of t15) {
      s++;
      for (const t16 in i2) {
        e2.has(t16) || e2.set(t16, { count: 0, ids: /* @__PURE__ */ new Map() });
        const s2 = e2.get(t16);
        s2.count++;
        for (const e3 of i2[t16]) {
          const t17 = s2.ids.get(e3) || 0;
          s2.ids.set(e3, t17 + 1);
        }
      }
    }
    const i = {};
    for (const [t16, { count: r, ids: n }] of e2) if (r === s) for (const [e3, r2] of n) r2 === s && (i[t16] || (i[t16] = /* @__PURE__ */ new Set()), i[t16].add(e3));
    return i;
  }
  static copy(t15) {
    const e2 = {};
    for (const s in t15) e2[s] = new Set(t15[s]);
    return e2;
  }
  static export(t15) {
    const e2 = {};
    for (const s in t15) e2[s] = Array.from(t15[s]);
    return e2;
  }
  static import(t15) {
    const e2 = {};
    for (const s in t15) e2[s] = new Set(t15[s]);
    return e2;
  }
};

// node_modules/@thatopen/components/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function makeEmptyBounds(target) {
  target[0] = target[1] = target[2] = Infinity;
  target[3] = target[4] = target[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}
function getBounds(triangleBounds, offset, count, target, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai2 = tri3 + 0;
    let bi2 = tri3 + 1;
    let ci2 = tri3 + 2;
    if (index) {
      ai2 = index[ai2];
      bi2 = index[bi2];
      ci2 = index[ci2];
    }
    if (!normalized) {
      ai2 = ai2 * stride + bufferOffset;
      bi2 = bi2 * stride + bufferOffset;
      ci2 = ci2 * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai2);
        b = posAttr[getters[el]](bi2);
        c = posAttr[getters[el]](ci2);
      } else {
        a = posArr[ai2 + el];
        b = posArr[bi2 + el];
        c = posArr[ci2 + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
var BIN_COUNT = 32;
var binsSort = (a, b) => a.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi2 = 0; bi2 < splitCount; bi2++) {
          const bin = truncatedBins[bi2];
          while (bi2 + 1 < splitCount && truncatedBins[bi2 + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi2 + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi2 = 0; bi2 < splitCount; bi2++) {
            const bin = truncatedBins[bi2];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi2 = 0; bi2 < splitCount; bi2++) {
          const bin = truncatedBins[bi2];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
var MeshBVHNode = class {
  constructor() {
  }
};
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t15 = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t15;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect : partition;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const roots = buildTree(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = p[field];
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = axis.dot(p);
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z2 + boxMax.z * (1 - z2);
          const val2 = axis.dot(p);
          min = Math.min(val2, min);
          max = Math.max(val2, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp12 = new Vector3();
  const temp22 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp12;
      const closestPoint2 = temp22;
      l1.closestPointToPoint(p2, true, temp12);
      l2.closestPointToPoint(p, true, temp22);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle3) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle3;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle3.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle3.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa2 = satAxes1[i];
        cachedSatBounds.setFromPoints(sa2, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa2 = satAxes2[i];
        cachedSatBounds.setFromPoints(sa2, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var OrientedBox = class {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z2;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z2 ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi2 = points[index];
      axis.subVectors(minVec, pi2);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle3) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle3.isExtendedTriangle) {
      saTri.copy(triangle3);
      saTri.update();
      triangle3 = saTri;
    } else if (triangle3.needsUpdate) {
      triangle3.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle3.a;
    pointsArr[1] = triangle3.b;
    pointsArr[2] = triangle3.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa2 = satAxes[i];
      cachedSatBounds.setFromPoints(sa2, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle3.satBounds;
    const triSatAxes = triangle3.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa2 = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa2, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z2 = 0; z2 <= 1; z2++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z2 ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box3());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}
var temp = new Vector3();
var temp1$2 = new Vector3();
function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1$2.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point)
    target.point = temp1$2.clone();
  else
    target.point.copy(temp1$2);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(ray2, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray2.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const intersection = checkIntersection(ray2, _vA, _vB, _vC, _intersectionPoint, side);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}
function setTriangle(tri, i, index, pos) {
  const ta2 = tri.a;
  const tb = tri.b;
  const tc2 = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta2.x = pos.getX(i0);
  ta2.y = pos.getY(i0);
  ta2.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc2.x = pos.getX(i2);
  tc2.y = pos.getY(i2);
  tc2.z = pos.getZ(i2);
}
function intersectTris(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray2, i, intersections);
  }
}
function intersectClosestTri(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z2 = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z2 < minz)
          minz = z2;
        if (z2 > maxz)
          maxz = z2;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boundingBox = new Box3();
function intersectRay(nodeIndex32, array, ray2, target) {
  arrayToBox(nodeIndex32, array, _boundingBox);
  return ray2.intersectBox(_boundingBox, target);
}
function intersectTris_indirect(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi2 = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray2, vi2, intersections);
  }
}
function intersectClosestTri_indirect(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, _indirectBuffer ? _indirectBuffer[i] : i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
var _boxIntersection$3 = new Vector3();
function raycast(bvh, root, side, ray2, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast$1(0, bvh, side, ray2, intersects2);
  BufferStack.clearBuffer();
}
function _raycast$1(nodeIndex32, bvh, side, ray2, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(bvh, side, ray2, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection$3)) {
      _raycast$1(leftIndex, bvh, side, ray2, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection$3)) {
      _raycast$1(rightIndex, bvh, side, ray2, intersects2);
    }
  }
}
var _boxIntersection$2 = new Vector3();
var _xyzFields$1 = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst$1(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst$1(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields$1[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection$2);
    const c1Result = c1Intersection ? _raycastFirst$1(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection$2);
    const c2Result = c2Intersection ? _raycastFirst$1(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox$1 = new Box3();
var triangle$1 = new ExtendedTriangle();
var triangle2$1 = new ExtendedTriangle();
var invertedMat$1 = new Matrix4();
var obb$4 = new OrientedBox();
var obb2$3 = new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry$1(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry$1(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat$1.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$3);
      obb2$3.matrix.copy(invertedMat$1);
      obb2$3.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$3.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2$1, i, thisIndex, thisPos);
            triangle2$1.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2$1)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle$1, i, thisIndex, thisPos);
        triangle$1.a.applyMatrix4(invertedMat$1);
        triangle$1.b.applyMatrix4(invertedMat$1);
        triangle$1.c.applyMatrix4(invertedMat$1);
        triangle$1.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2$1, i2, index, pos);
          triangle2$1.needsUpdate = true;
          if (triangle$1.intersectsTriangle(triangle2$1)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox$1);
    const leftIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox$1);
    const rightIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix$1 = new Matrix4();
var obb$3 = new OrientedBox();
var obb2$2 = new OrientedBox();
var temp1$1 = new Vector3();
var temp2$1 = new Vector3();
var temp3$1 = new Vector3();
var temp4$1 = new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1$1;
  let tempTargetDest1 = temp2$1;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3$1;
    tempTargetDest2 = temp4$1;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix$1.copy(geometryToBvh).invert();
  obb2$2.matrix.copy(tempMatrix$1);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2$2.min.copy(box.min);
            obb2$2.max.copy(box.max);
            obb2$2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2$2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle3, 3 * i, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle3, 3 * i, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix$1);
    tempTargetDest1.applyMatrix4(tempMatrix$1);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t15 = 3 * bvh.resolveTriangleIndex(i);
        for (let j2 = 0; j2 < 3; j2++) {
          let index = t15 + j2;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z2 = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z2 < minz)
            minz = z2;
          if (z2 > maxz)
            maxz = z2;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boxIntersection$1 = new Vector3();
function raycast_indirect(bvh, root, side, ray2, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray2, intersects2);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray2, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris_indirect(bvh, side, ray2, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection$1)) {
      _raycast(leftIndex, bvh, side, ray2, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection$1)) {
      _raycast(rightIndex, bvh, side, ray2, intersects2);
    }
  }
}
var _boxIntersection = new Vector3();
var _xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox = new Box3();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix4();
var obb$2 = new OrientedBox();
var obb2$1 = new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$2.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$2;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$1);
      obb2$1.matrix.copy(invertedMat);
      obb2$1.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$1.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti2 = bvh.resolveTriangleIndex(i);
        setTriangle(triangle, 3 * ti2, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix = new Matrix4();
var obb$1 = new OrientedBox();
var obb2 = new OrientedBox();
var temp1 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$1.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$1.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb2.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$1.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2.min.copy(box.min);
            obb2.max.copy(box.max);
            obb2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle22, 3 * ti2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti3 = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle3, 3 * ti3, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti2 = bvh.resolveTriangleIndex(i);
              setTriangle(triangle3, 3 * ti2, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box3());
var _leftBox1 = new Box3();
var _rightBox1 = new Box3();
var _leftBox2 = new Box3();
var _rightBox2 = new Box3();
var _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j2 = 0, jl = otherRoots.length; j2 < jl; j2++) {
      _bufferStack2.setBuffer(otherRoots[i]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j2].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}
var obb = new OrientedBox();
var tempBox = new Box3();
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i) => _indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects2 = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects2.length;
      raycastFunc(this, i, materialSide, ray2, intersects2);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j2 = startCount, jl = intersects2.length; j2 < jl; j2++) {
          intersects2[j2].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects2;
  }
  raycastFirst(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray2);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle3 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle3);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti2 = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti2 * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle22 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle22, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle22, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle22.a.applyMatrix4(matrixToLocal);
          triangle22.b.applyMatrix4(matrixToLocal);
          triangle22.c.applyMatrix4(matrixToLocal);
          triangle22.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle22, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb.intersectsBox(box2),
        intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
};
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}
var ray = new Ray();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
function acceleratedRaycast(raycaster, intersects2) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects2.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects2.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects2);
  }
}
function computeBoundsTree(options) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
var Event = class {
  constructor() {
    __publicField(this, "enabled", true);
    __publicField(this, "trigger", (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        handler(data);
      }
    });
    __publicField(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var AsyncEvent = class {
  constructor() {
    __publicField(this, "enabled", true);
    __publicField(this, "trigger", async (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        await handler(data);
      }
    });
    __publicField(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Base = class {
  constructor(components) {
    __publicField(this, "isDisposeable", () => {
      return "dispose" in this && "onDisposed" in this;
    });
    __publicField(this, "isResizeable", () => {
      return "resize" in this && "getSize" in this;
    });
    __publicField(this, "isUpdateable", () => {
      return "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this;
    });
    __publicField(this, "isHideable", () => {
      return "visible" in this;
    });
    __publicField(this, "isConfigurable", () => {
      return "setup" in this && "config" in this && "onSetup" in this;
    });
    this.components = components;
  }
};
var Component = class extends Base {
};
var BaseWorldItem = class extends Base {
  constructor(components) {
    super(components);
    __publicField(this, "worlds", /* @__PURE__ */ new Map());
    __publicField(this, "onWorldChanged", new Event());
    __publicField(this, "currentWorld", null);
    this.onWorldChanged.add(({ world, action }) => {
      if (action === "removed") {
        this.worlds.delete(world.uuid);
      }
    });
  }
};
var BaseCamera = class extends BaseWorldItem {
  constructor() {
    super(...arguments);
    __publicField(this, "hasCameraControls", () => {
      return "controls" in this;
    });
  }
};
var BaseRenderer = class extends BaseWorldItem {
  constructor() {
    super(...arguments);
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onResize", new Event());
    __publicField(this, "onClippingPlanesUpdated", new Event());
    __publicField(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(active, plane, isLocal) {
    plane.isLocal = isLocal;
    const index = this.clippingPlanes.indexOf(plane);
    if (active && index === -1) {
      this.clippingPlanes.push(plane);
    } else if (!active && index > -1) {
      this.clippingPlanes.splice(index, 1);
    }
    this.three.clippingPlanes = this.clippingPlanes.filter(
      (plane2) => !plane2.isLocal
    );
  }
};
var _Disposer = class _Disposer2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "_disposedComponents", /* @__PURE__ */ new Set());
    __publicField(this, "enabled", true);
    components.add(_Disposer2.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(object, materials = true, recursive = true) {
    object.removeFromParent();
    const item = object;
    if (item.dispose) {
      item.dispose();
    }
    this.disposeGeometryAndMaterials(object, materials);
    if (recursive && item.children && item.children.length) {
      this.disposeChildren(item);
    }
    object.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(geometry) {
    if (geometry.boundsTree && geometry.disposeBoundsTree) {
      geometry.disposeBoundsTree();
    }
    geometry.dispose();
  }
  disposeGeometryAndMaterials(mesh, materials) {
    const item = mesh;
    if (item.geometry) {
      this.disposeGeometry(item.geometry);
    }
    if (materials && item.material) {
      _Disposer2.disposeMaterial(item);
    }
    item.material = [];
    item.geometry = null;
  }
  disposeChildren(mesh) {
    for (const child of mesh.children) {
      this.destroy(child);
    }
  }
  static disposeMaterial(mesh) {
    if (mesh.material) {
      if (Array.isArray(mesh.material)) {
        for (const mat of mesh.material) {
          mat.dispose();
        }
      } else {
        mesh.material.dispose();
      }
    }
  }
};
__publicField(_Disposer, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var Disposer = _Disposer;
var BaseScene = class extends BaseWorldItem {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "directionalLights", /* @__PURE__ */ new Map());
    __publicField(this, "ambientLights", /* @__PURE__ */ new Map());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const disposer = this.components.get(Disposer);
    for (const child of this.three.children) {
      const mesh = child;
      if (mesh.geometry) {
        disposer.destroy(mesh);
      }
    }
    this.deleteAllLights();
    this.three.children = [];
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  deleteAllLights() {
    for (const [, light] of this.directionalLights) {
      light.removeFromParent();
      light.target.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    for (const [, light] of this.ambientLights) {
      light.removeFromParent();
      light.dispose();
    }
    this.ambientLights.clear();
  }
};
var DataSet = class extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(iterable) {
    super(iterable);
    __publicField(this, "onItemAdded", new Event());
    __publicField(this, "onItemDeleted", new Event());
    __publicField(this, "onCleared", new Event());
    __publicField(this, "guard", () => true);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...value) {
    for (const item of value) {
      const existing = this.has(item);
      if (existing)
        continue;
      const isValid = this.guard(item);
      if (!isValid)
        continue;
      super.add(item);
      if (!this.onItemAdded)
        this.onItemAdded = new Event();
      this.onItemAdded.trigger(item);
    }
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(value) {
    const deleted = super.delete(value);
    if (deleted)
      this.onItemDeleted.trigger();
    return deleted;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear();
    this.onItemAdded.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
};
var DataMap = class extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(iterable) {
    super(iterable);
    __publicField(this, "onItemSet", new Event());
    __publicField(this, "onItemUpdated", new Event());
    __publicField(this, "onItemDeleted", new Event());
    __publicField(this, "onCleared", new Event());
    __publicField(this, "guard", () => true);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(key, value) {
    const triggerUpdate = this.has(key);
    const guard = this.guard ?? (() => true);
    const isValid = guard(key, value);
    if (!isValid)
      return this;
    const result = super.set(key, value);
    if (triggerUpdate) {
      if (!this.onItemUpdated) {
        this.onItemUpdated = new Event();
      }
      this.onItemUpdated.trigger({ key, value });
    } else {
      if (!this.onItemSet) {
        this.onItemSet = new Event();
      }
      this.onItemSet.trigger({ key, value });
    }
    return result;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(key) {
    const deleted = super.delete(key);
    if (deleted)
      this.onItemDeleted.trigger(key);
    return deleted;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear();
    this.onItemSet.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
};
var ComponentWithUI = class extends Component {
};
var ControlsUtils = class {
  static isEntry(item) {
    const types = /* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ]);
    return types.has(item.type);
  }
  static copySchema(schema, copy = {}) {
    for (const name in schema) {
      const entry = schema[name];
      if (this.isEntry(entry)) {
        copy[name] = this.copyEntry(entry);
      } else {
        copy[name] = {};
        this.copySchema(entry, copy[name]);
      }
    }
    return copy;
  }
  static copyEntry(controlEntry) {
    if (controlEntry.type === "Boolean") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Color") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "Text") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Number") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        min: entry.min,
        max: entry.max,
        interpolable: entry.interpolable
      };
    }
    if (controlEntry.type === "Select") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        multiple: entry.multiple,
        options: new Set(entry.options)
      };
    }
    if (controlEntry.type === "Vector3") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "TextSet") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: new Set(entry.value)
      };
    }
    if (controlEntry.type === "None") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    throw new Error("Invalid entry!");
  }
};
var EventManager = class {
  constructor() {
    __publicField(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(events) {
    for (const event of events) {
      this.list.add(event);
    }
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(events) {
    for (const event of events) {
      this.list.delete(event);
    }
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(active) {
    for (const event of this.list) {
      event.enabled = active;
    }
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const event of this.list) {
      event.reset();
    }
  }
};
var Visible = 0;
var Deleted = 1;
var _v1$1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  /**
   * Constructs a new convex hull.
   */
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  /**
   * Computes to convex hull for the given array of points.
   *
   * @param {Array<Vector3>} points - The array of points in 3D space.
   * @return {ConvexHull} A reference to this convex hull.
   */
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }
      this._compute();
    }
    return this;
  }
  /**
   * Computes the convex hull of the given 3D object (including its descendants),
   * accounting for the world transforms of both the 3D object and its descendants.
   *
   * @param {Object3D} object - The 3D object to compute the convex hull for.
   * @return {ConvexHull} A reference to this convex hull.
   */
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        const attribute = geometry.attributes.position;
        if (attribute !== void 0) {
          for (let i = 0, l = attribute.count; i < l; i++) {
            const point = new Vector3();
            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
            points.push(point);
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  /**
   * Returns `true` if the given point lies in the convex hull.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the given point lies in the convex hull or not.
   */
  containsPoint(point) {
    const faces = this.faces;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  /**
   * Computes the intersections point of the given ray and this convex hull.
   *
   * @param {Ray} ray - The ray to test.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.
   */
  intersectRay(ray2, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      const vN = face.distanceToPoint(ray2.origin);
      const vD = face.normal.dot(ray2.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t15 = vD !== 0 ? -vN / vD : 0;
      if (t15 <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t15, tFar);
      } else {
        tNear = Math.max(t15, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray2.at(tNear, target);
    } else {
      ray2.at(tFar, target);
    }
    return target;
  }
  /**
   * Returns `true` if the given ray intersects with this convex hull.
   *
   * @param {Ray} ray - The ray to test.
   * @return {boolean} Whether the given ray intersects with this convex hull or not.
   */
  intersectsRay(ray2) {
    return this.intersectRay(ray2, _v1$1) !== null;
  }
  /**
   * Makes the convex hull empty.
   *
   * @return {ConvexHull} A reference to this convex hull.
   */
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  // private
  /**
   * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to add.
   * @param {Face} face - The target face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  /**
   * Removes a vertex from the 'assigned' list of vertices and from the given face.
   * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'
   * is linked correctly after the removal.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to remove.
   * @param {Face} face - The target face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  /**
   * Removes all the visible vertices that a given face is able to see which are stored in
   * the 'assigned' vertex list.
   *
   * @private
   * @param {Face} face - The target face.
   * @return {VertexNode|undefined} A reference to this convex hull.
   */
  _removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  /**
   * Removes all the visible vertices that `face` is able to see.
   *
   * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.
   * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.
   * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.
   *
   * @private
   * @param {Face} face - The given face.
   * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this._removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance = absorbingFace.distanceToPoint(vertex.point);
          if (distance > this.tolerance) {
            this._addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  /**
   * Reassigns as many vertices as possible from the unassigned list to the new faces.
   *
   * @private
   * @param {Array<Face>} newFaces - The new faces.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i = 0; i < newFaces.length; i++) {
          const face = newFaces[i];
          if (face.mark === Visible) {
            const distance = face.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this._addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  /**
   * Computes the extremes values (min/max vectors) which will be used to
   * compute the initial hull.
   *
   * @private
   * @return {Object} The extremes.
   */
  _computeExtremes() {
    const min = new Vector3();
    const max = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i = 0; i < 3; i++) {
      minVertices[i] = maxVertices[i] = this.vertices[0];
    }
    min.copy(this.vertices[0].point);
    max.copy(this.vertices[0].point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = this.vertices[i];
      const point = vertex.point;
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) < min.getComponent(j2)) {
          min.setComponent(j2, point.getComponent(j2));
          minVertices[j2] = vertex;
        }
      }
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) > max.getComponent(j2)) {
          max.setComponent(j2, point.getComponent(j2));
          maxVertices[j2] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
    return { min: minVertices, max: maxVertices };
  }
  /**
   * Computes the initial simplex assigning to its faces all the points that are
   * candidates to form part of the hull.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this._computeExtremes();
    const min = extremes.min;
    const max = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i = 0; i < 3; i++) {
      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
      if (distance > maxDistance) {
        maxDistance = distance;
        index = i;
      }
    }
    const v0 = min[index];
    const v1 = max[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v1.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance = _closestPoint.distanceToSquared(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
        const distance = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance > maxDistance) {
          maxDistance = distance;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(
        Face.create(v0, v1, v2),
        Face.create(v3, v1, v0),
        Face.create(v3, v2, v1),
        Face.create(v3, v0, v2)
      );
      for (let i = 0; i < 3; i++) {
        const j2 = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j2));
        faces[i + 1].getEdge(1).setTwin(faces[j2 + 1].getEdge(0));
      }
    } else {
      faces.push(
        Face.create(v0, v2, v1),
        Face.create(v3, v0, v1),
        Face.create(v3, v1, v2),
        Face.create(v3, v2, v0)
      );
      for (let i = 0; i < 3; i++) {
        const j2 = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
        faces[i + 1].getEdge(0).setTwin(faces[j2 + 1].getEdge(1));
      }
    }
    for (let i = 0; i < 4; i++) {
      this.faces.push(faces[i]);
    }
    for (let i = 0, l = vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j2 = 0; j2 < 4; j2++) {
          const distance = this.faces[j2].distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            maxFace = this.faces[j2];
          }
        }
        if (maxFace !== null) {
          this._addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  /**
   * Removes inactive (e.g. deleted) faces from the internal face list.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _reindexFaces() {
    const activeFaces = [];
    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  /**
   * Finds the next vertex to create faces with the current hull.
   *
   * - Let the initial face be the first face existing in the 'assigned' vertex list.
   * - If a face doesn't exist then return since there're no vertices left.
   * - Otherwise for each vertex that face sees find the one furthest away from it.
   *
   * @private
   * @return {?VertexNode} The next vertex to add.
   */
  _nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance = eyeFace.distanceToPoint(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  /**
   * Computes a chain of half edges in CCW order called the 'horizon'. For an edge
   * to be part of the horizon it must join a face that can see 'eyePoint' and a face
   * that cannot see 'eyePoint'.
   *
   * @private
   * @param {Vector3} eyePoint - The 3D-coordinates of a point.
   * @param {HalfEdge} crossEdge - The edge used to jump to the current face.
   * @param {Face} face - The current face being tested.
   * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _computeHorizon(eyePoint, crossEdge, face, horizon) {
    this._deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this._computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  /**
   * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'
   * in CCW order. All the half edges are created in CCW order thus the face is always pointing
   * outside the hull.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.
   * @param {HalfEdge} horizonEdge - A single edge of the horizon.
   * @return {HalfEdge} The half edge whose vertex is the eyeVertex.
   */
  _addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  /**
   * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon
   * opposite face and the face on the left/right.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.
   * @param {Array<HalfEdge>} horizon - The horizon.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i = 0; i < horizon.length; i++) {
      const horizonEdge = horizon[i];
      const sideEdge = this._addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  /**
   * Adds a vertex to the hull with the following algorithm:
   *
   * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group
   * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.
   * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.
   * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected
   * with the opposite horizon face and the face on the left/right.
   * - The vertices removed from all the visible faces are assigned to the new faces if possible.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex to add.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this._removeVertexFromFace(eyeVertex, eyeVertex.face);
    this._computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this._addNewFaces(eyeVertex, horizon);
    this._resolveUnassignedPoints(this.newFaces);
    return this;
  }
  /**
   * Cleans up internal properties after computing the convex hull.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  /**
   * Starts the execution of the quick hull algorithm.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _compute() {
    let vertex;
    this._computeInitialHull();
    while ((vertex = this._nextVertexToAdd()) !== void 0) {
      this._addVertexToHull(vertex);
    }
    this._reindexFaces();
    this._cleanup();
    return this;
  }
};
var Face = class _Face {
  /**
   * Constructs a new face.
   */
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  /**
   * Creates a face from the given vertex nodes.
   *
   * @private
   * @param {VertexNode} a - The first vertex node.
   * @param {VertexNode} b - The second vertex node.
   * @param {VertexNode} c - The third vertex node.
   * @return {Face} The created face.
   */
  static create(a, b, c) {
    const face = new _Face();
    const e0 = new HalfEdge(a, face);
    const e1 = new HalfEdge(b, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  /**
   * Returns an edge by the given index.
   *
   * @private
   * @param {number} i - The edge index.
   * @return {HalfEdge} The edge.
   */
  getEdge(i) {
    let edge = this.edge;
    while (i > 0) {
      edge = edge.next;
      i--;
    }
    while (i < 0) {
      edge = edge.prev;
      i++;
    }
    return edge;
  }
  /**
   * Computes all properties of the face.
   *
   * @private
   * @return {Face} A reference to this face.
   */
  compute() {
    const a = this.edge.tail();
    const b = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a.point, b.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  /**
   * Returns the signed distance from a given point to the plane representation of this face.
   *
   * @private
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  /**
   * Constructs a new half edge.
   *
   * @param {VertexNode} vertex - A reference to its destination vertex.
   * @param {Face} face - A reference to its face.
   */
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  /**
   * Returns the destination vertex.
   *
   * @private
   * @return {VertexNode} The destination vertex.
   */
  head() {
    return this.vertex;
  }
  /**
   * Returns the origin vertex.
   *
   * @private
   * @return {VertexNode} The destination vertex.
   */
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  /**
   * Returns the Euclidean length (straight-line length) of the edge.
   *
   * @private
   * @return {number} The edge's length.
   */
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  /**
   * Returns the square of the Euclidean length (straight-line length) of the edge.
   *
   * @private
   * @return {number} The square of the edge's length.
   */
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  /**
   * Sets the twin edge of this half-edge. It also ensures that the twin reference
   * of the given half-edge is correctly set.
   *
   * @private
   * @param {HalfEdge} edge - The twin edge to set.
   * @return {HalfEdge} A reference to this edge.
   */
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  /**
   * Constructs a new vertex node.
   *
   * @param {Vector3} point - A point in 3D space.
   */
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  /**
   * Constructs a new vertex list.
   */
  constructor() {
    this.head = null;
    this.tail = null;
  }
  /**
   * Returns the head reference.
   *
   * @private
   * @return {VertexNode} The head reference.
   */
  first() {
    return this.head;
  }
  /**
   * Returns the tail reference.
   *
   * @private
   * @return {VertexNode} The tail reference.
   */
  last() {
    return this.tail;
  }
  /**
   * Clears the linked list.
   *
   * @private
   * @return {VertexList} A reference to this vertex list.
   */
  clear() {
    this.head = this.tail = null;
    return this;
  }
  /**
   * Inserts a vertex before a target vertex.
   *
   * @private
   * @param {VertexNode} target - The target.
   * @param {VertexNode} vertex - The vertex to insert.
   * @return {VertexList} A reference to this vertex list.
   */
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  /**
   * Inserts a vertex after a target vertex.
   *
   * @private
   * @param {VertexNode} target - The target.
   * @param {VertexNode} vertex - The vertex to insert.
   * @return {VertexList} A reference to this vertex list.
   */
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  /**
   * Appends a vertex to this vertex list.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to append.
   * @return {VertexList} A reference to this vertex list.
   */
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  /**
   * Appends a chain of vertices where the given vertex is the head.
   *
   * @private
   * @param {VertexNode} vertex - The head vertex of a chain of vertices.
   * @return {VertexList} A reference to this vertex list.
   */
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  /**
   * Removes a vertex from the linked list.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to remove.
   * @return {VertexList} A reference to this vertex list.
   */
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  /**
   * Removes a sublist of vertices from the linked list.
   *
   * @private
   * @param {VertexNode} a - The head of the sublist.
   * @param {VertexNode} b - The tail of the sublist.
   * @return {VertexList} A reference to this vertex list.
   */
  removeSubList(a, b) {
    if (a.prev === null) {
      this.head = b.next;
    } else {
      a.prev.next = b.next;
    }
    if (b.next === null) {
      this.tail = a.prev;
    } else {
      b.next.prev = a.prev;
    }
    return this;
  }
  /**
   * Returns `true` if the linked list is empty.
   *
   * @private
   * @return {boolean} Whether the linked list is empty or not.
   */
  isEmpty() {
    return this.head === null;
  }
};
var colVal = [2, 2, 1];
var rowVal = [1, 0, 0];
function getElementIndex(column, row) {
  return column * 3 + row;
}
function frobeniusNorm(matrix) {
  const e2 = matrix.elements;
  let norm = 0;
  for (let i = 0; i < 9; i++) {
    norm += e2[i] * e2[i];
  }
  return Math.sqrt(norm);
}
function offDiagonalFrobeniusNorm(source) {
  const e2 = source.elements;
  let norm = 0;
  for (let i = 0; i < 3; i++) {
    const t15 = e2[getElementIndex(colVal[i], rowVal[i])];
    norm += 2 * t15 * t15;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(source, result) {
  let maxDiagonal = 0;
  let rotAxis = 1;
  const e2 = source.elements;
  for (let i = 0; i < 3; i++) {
    const t15 = Math.abs(e2[getElementIndex(colVal[i], rowVal[i])]);
    if (t15 > maxDiagonal) {
      maxDiagonal = t15;
      rotAxis = i;
    }
  }
  let c = 1;
  let s = 0;
  const p = rowVal[rotAxis];
  const q = colVal[rotAxis];
  if (Math.abs(e2[getElementIndex(q, p)]) > Number.EPSILON) {
    const qq = e2[getElementIndex(q, q)];
    const pp = e2[getElementIndex(p, p)];
    const qp = e2[getElementIndex(q, p)];
    const tau = (qq - pp) / 2 / qp;
    let t15;
    if (tau < 0) {
      t15 = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t15 = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c = 1 / Math.sqrt(1 + t15 * t15);
    s = t15 * c;
  }
  result.identity();
  result.elements[getElementIndex(p, p)] = c;
  result.elements[getElementIndex(q, q)] = c;
  result.elements[getElementIndex(q, p)] = s;
  result.elements[getElementIndex(p, q)] = -s;
  return result;
}
function eigenDecomposition(source, result) {
  let count = 0;
  let sweep = 0;
  const maxSweeps = 10;
  result.unitary.identity();
  result.diagonal.copy(source);
  const unitaryMatrix = result.unitary;
  const diagonalMatrix = result.diagonal;
  const m1 = new Matrix3();
  const m2 = new Matrix3();
  const epsilon = Number.EPSILON * frobeniusNorm(diagonalMatrix);
  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, m1);
    m2.copy(m1).transpose();
    diagonalMatrix.multiply(m1);
    diagonalMatrix.premultiply(m2);
    unitaryMatrix.multiply(m1);
    if (++count > 2) {
      sweep++;
      count = 0;
    }
  }
  return result;
}
function obbFromPoints(vertices) {
  const points = [];
  for (let i = 0; i < vertices.length - 2; i += 3) {
    const x2 = vertices[i];
    const y2 = vertices[i + 1];
    const z22 = vertices[i + 2];
    points.push(new Vector3(x2, y2, z22));
  }
  const convexHull = new ConvexHull();
  convexHull.setFromPoints(points);
  const eigenDecomposed = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  };
  const faces = convexHull.faces;
  const edges = [];
  const triangles = [];
  for (let i = 0, il = faces.length; i < il; i++) {
    const face = faces[i];
    let edge = face.edge;
    edges.length = 0;
    do {
      edges.push(edge);
      edge = edge.next;
    } while (edge !== face.edge);
    const triangleCount = edges.length - 2;
    for (let j2 = 1, jl = triangleCount; j2 <= jl; j2++) {
      const v12 = edges[0].vertex;
      const v22 = edges[j2 + 0].vertex;
      const v32 = edges[j2 + 1].vertex;
      triangles.push(v12.point.x, v12.point.y, v12.point.z);
      triangles.push(v22.point.x, v22.point.y, v22.point.z);
      triangles.push(v32.point.x, v32.point.y, v32.point.z);
    }
  }
  const p = new Vector3();
  const q = new Vector3();
  const r = new Vector3();
  const qp = new Vector3();
  const rp = new Vector3();
  const v = new Vector3();
  const mean = new Vector3();
  const weightedMean = new Vector3();
  let areaSum = 0;
  let cxx = 0;
  let cxy = 0;
  let cxz = 0;
  let cyy = 0;
  let cyz = 0;
  let czz = 0;
  for (let i = 0, l = triangles.length; i < l; i += 9) {
    p.fromArray(triangles, i);
    q.fromArray(triangles, i + 3);
    r.fromArray(triangles, i + 6);
    mean.set(0, 0, 0);
    mean.add(p).add(q).add(r).divideScalar(3);
    qp.subVectors(q, p);
    rp.subVectors(r, p);
    const area2 = v.crossVectors(qp, rp).length() / 2;
    weightedMean.add(v.copy(mean).multiplyScalar(area2));
    areaSum += area2;
    cxx += (9 * mean.x * mean.x + p.x * p.x + q.x * q.x + r.x * r.x) * (area2 / 12);
    cxy += (9 * mean.x * mean.y + p.x * p.y + q.x * q.y + r.x * r.y) * (area2 / 12);
    cxz += (9 * mean.x * mean.z + p.x * p.z + q.x * q.z + r.x * r.z) * (area2 / 12);
    cyy += (9 * mean.y * mean.y + p.y * p.y + q.y * q.y + r.y * r.y) * (area2 / 12);
    cyz += (9 * mean.y * mean.z + p.y * p.z + q.y * q.z + r.y * r.z) * (area2 / 12);
    czz += (9 * mean.z * mean.z + p.z * p.z + q.z * q.z + r.z * r.z) * (area2 / 12);
  }
  weightedMean.divideScalar(areaSum);
  cxx /= areaSum;
  cxy /= areaSum;
  cxz /= areaSum;
  cyy /= areaSum;
  cyz /= areaSum;
  czz /= areaSum;
  cxx -= weightedMean.x * weightedMean.x;
  cxy -= weightedMean.x * weightedMean.y;
  cxz -= weightedMean.x * weightedMean.z;
  cyy -= weightedMean.y * weightedMean.y;
  cyz -= weightedMean.y * weightedMean.z;
  czz -= weightedMean.z * weightedMean.z;
  const covarianceMatrix = new Matrix3();
  covarianceMatrix.elements[0] = cxx;
  covarianceMatrix.elements[1] = cxy;
  covarianceMatrix.elements[2] = cxz;
  covarianceMatrix.elements[3] = cxy;
  covarianceMatrix.elements[4] = cyy;
  covarianceMatrix.elements[5] = cyz;
  covarianceMatrix.elements[6] = cxz;
  covarianceMatrix.elements[7] = cyz;
  covarianceMatrix.elements[8] = czz;
  eigenDecomposition(covarianceMatrix, eigenDecomposed);
  const unitary = eigenDecomposed.unitary;
  const v1 = new Vector3();
  const v2 = new Vector3();
  const v3 = new Vector3();
  unitary.extractBasis(v1, v2, v3);
  let u1 = -Infinity;
  let u2 = -Infinity;
  let u3 = -Infinity;
  let l1 = Infinity;
  let l2 = Infinity;
  let l3 = Infinity;
  for (let i = 0, l = points.length; i < l; i++) {
    const p2 = points[i];
    u1 = Math.max(v1.dot(p2), u1);
    u2 = Math.max(v2.dot(p2), u2);
    u3 = Math.max(v3.dot(p2), u3);
    l1 = Math.min(v1.dot(p2), l1);
    l2 = Math.min(v2.dot(p2), l2);
    l3 = Math.min(v3.dot(p2), l3);
  }
  v1.multiplyScalar(0.5 * (l1 + u1));
  v2.multiplyScalar(0.5 * (l2 + u2));
  v3.multiplyScalar(0.5 * (l3 + u3));
  const center = new Vector3();
  const halfSizes = new Vector3();
  const rotation = new Matrix3();
  center.add(v1).add(v2).add(v3);
  halfSizes.x = u1 - l1;
  halfSizes.y = u2 - l2;
  halfSizes.z = u3 - l3;
  halfSizes.multiplyScalar(0.5);
  rotation.copy(unitary);
  const { x, y, z: z2 } = halfSizes;
  const scale = new Matrix4();
  scale.makeScale(x * 2, y * 2, z2 * 2);
  const offset = new Matrix4();
  offset.makeTranslation(-x, -y, -z2);
  const translation = new Matrix4();
  translation.makeTranslation(center.x, center.y, center.z);
  const rot = new Matrix4();
  rot.setFromMatrix3(rotation);
  const transformation = new Matrix4();
  transformation.multiply(translation);
  transformation.multiply(rot);
  transformation.multiply(offset);
  transformation.multiply(scale);
  return { center, halfSizes, rotation, transformation };
}
function isPointInFrontOfPlane(point, planePoint, planeNormal) {
  const vectorToPlane = [
    point[0] - planePoint[0],
    point[1] - planePoint[1],
    point[2] - planePoint[2]
  ];
  const dotProduct = planeNormal[0] * vectorToPlane[0] + planeNormal[1] * vectorToPlane[1] + planeNormal[2] * vectorToPlane[2];
  return dotProduct > 0;
}
var MaterialsUtils = class {
  static isTransparent(material) {
    return material.transparent && material.opacity < 1;
  }
};
var _UUID = class _UUID2 {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = `${_UUID2._lut[d0 & 255] + _UUID2._lut[d0 >> 8 & 255] + _UUID2._lut[d0 >> 16 & 255] + _UUID2._lut[d0 >> 24 & 255]}-${_UUID2._lut[d1 & 255]}${_UUID2._lut[d1 >> 8 & 255]}-${_UUID2._lut[d1 >> 16 & 15 | 64]}${_UUID2._lut[d1 >> 24 & 255]}-${_UUID2._lut[d2 & 63 | 128]}${_UUID2._lut[d2 >> 8 & 255]}-${_UUID2._lut[d2 >> 16 & 255]}${_UUID2._lut[d2 >> 24 & 255]}${_UUID2._lut[d3 & 255]}${_UUID2._lut[d3 >> 8 & 255]}${_UUID2._lut[d3 >> 16 & 255]}${_UUID2._lut[d3 >> 24 & 255]}`;
    return uuid.toLowerCase();
  }
  static validate(uuid) {
    if (!_UUID2._pattern.test(uuid))
      throw new Error(
        `${uuid} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
__publicField(_UUID, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
__publicField(_UUID, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var UUID = _UUID;
var VertexPicker = class extends Component {
  constructor(components, config) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onVertexFound", new Event());
    __publicField(this, "onVertexLost", new Event());
    __publicField(this, "onEnabled", new Event());
    __publicField(this, "components");
    __publicField(this, "workingPlane", null);
    __publicField(this, "_pickedPoint", null);
    __publicField(this, "_config");
    __publicField(this, "_enabled", false);
    this.components = components;
    this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...config
    };
    this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(value) {
    this._enabled = value;
    if (!value) {
      this._pickedPoint = null;
    }
    this.onEnabled.trigger(value);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset();
    this.onVertexLost.reset();
    this.components = null;
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(world) {
    if (!this.enabled)
      return this._pickedPoint;
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects2 = caster.castRay();
    if (!intersects2) {
      if (this._pickedPoint !== null) {
        this.onVertexLost.trigger();
        this._pickedPoint = null;
      }
      return this._pickedPoint;
    }
    const point = this.getClosestVertex(intersects2);
    if (!point) {
      if (this._pickedPoint !== null) {
        this.onVertexLost.trigger();
        this._pickedPoint = null;
      }
      return this._pickedPoint;
    }
    const isOnPlane = !this.workingPlane ? true : Math.abs(this.workingPlane.distanceToPoint(point)) < 1e-3;
    if (!isOnPlane) {
      this._pickedPoint = null;
      return this._pickedPoint;
    }
    if (this._pickedPoint === null || !this._pickedPoint.equals(point)) {
      this._pickedPoint = point.clone();
      this.onVertexFound.trigger(this._pickedPoint);
    }
    return this._pickedPoint;
  }
  getClosestVertex(intersects2) {
    let closestVertex = new Vector3();
    let vertexFound = false;
    let closestDistance = Number.MAX_SAFE_INTEGER;
    const vertices = this.getVertices(intersects2);
    if (vertices === null) {
      return null;
    }
    for (const vertex of vertices) {
      if (!vertex) {
        continue;
      }
      const distance = intersects2.point.distanceTo(vertex);
      if (distance > closestDistance || distance > this._config.snapDistance) {
        continue;
      }
      vertexFound = true;
      closestVertex = vertex;
      closestDistance = intersects2.point.distanceTo(vertex);
    }
    if (vertexFound) {
      return closestVertex;
    }
    return this.config.showOnlyVertex ? null : intersects2.point;
  }
  getVertices(intersects2) {
    const mesh = intersects2.object;
    if (!intersects2.face || !mesh)
      return null;
    const geom = mesh.geometry;
    const instanceTransform = new Matrix4();
    const { instanceId } = intersects2;
    const instanceFound = instanceId !== void 0;
    const isInstance = mesh instanceof InstancedMesh;
    if (isInstance && instanceFound) {
      mesh.getMatrixAt(instanceId, instanceTransform);
    }
    return [
      this.getVertex(intersects2.face.a, geom),
      this.getVertex(intersects2.face.b, geom),
      this.getVertex(intersects2.face.c, geom)
    ].map((vertex) => {
      if (vertex) {
        if (isInstance && instanceFound) {
          vertex.applyMatrix4(instanceTransform);
        }
        vertex.applyMatrix4(mesh.matrixWorld);
      }
      return vertex;
    });
  }
  getVertex(index, geom) {
    if (index === void 0)
      return null;
    const vertices = geom.attributes.position;
    return new Vector3(
      vertices.getX(index),
      vertices.getY(index),
      vertices.getZ(index)
    );
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  var p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an2 = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an2;
  an2.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j2 = end - dim; i < end; i += dim) {
    sum += (data[j2] - data[i]) * (data[i + 1] + data[j2 + 1]);
    j2 = i;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j2 = 0; j2 < data[i].length; j2++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j2][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
var earcut$1 = getDefaultExportFromCjs(earcutExports);
var SectionGenerator = class extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "enabled", true);
    __publicField(this, "_inverseMatrix", new Matrix4());
    __publicField(this, "_localPlane", new Plane());
    __publicField(this, "_tempLine", new Line3());
    __publicField(this, "_tempVector", new Vector3());
    __publicField(this, "_plane");
    __publicField(this, "_plane2DCoordinateSystem", new Matrix4());
    __publicField(this, "_precission", 1e4);
    __publicField(this, "_planeAxis");
  }
  get plane() {
    if (!this._plane) {
      throw new Error("Plane not set");
    }
    return this._plane;
  }
  set plane(plane) {
    this._plane = plane;
  }
  // This assumes that the mesh that contains the posAttr is aligned with the current plane
  createEdges(data) {
    const { meshes, posAttr } = data;
    let index = 0;
    posAttr.array.fill(0);
    const indexes = [];
    let lastIndex = 0;
    const tempMesh = new Mesh();
    for (const mesh of meshes) {
      if (!mesh.geometry) {
        continue;
      }
      if (!mesh.geometry.boundsTree) {
        mesh.geometry.computeBoundsTree();
      }
      if (!mesh.geometry.boundsTree) {
        throw new Error("Bounds tree not found for edges generation.");
      }
      if (mesh instanceof InstancedMesh) {
        if (mesh.count === 0) {
          continue;
        }
        const instanced = mesh;
        for (let i = 0; i < instanced.count; i++) {
          tempMesh.geometry = mesh.geometry;
          tempMesh.matrix.copy(mesh.matrix);
          const tempMatrix2 = new Matrix4();
          instanced.getMatrixAt(i, tempMatrix2);
          tempMesh.applyMatrix4(tempMatrix2);
          tempMesh.applyMatrix4(mesh.matrixWorld);
          tempMesh.updateMatrix();
          tempMesh.updateMatrixWorld();
          this._inverseMatrix.copy(tempMesh.matrixWorld).invert();
          this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix);
          index = this.shapecast(tempMesh, posAttr, index);
          if (index !== lastIndex) {
            indexes.push(index);
            lastIndex = index;
          }
        }
      } else {
        this._inverseMatrix.copy(mesh.matrixWorld).invert();
        this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix);
        index = this.shapecast(mesh, posAttr, index);
        if (index !== lastIndex) {
          indexes.push(index);
          lastIndex = index;
        }
      }
    }
    return { indexes, index };
  }
  createFills(buffer, trianglesIndices) {
    this.updatePlane2DCoordinateSystem();
    const allIndices = [];
    let currentTriangle = 0;
    for (let i = 0; i < trianglesIndices.length; i++) {
      const nextTriangle = trianglesIndices[i];
      const vertices = [];
      for (let j2 = currentTriangle; j2 < nextTriangle; j2 += 2) {
        vertices.push(j2 * 3);
      }
      const indices = this.computeFill(vertices, buffer);
      for (const index of indices) {
        allIndices.push(index);
      }
      currentTriangle = nextTriangle;
    }
    return allIndices;
  }
  computeFill(vertices, buffer) {
    const indices = /* @__PURE__ */ new Map();
    const all2DVertices = {};
    const shapes = /* @__PURE__ */ new Map();
    let nextShapeID = 0;
    const shapesEnds = /* @__PURE__ */ new Map();
    const shapesStarts = /* @__PURE__ */ new Map();
    const openShapes = /* @__PURE__ */ new Set();
    const p = this._precission;
    for (let i = 0; i < vertices.length; i++) {
      const startVertexIndex = vertices[i];
      let x1 = 0;
      let y1 = 0;
      let x2 = 0;
      let y2 = 0;
      const globalX1 = buffer[startVertexIndex];
      const globalY1 = buffer[startVertexIndex + 1];
      const globalZ1 = buffer[startVertexIndex + 2];
      const globalX2 = buffer[startVertexIndex + 3];
      const globalY2 = buffer[startVertexIndex + 4];
      const globalZ2 = buffer[startVertexIndex + 5];
      this._tempVector.set(globalX1, globalY1, globalZ1);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x1 = Math.trunc(this._tempVector.x * p) / p;
      y1 = Math.trunc(this._tempVector.y * p) / p;
      this._tempVector.set(globalX2, globalY2, globalZ2);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x2 = Math.trunc(this._tempVector.x * p) / p;
      y2 = Math.trunc(this._tempVector.y * p) / p;
      if (x1 === x2 && y1 === y2) {
        continue;
      }
      const startCode = `${x1}|${y1}`;
      const endCode = `${x2}|${y2}`;
      if (!indices.has(startCode)) {
        indices.set(startCode, startVertexIndex / 3);
      }
      if (!indices.has(endCode)) {
        indices.set(endCode, startVertexIndex / 3 + 1);
      }
      const start = indices.get(startCode);
      const end = indices.get(endCode);
      all2DVertices[start] = [x1, y1];
      all2DVertices[end] = [x2, y2];
      const startMatchesStart = shapesStarts.has(start);
      const startMatchesEnd = shapesEnds.has(start);
      const endMatchesStart = shapesStarts.has(end);
      const endMatchesEnd = shapesEnds.has(end);
      const noMatches = !startMatchesStart && !startMatchesEnd && !endMatchesStart && !endMatchesEnd;
      if (noMatches) {
        shapesStarts.set(start, nextShapeID);
        shapesEnds.set(end, nextShapeID);
        openShapes.add(nextShapeID);
        shapes.set(nextShapeID, [start, end]);
        nextShapeID++;
      } else if (startMatchesStart && endMatchesEnd) {
        const startIndex = shapesStarts.get(start);
        const endIndex = shapesEnds.get(end);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(start);
        shapesEnds.delete(end);
      } else if (startMatchesEnd && endMatchesStart) {
        const startIndex = shapesStarts.get(end);
        const endIndex = shapesEnds.get(start);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(end);
        shapesEnds.delete(start);
      } else if (startMatchesStart && endMatchesStart) {
        const startIndex1 = shapesStarts.get(end);
        const startIndex2 = shapesStarts.get(start);
        const startShape2 = shapes.get(startIndex2);
        const startShape1 = shapes.get(startIndex1);
        if (!startShape2 || !startShape1) {
          continue;
        }
        shapes.delete(startIndex1);
        openShapes.delete(startIndex1);
        shapesStarts.delete(startShape2[0]);
        shapesStarts.delete(startShape1[0]);
        shapesEnds.delete(startShape1[startShape1.length - 1]);
        shapesStarts.set(startShape1[startShape1.length - 1], startIndex2);
        startShape1.reverse();
        startShape2.splice(0, 0, ...startShape1);
      } else if (startMatchesEnd && endMatchesEnd) {
        const endIndex1 = shapesEnds.get(end);
        const endIndex2 = shapesEnds.get(start);
        const endShape2 = shapes.get(endIndex2);
        const endShape1 = shapes.get(endIndex1);
        if (!endShape2 || !endShape1) {
          continue;
        }
        shapes.delete(endIndex1);
        openShapes.delete(endIndex1);
        shapesEnds.delete(endShape2[endShape2.length - 1]);
        shapesEnds.delete(endShape1[endShape1.length - 1]);
        shapesStarts.delete(endShape1[0]);
        shapesEnds.set(endShape1[0], endIndex2);
        endShape1.reverse();
        endShape2.push(...endShape1);
      } else if (startMatchesStart) {
        const shapeIndex = shapesStarts.get(start);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(end);
        shapesStarts.delete(start);
        shapesStarts.set(end, shapeIndex);
      } else if (startMatchesEnd) {
        const shapeIndex = shapesEnds.get(start);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(end);
        shapesEnds.delete(start);
        shapesEnds.set(end, shapeIndex);
      } else if (endMatchesStart) {
        const shapeIndex = shapesStarts.get(end);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(start);
        shapesStarts.delete(end);
        shapesStarts.set(start, shapeIndex);
      } else if (endMatchesEnd) {
        const shapeIndex = shapesEnds.get(end);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(start);
        shapesEnds.delete(end);
        shapesEnds.set(start, shapeIndex);
      }
    }
    const trueIndices = [];
    for (const [id, shape] of shapes) {
      if (openShapes.has(id)) {
        continue;
      }
      const vertices2 = [];
      const indexMap = /* @__PURE__ */ new Map();
      let counter = 0;
      for (const index of shape) {
        const vertex = all2DVertices[index];
        vertices2.push(vertex[0], vertex[1]);
        indexMap.set(counter++, index);
      }
      const result = earcut$1(vertices2);
      for (const index of result) {
        const trueIndex = indexMap.get(index);
        if (trueIndex === void 0) {
          throw new Error("Map error!");
        }
        trueIndices.push(trueIndex);
      }
    }
    return trueIndices;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new Matrix4();
    const xAxis = new Vector3(1, 0, 0);
    const yAxis = new Vector3(0, 1, 0);
    const zAxis = this.plane.normal;
    const pos = new Vector3();
    this.plane.coplanarPoint(pos);
    if (this._planeAxis === "x") {
      xAxis.crossVectors(yAxis, zAxis);
    } else if (this._planeAxis === "y") {
      yAxis.crossVectors(zAxis, xAxis);
    } else if (this._planeAxis === "z")
      ;
    else {
      xAxis.crossVectors(yAxis, zAxis).normalize();
      yAxis.crossVectors(zAxis, xAxis);
    }
    this._plane2DCoordinateSystem.fromArray([
      xAxis.x,
      xAxis.y,
      xAxis.z,
      0,
      yAxis.x,
      yAxis.y,
      yAxis.z,
      0,
      zAxis.x,
      zAxis.y,
      zAxis.z,
      0,
      pos.x,
      pos.y,
      pos.z,
      1
    ]);
    this._plane2DCoordinateSystem.invert();
  }
  shapecast(mesh, posAttr, index) {
    mesh.geometry.boundsTree.shapecast({
      intersectsBounds: (box) => {
        return this._localPlane.intersectsBox(box);
      },
      // @ts-ignore
      intersectsTriangle: (tri) => {
        let count = 0;
        this._tempLine.start.copy(tri.a);
        this._tempLine.end.copy(tri.b);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.b);
        this._tempLine.end.copy(tri.c);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.c);
        this._tempLine.end.copy(tri.a);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        if (count !== 2) {
          index -= count;
        }
      }
    });
    return index;
  }
};
__publicField(SectionGenerator, "uuid", "1a193b87-6376-46c8-9e65-62a1576fdb64");
var _Components = class _Components2 {
  constructor() {
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "list", /* @__PURE__ */ new Map());
    __publicField(this, "enabled", false);
    __publicField(this, "_clock");
    __publicField(this, "onInit", new Event());
    __publicField(this, "update", () => {
      if (!this.enabled)
        return;
      const delta = this._clock.getDelta();
      for (const [_id, component] of this.list) {
        if (component.enabled && component.isUpdateable()) {
          component.update(delta);
        }
      }
      requestAnimationFrame(this.update);
    });
    this._clock = new Clock();
    _Components2.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(uuid, instance) {
    if (this.list.has(uuid))
      throw new Error(
        `You're trying to add a component that already exists in the components instance. Use Components.get() instead.`
      );
    UUID.validate(uuid);
    this.list.set(uuid, instance);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(Component2) {
    const uuid = Component2.uuid;
    if (!this.list.has(uuid)) {
      const toolInstance = new Component2(this);
      if (!this.list.has(uuid)) {
        this.add(uuid, toolInstance);
      }
      return toolInstance;
    }
    return this.list.get(uuid);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = true;
    this._clock.start();
    this.update();
    this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [_id, component] of this.list) {
      component.enabled = false;
      if (component.isDisposeable()) {
        component.dispose();
      }
    }
    this._clock.stop();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
    BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
    Mesh.prototype.raycast = acceleratedRaycast;
  }
};
__publicField(_Components, "release", "2.4.10");
var Components = _Components;
var SimpleWorld = class extends Base {
  constructor() {
    super(...arguments);
    __publicField(this, "meshes", /* @__PURE__ */ new Set());
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "isDisposing", false);
    __publicField(this, "enabled", true);
    __publicField(this, "uuid", UUID.create());
    __publicField(this, "name");
    __publicField(this, "_scene");
    __publicField(this, "_camera");
    __publicField(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene) {
      throw new Error("No scene initialized!");
    }
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(scene) {
    this._scene = scene;
    scene.worlds.set(this.uuid, this);
    scene.currentWorld = this;
    scene.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera) {
      throw new Error("No camera initialized!");
    }
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(camera) {
    this._camera = camera;
    camera.worlds.set(this.uuid, this);
    camera.currentWorld = this;
    camera.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(renderer) {
    this._renderer = renderer;
    if (renderer) {
      renderer.worlds.set(this.uuid, this);
      renderer.currentWorld = this;
      renderer.onWorldChanged.trigger({ world: this, action: "added" });
    }
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    if (!this._scene || !this._camera) {
      return;
    }
    this.scene.currentWorld = this;
    this.camera.currentWorld = this;
    if (this.renderer) {
      this.renderer.currentWorld = this;
    }
    this.onBeforeUpdate.trigger();
    if (this.scene.isUpdateable()) {
      this.scene.update(delta);
    }
    if (this.camera.isUpdateable()) {
      this.camera.update(delta);
    }
    if (this.renderer) {
      this.renderer.update(delta);
    }
    this.onAfterUpdate.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose(disposeResources = true) {
    this.enabled = false;
    this.isDisposing = true;
    this.scene.onWorldChanged.trigger({ world: this, action: "removed" });
    this.camera.onWorldChanged.trigger({ world: this, action: "removed" });
    if (this.renderer) {
      this.renderer.onWorldChanged.trigger({ world: this, action: "removed" });
    }
    if (disposeResources) {
      const disposer = this.components.get(Disposer);
      this.scene.dispose();
      if (this.camera.isDisposeable()) {
        this.camera.dispose();
      }
      if (this.renderer) {
        this.renderer.dispose();
      }
      for (const mesh of this.meshes) {
        disposer.destroy(mesh);
      }
      this.meshes.clear();
    }
    this._scene = null;
    this._camera = null;
    this._renderer = null;
    const worlds = this.components.get(Worlds);
    worlds.list.delete(this.uuid);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
var Configurator = class {
  constructor(component, components, name, uuid) {
    __publicField(this, "_component");
    __publicField(this, "name");
    __publicField(this, "uuid");
    this._component = component;
    this.name = name;
    this.uuid = uuid ?? UUID.create();
    const configManager = components.get(ConfigManager);
    configManager.list.set(this.uuid, this);
  }
  get controls() {
    return ControlsUtils.copySchema(this._config);
  }
  set(data) {
    for (const name in data) {
      if (name in this) {
        const key = name;
        this[key] = data[name].value;
      }
    }
  }
  export(controls = this._config, exported = {}) {
    for (const id in controls) {
      const control = controls[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          exported[id] = { ...control, value: { r, g, b } };
        } else if (control.type === "Vector3") {
          const { x, y, z: z2 } = control.value;
          exported[id] = { ...control, value: { x, y, z: z2 } };
        } else if (control.type === "TextSet") {
          const value = Array.from(control.value);
          exported[id] = { ...control, value };
        } else if (control.type === "Select") {
          const options = Array.from(control.options);
          exported[id] = { ...control, options };
        } else {
          exported[id] = { ...control };
        }
      } else {
        exported[id] = {};
        this.export(control, exported[id]);
      }
    }
    return exported;
  }
  import(exported, imported = {}, first = true) {
    for (const id in exported) {
      const control = exported[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          imported[id] = { ...control, value: new Color(r, g, b) };
        } else if (control.type === "Vector3") {
          const { x, y, z: z2 } = control.value;
          imported[id] = { ...control, value: new Vector3(x, y, z2) };
        } else if (control.type === "TextSet") {
          imported[id] = { ...control, value: new Set(control.value) };
        } else if (control.type === "Select") {
          imported[id] = { ...control, options: new Set(control.options) };
        } else {
          imported[id] = { ...control };
        }
      } else {
        imported[id] = {};
        this.import(control, imported[id], false);
      }
    }
    if (first) {
      this.set(imported);
    }
  }
};
var _ConfigManager = class _ConfigManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "list", new DataMap());
    __publicField(this, "enabled", true);
    components.add(_ConfigManager2.uuid, this);
  }
};
__publicField(_ConfigManager, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
var ConfigManager = _ConfigManager;
var DirectionalLightConfig = class {
  constructor(list, scene) {
    __publicField(this, "_list");
    __publicField(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.directionalLight.color.value;
  }
  set color(value) {
    this._list.directionalLight.color.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.directionalLight.intensity.value;
  }
  set intensity(value) {
    this._list.directionalLight.intensity.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.intensity = value;
    }
  }
  get position() {
    return this._list.directionalLight.position.value.clone();
  }
  set position(value) {
    this._list.directionalLight.position.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.position.copy(value);
    }
  }
};
var AmbientLightConfig = class {
  constructor(list, scene) {
    __publicField(this, "_list");
    __publicField(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.ambientLight.color.value;
  }
  set color(value) {
    this._list.ambientLight.color.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.ambientLight.intensity.value;
  }
  set intensity(value) {
    this._list.ambientLight.intensity.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.intensity = value;
    }
  }
};
var SimpleSceneConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      backgroundColor: {
        value: new Color(),
        type: "Color"
      },
      ambientLight: {
        color: {
          type: "Color",
          value: new Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        }
      },
      directionalLight: {
        color: {
          type: "Color",
          value: new Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        },
        position: {
          type: "Vector3",
          value: new Vector3()
        }
      }
    });
    __publicField(this, "ambientLight", new AmbientLightConfig(this._config, this._component));
    __publicField(this, "directionalLight", new DirectionalLightConfig(this._config, this._component));
  }
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  set backgroundColor(value) {
    this._config.backgroundColor.value = value;
    this._component.three.background = value;
  }
};
var SimpleScene = class extends BaseScene {
  constructor(components) {
    super(components);
    __publicField(this, "onSetup", new Event());
    __publicField(this, "isSetup", false);
    __publicField(this, "three");
    __publicField(this, "config", new SimpleSceneConfigManager(this, this.components, "Scene"));
    __publicField(this, "_defaultConfig", {
      backgroundColor: new Color(2107698),
      directionalLight: {
        color: new Color("white"),
        intensity: 1.5,
        position: new Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new Color("white"),
        intensity: 1
      }
    });
    this.three = new Scene();
    this.three.background = new Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.backgroundColor = fullConfig.backgroundColor;
    const ambLightData = fullConfig.ambientLight;
    this.config.ambientLight.color = ambLightData.color;
    this.config.ambientLight.intensity = ambLightData.intensity;
    const dirLightData = fullConfig.directionalLight;
    this.config.directionalLight.color = dirLightData.color;
    this.config.directionalLight.intensity = dirLightData.intensity;
    this.config.directionalLight.position = dirLightData.position;
    this.deleteAllLights();
    const { color: dc2, intensity: di2 } = this.config.directionalLight;
    const directionalLight = new DirectionalLight(dc2, di2);
    directionalLight.position.copy(dirLightData.position);
    const { color: ac2, intensity: ai2 } = this.config.directionalLight;
    const ambientLight = new AmbientLight(ac2, ai2);
    this.three.add(directionalLight, ambientLight);
    this.directionalLights.set(directionalLight.uuid, directionalLight);
    this.ambientLights.set(ambientLight.uuid, ambientLight);
    this.isSetup = true;
    this.onSetup.trigger();
  }
  dispose() {
    super.dispose();
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
  }
};
var SimpleRenderer = class extends BaseRenderer {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(components, container, parameters) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "container");
    __publicField(this, "three");
    __publicField(this, "_canvas");
    __publicField(this, "_parameters");
    __publicField(this, "_resizeObserver", null);
    __publicField(this, "onContainerUpdated", new Event());
    __publicField(this, "_resizing", false);
    __publicField(this, "resize", (size) => {
      if (this._resizing)
        return;
      this._resizing = true;
      this.onContainerUpdated.trigger();
      const width = size ? size.x : this.container.clientWidth;
      const height = size ? size.y : this.container.clientHeight;
      this.three.setSize(width, height);
      this.onResize.trigger(new Vector2(width, height));
      this._resizing = false;
    });
    __publicField(this, "resizeEvent", () => {
      this.resize();
    });
    __publicField(this, "onContextLost", (event) => {
      event.preventDefault();
      this.enabled = false;
    });
    __publicField(this, "onContextBack", () => {
      this.three.setRenderTarget(null);
      this.three.dispose();
      this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      });
      this.enabled = true;
    });
    this.container = container;
    this._parameters = parameters;
    this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...parameters
    });
    this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.setupRenderer();
    this.setupEvents(true);
    this.resize();
    this._canvas = this.three.domElement;
    const context = this.three.getContext();
    const { canvas } = context;
    canvas.addEventListener("webglcontextlost", this.onContextLost, false);
    canvas.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const scene = this.currentWorld.scene.three;
    const camera = this.currentWorld.camera.three;
    this.three.render(scene, camera);
    this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.setupEvents(false);
    this.three.domElement.remove();
    this.three.forceContextLoss();
    this.three.dispose();
    this.onResize.reset();
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(active) {
    const dom = this.three.domElement.parentElement;
    if (!dom) {
      throw new Error("This renderer needs to have an HTML container!");
    }
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    window.removeEventListener("resize", this.resizeEvent);
    if (active) {
      this._resizeObserver = new ResizeObserver(this.resizeEvent);
      this._resizeObserver.observe(dom);
      window.addEventListener("resize", this.resizeEvent);
    }
  }
  setupRenderer() {
    this.three.localClippingEnabled = true;
    if (this.container) {
      this.container.appendChild(this.three.domElement);
    }
    this.onContainerUpdated.trigger();
  }
};
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
var DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
var DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
  return approxZero(a - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp5 = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp5) * exp;
  let output = target + (change + temp5) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
var EventDispatcher = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
};
var _a2;
var VERSION = "2.10.1";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isMac = /Mac/.test((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.platform);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v2$1;
var _v3A;
var _v3B;
var _v3C;
var _cameraDirection;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster$1;
var CameraControls = class _CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2$1 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster$1 = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(_) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = this.truckSpeed * deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = this.truckSpeed * deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (screenSpacePanning) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown2 = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove2 = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onPointerUp2 = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 || event.ctrlKey ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.SCREEN_PAN: {
          this._truckInternal(event.deltaX, event.deltaY, false, true);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true, false);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === _CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2$1);
      lastDragPosition.copy(_v2$1);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2$1.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2$1.y;
      lastDragPosition.copy(_v2$1);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
        this._truckInternal(deltaX, deltaY, false, true);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true, false);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      lastDragPosition.copy(_v2$1);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      startDragging();
    };
    this.unlockPointer = () => {
      var _a22, _b, _c2;
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      (_a22 = this._domElement) === null || _a22 === void 0 ? void 0 : _a22.ownerDocument.exitPointerLock();
      (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      (_c2 = this._domElement) === null || _c2 === void 0 ? void 0 : _c2.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
      this.cancel();
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown2);
      this._domElement.addEventListener("pointercancel", onPointerUp2);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown2);
      this._domElement.removeEventListener("pointercancel", onPointerUp2);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to2 = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to2.x, to2.y, to2.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to2 = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to2.x, to2.y, to2.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z2, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z2).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z2, enableTransition = false) {
    const point = _v3A.set(x, y, z2);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isObject3D = "isObject3D" in sphereOrMesh;
    const boundingSphere = isObject3D ? _CameraControls.createBoundingSphere(sphereOrMesh, _sphere) : _sphere.copy(sphereOrMesh);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t15, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t15));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t15, _sphericalA.phi + deltaPhi * t15, _sphericalA.theta + deltaTheta * t15);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z2, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z2);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = out || new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd);
    this._target.copy(this._targetEnd);
    this._spherical.copy(this._sphericalEnd);
    this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
      this._camera.updateMatrixWorld();
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster$1.set(origin, rayDirection);
      _raycaster$1.far = this._spherical.radius + 1;
      const intersects2 = _raycaster$1.intersectObjects(this.colliderMeshes);
      if (intersects2.length !== 0 && intersects2[0].distance < distance) {
        distance = intersects2[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      if (!mesh.geometry)
        return;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l = position.count; i < l; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
};
var SimpleCamera = class _SimpleCamera extends BaseCamera {
  constructor(components) {
    super(components);
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onAspectUpdated", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "three");
    __publicField(this, "_allControls", /* @__PURE__ */ new Map());
    __publicField(this, "updateAspect", () => {
      var _a22;
      if (!this.currentWorld || !this.currentWorld.renderer)
        return;
      if (this.three instanceof OrthographicCamera) {
        this.onAspectUpdated.trigger();
        return;
      }
      if ((_a22 = this.currentWorld.renderer) == null ? void 0 : _a22.isResizeable()) {
        const size = this.currentWorld.renderer.getSize();
        this.three.aspect = size.width / size.height;
        this.three.updateProjectionMatrix();
        this.onAspectUpdated.trigger();
      }
    });
    this.three = this.setupCamera();
    this.setupEvents(true);
    this.onWorldChanged.add(({ action, world }) => {
      if (action === "added") {
        const controls = this.newCameraControls();
        this._allControls.set(world.uuid, controls);
      }
      if (action === "removed") {
        const controls = this._allControls.get(world.uuid);
        if (controls) {
          controls.dispose();
          this._allControls.delete(world.uuid);
        }
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    const controls = this._allControls.get(this.currentWorld.uuid);
    if (!controls) {
      throw new Error("Controls not found!");
    }
    return controls;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    if (this.currentWorld === null) {
      return false;
    }
    return this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(enabled) {
    if (this.currentWorld !== null) {
      this.controls.enabled = enabled;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onAspectUpdated.reset();
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.three.removeFromParent();
    this.onDisposed.trigger();
    this.onDisposed.reset();
    for (const [_id, controls] of this._allControls) {
      controls.dispose();
    }
  }
  /** {@link Updateable.update} */
  update(_delta) {
    if (this.enabled) {
      this.onBeforeUpdate.trigger(this);
      this.controls.update(_delta);
      this.onAfterUpdate.trigger(this);
    }
  }
  setupCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new PerspectiveCamera(60, aspect, 1, 1e3);
    camera.position.set(50, 50, 50);
    camera.lookAt(new Vector3(0, 0, 0));
    return camera;
  }
  newCameraControls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    if (!this.currentWorld.renderer) {
      throw new Error("This camera needs a renderer to work!");
    }
    CameraControls.install({ THREE: _SimpleCamera.getSubsetOfThree() });
    const { domElement } = this.currentWorld.renderer.three;
    const controls = new CameraControls(this.three, domElement);
    controls.smoothTime = 0.2;
    controls.dollyToCursor = true;
    controls.infinityDolly = true;
    controls.minDistance = 6;
    return controls;
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.updateAspect);
    } else {
      window.removeEventListener("resize", this.updateAspect);
    }
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var _Worlds = class _Worlds2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "list", new DataMap());
    __publicField(this, "enabled", true);
    components.add(_Worlds2.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const world = new SimpleWorld(this.components);
    const id = world.uuid;
    if (this.list.has(id)) {
      throw new Error("There is already a world with this name!");
    }
    this.list.set(id, world);
    return world;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(world) {
    if (!this.list.has(world.uuid)) {
      throw new Error("The provided world is not found in the list!");
    }
    this.list.delete(world.uuid);
    world.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = false;
    for (const [_id, world] of this.list) {
      world.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    for (const [_id, world] of this.list) {
      world.update(delta);
    }
  }
};
__publicField(_Worlds, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Worlds = _Worlds;
function clientWaitAsync(gl, sync, flags, intervalMilliseconds) {
  return new Promise((resolve, reject) => {
    function test() {
      const res = gl.clientWaitSync(sync, flags, 0);
      if (res === gl.WAIT_FAILED) {
        reject();
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test, intervalMilliseconds);
        return;
      }
      resolve();
    }
    test();
  });
}
async function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  await clientWaitAsync(gl, sync, 0, 10);
  gl.deleteSync(sync);
  gl.bindBuffer(target, buffer);
  gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
  gl.bindBuffer(target, null);
}
async function readPixelsAsync(gl, x, y, w, h, format, type, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x, y, w, h, format, type, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}
var CullerRendererConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      width: {
        type: "Number",
        interpolable: true,
        value: 512,
        min: 32,
        max: 1024
      },
      height: {
        type: "Number",
        interpolable: true,
        value: 512,
        min: 32,
        max: 1024
      },
      autoUpdate: {
        value: true,
        type: "Boolean"
      },
      renderDebugFrame: {
        value: false,
        type: "Boolean"
      },
      updateInterval: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      threshold: {
        type: "Number",
        interpolable: true,
        value: 100,
        min: 1,
        max: 512
      }
    });
    __publicField(this, "_interval", null);
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(value) {
    this._config.enabled.value = value;
    this._component.enabled = value;
  }
  get width() {
    return this._config.width.value;
  }
  set width(value) {
    this.setWidthHeight(value, this.height);
  }
  get height() {
    return this._config.height.value;
  }
  set height(value) {
    this.setWidthHeight(this.width, value);
  }
  get autoUpdate() {
    return this._config.autoUpdate.value;
  }
  set autoUpdate(value) {
    this.setAutoAndInterval(value, this.updateInterval);
  }
  get updateInterval() {
    return this._config.updateInterval.value;
  }
  set updateInterval(value) {
    this.setAutoAndInterval(this.autoUpdate, value);
  }
  get renderDebugFrame() {
    return this._config.renderDebugFrame.value;
  }
  set renderDebugFrame(value) {
    this._config.renderDebugFrame.value = value;
  }
  get threshold() {
    return this._config.threshold.value;
  }
  set threshold(value) {
    this._config.threshold.value = value;
  }
  setWidthHeight(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error(
        "The width and height of the culler renderer must be more than 0!"
      );
    }
    this._config.width.value = width;
    this._config.height.value = height;
    this.resetRenderTarget();
  }
  setAutoAndInterval(auto, interval) {
    if (interval <= 0) {
      throw new Error(
        "The updateInterval of the culler renderer must be more than 0!"
      );
    }
    this._config.autoUpdate.value = auto;
    this._config.updateInterval.value = interval;
    this.resetInterval(auto);
  }
  resetRenderTarget() {
    this._component.renderTarget.dispose();
    this._component.renderTarget = new WebGLRenderTarget(
      this.width,
      this.height
    );
    this._component.bufferSize = this.width * this.height * 4;
    this._component.buffer = new Uint8Array(this._component.bufferSize);
  }
  resetInterval(enabled) {
    if (this._interval !== null) {
      window.clearInterval(this._interval);
    }
    if (!enabled)
      return;
    this._interval = window.setInterval(async () => {
      if (!this._component.preventUpdate) {
        await this._component.updateVisibility();
      }
    }, this.updateInterval);
  }
};
var CullerRenderer = class {
  constructor(components, world) {
    __publicField(this, "onSetup", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onViewUpdated", new AsyncEvent());
    __publicField(this, "enabled", true);
    __publicField(this, "needsUpdate", false);
    __publicField(this, "components");
    __publicField(this, "renderTarget", new WebGLRenderTarget());
    __publicField(this, "bufferSize", 1);
    __publicField(this, "buffer", new Uint8Array());
    __publicField(this, "preventUpdate", false);
    __publicField(this, "config");
    __publicField(this, "isSetup", false);
    __publicField(this, "world");
    __publicField(this, "renderer");
    __publicField(this, "_defaultConfig", {
      enabled: true,
      height: 512,
      width: 512,
      updateInterval: 1e3,
      autoUpdate: true,
      renderDebugFrame: false,
      threshold: 100
    });
    __publicField(this, "worker");
    __publicField(this, "scene", new Scene());
    __publicField(this, "_availableColor", 1);
    __publicField(this, "_isWorkerBusy", false);
    __publicField(this, "updateVisibility", async (force) => {
      if (!this.enabled)
        return;
      if (!this.needsUpdate && !force)
        return;
      if (this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const camera = this.world.camera.three;
      camera.updateMatrix();
      const { width, height } = this.config;
      this.renderer.setSize(width, height);
      this.renderer.setRenderTarget(this.renderTarget);
      this.renderer.render(this.scene, camera);
      const context = this.renderer.getContext();
      await readPixelsAsync(
        context,
        0,
        0,
        width,
        height,
        context.RGBA,
        context.UNSIGNED_BYTE,
        this.buffer
      );
      this.renderer.setRenderTarget(null);
      if (this.config.renderDebugFrame) {
        this.renderer.render(this.scene, camera);
      }
      this.worker.postMessage({
        buffer: this.buffer
      });
      this.needsUpdate = false;
    });
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.components = components;
    this.config = new CullerRendererConfigManager(
      this,
      this.components,
      "Culler renderer"
    );
    this.world = world;
    this.renderer = new WebGLRenderer();
    this.renderer.clippingPlanes = world.renderer.clippingPlanes;
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.setup();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.config.autoUpdate = false;
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    for (const child of this.scene.children) {
      child.removeFromParent();
    }
    this.onViewUpdated.reset();
    this.worker.terminate();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.renderTarget.dispose();
    this.buffer = null;
    this.onDisposed.reset();
  }
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    const { width, height } = fullConfig;
    this.config.setWidthHeight(width, height);
    const { updateInterval, autoUpdate } = fullConfig;
    this.config.setAutoAndInterval(autoUpdate, updateInterval);
    this.config.threshold = fullConfig.threshold;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  getAvailableColor() {
    let bigOne = BigInt(this._availableColor.toString());
    const colorArray = [];
    do {
      colorArray.unshift(Number(bigOne % 256n));
      bigOne /= 256n;
    } while (bigOne);
    while (colorArray.length !== 3) {
      colorArray.unshift(0);
    }
    const [r, g, b] = colorArray;
    const code = `${r}-${g}-${b}`;
    return { r, g, b, code };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
};
var MeshCullerRenderer = class extends CullerRenderer {
  constructor(components, world) {
    super(components, world);
    __publicField(this, "onViewUpdated", new Event());
    __publicField(this, "colorMeshes", /* @__PURE__ */ new Map());
    __publicField(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    __publicField(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    __publicField(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    __publicField(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    __publicField(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    }));
    __publicField(this, "handleWorkerMessage", async (event) => {
      if (this.preventUpdate) {
        return;
      }
      const colors = event.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes);
      this._currentVisibleMeshes.clear();
      for (const [code, pixels] of colors) {
        if (pixels < this.config.threshold) {
          continue;
        }
        const mesh = this._colorCodeMeshMap.get(code);
        if (mesh) {
          this._currentVisibleMeshes.add(mesh);
          this._recentlyHiddenMeshes.delete(mesh);
        }
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      });
      this._isWorkerBusy = false;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage);
    this.onViewUpdated.add(({ seen, unseen }) => {
      for (const mesh of seen) {
        mesh.visible = true;
      }
      for (const mesh of unseen) {
        mesh.visible = false;
      }
    });
  }
  /**
   * @deprecated use config.threshold instead.
   */
  get threshold() {
    return this.config.threshold;
  }
  /**
   * @deprecated use config.threshold instead.
   */
  set threshold(value) {
    this.config.threshold = value;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    this._currentVisibleMeshes.clear();
    this._recentlyHiddenMeshes.clear();
    this._meshIDColorCodeMap.clear();
    this._transparentMat.dispose();
    this._colorCodeMeshMap.clear();
    const disposer = this.components.get(Disposer);
    for (const id in this.colorMeshes) {
      const mesh = this.colorMeshes.get(id);
      if (mesh) {
        disposer.destroy(mesh, true);
      }
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  add(mesh) {
    if (!this.enabled)
      return;
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = true;
    const isInstanced = mesh instanceof InstancedMesh;
    const { geometry, material } = mesh;
    const { colorMaterial, code } = this.getAvailableMaterial();
    let newMaterial;
    if (Array.isArray(material)) {
      let transparentOnly = true;
      const matArray = [];
      for (const mat of material) {
        if (MaterialsUtils.isTransparent(mat)) {
          matArray.push(this._transparentMat);
        } else {
          transparentOnly = false;
          matArray.push(colorMaterial);
        }
      }
      if (transparentOnly) {
        colorMaterial.dispose();
        this.preventUpdate = false;
        return;
      }
      newMaterial = matArray;
    } else if (MaterialsUtils.isTransparent(material)) {
      colorMaterial.dispose();
      this.preventUpdate = false;
      return;
    } else {
      newMaterial = colorMaterial;
    }
    this._colorCodeMeshMap.set(code, mesh);
    this._meshIDColorCodeMap.set(mesh.uuid, code);
    const count = isInstanced ? mesh.count : 1;
    const colorMesh = new InstancedMesh(geometry, newMaterial, count);
    if (isInstanced) {
      colorMesh.instanceMatrix = mesh.instanceMatrix;
    } else {
      colorMesh.setMatrixAt(0, new Matrix4());
    }
    mesh.visible = false;
    mesh.updateWorldMatrix(true, false);
    colorMesh.applyMatrix4(mesh.matrixWorld);
    colorMesh.updateMatrix();
    this.scene.add(colorMesh);
    this.colorMeshes.set(mesh.uuid, colorMesh);
    this.increaseColor();
    this.preventUpdate = false;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  remove(mesh) {
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = true;
    const disposer = this.components.get(Disposer);
    this._currentVisibleMeshes.delete(mesh);
    this._recentlyHiddenMeshes.delete(mesh);
    const colorMesh = this.colorMeshes.get(mesh.uuid);
    const code = this._meshIDColorCodeMap.get(mesh.uuid);
    if (!colorMesh || !code) {
      this.preventUpdate = false;
      return;
    }
    this._colorCodeMeshMap.delete(code);
    this._meshIDColorCodeMap.delete(mesh.uuid);
    this.colorMeshes.delete(mesh.uuid);
    colorMesh.geometry = void 0;
    colorMesh.material = [];
    disposer.destroy(colorMesh, true);
    this._recentlyHiddenMeshes.delete(mesh);
    this._currentVisibleMeshes.delete(mesh);
    this.preventUpdate = false;
  }
  /**
   * Updates the given instanced meshes inside the culler. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   * @returns {void}
   */
  updateInstanced(meshes) {
    for (const mesh of meshes) {
      const colorMesh = this.colorMeshes.get(mesh.uuid);
      if (!colorMesh) {
        continue;
      }
      colorMesh.count = mesh.count;
    }
  }
  getAvailableMaterial() {
    const { r, g, b, code } = this.getAvailableColor();
    const colorEnabled = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const color = new Color(`rgb(${r}, ${g}, ${b})`);
    if (!this.world.renderer) {
      throw new Error("Renderer not found in the world!");
    }
    const clippingPlanes = this.world.renderer.clippingPlanes;
    const colorMaterial = new MeshBasicMaterial({
      color,
      clippingPlanes,
      side: DoubleSide
    });
    ColorManagement.enabled = colorEnabled;
    return { colorMaterial, code };
  }
};
var _Cullers = class _Cullers2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "_enabled", true);
    __publicField(this, "list", /* @__PURE__ */ new Map());
    components.add(_Cullers2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(value) {
    this._enabled = value;
    for (const [_id, renderer] of this.list) {
      renderer.enabled = value;
    }
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const culler = new MeshCullerRenderer(this.components, world);
    this.list.set(world.uuid, culler);
    return culler;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(world) {
    const culler = this.list.get(world.uuid);
    if (culler) {
      culler.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onDisposed.trigger(_Cullers2.uuid);
    this.onDisposed.reset();
    for (const [_id, culler] of this.list) {
      culler.dispose();
    }
    this.list.clear();
  }
  /**
   * Updates the given instanced meshes inside the all the cullers. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   */
  updateInstanced(meshes) {
    for (const [, culler] of this.list) {
      culler.updateInstanced(meshes);
    }
  }
};
__publicField(_Cullers, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Cullers = _Cullers;
var DistanceRenderer = class {
  constructor(components, world) {
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onDistanceComputed", new Event());
    __publicField(this, "excludedObjects", /* @__PURE__ */ new Set());
    __publicField(this, "enabled", true);
    __publicField(this, "renderDebugFrame", false);
    __publicField(this, "components");
    __publicField(this, "scene", new Scene());
    __publicField(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    __publicField(this, "depthMaterial");
    __publicField(this, "world");
    __publicField(this, "renderer");
    __publicField(this, "worker");
    __publicField(this, "_width", 512);
    __publicField(this, "_height", 512);
    __publicField(this, "_postQuad");
    __publicField(this, "tempRT");
    __publicField(this, "resultRT");
    __publicField(this, "bufferSize");
    __publicField(this, "_buffer");
    __publicField(this, "_isWorkerBusy", false);
    __publicField(this, "compute", async () => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      if (this._isWorkerBusy) {
        return;
      }
      this._isWorkerBusy = true;
      this.world.camera.three.updateMatrix();
      this.renderer.setSize(this._width, this._height);
      this.renderer.setRenderTarget(this.tempRT);
      const tempVariableName = "visibilityBeforeDistanceCheck";
      for (const object of this.excludedObjects) {
        object.userData[tempVariableName] = object.visible;
        object.visible = false;
      }
      this.renderer.render(this.world.scene.three, this.world.camera.three);
      for (const object of this.excludedObjects) {
        if (object.userData[tempVariableName] !== void 0) {
          object.visible = object.userData[tempVariableName];
        }
      }
      this.depthMaterial.uniforms.tDiffuse.value = this.tempRT.texture;
      this.depthMaterial.uniforms.tDepth.value = this.tempRT.depthTexture;
      this.renderer.setRenderTarget(this.resultRT);
      this.renderer.render(this.scene, this.camera);
      const context = this.renderer.getContext();
      try {
        await readPixelsAsync(
          context,
          0,
          0,
          this._width,
          this._height,
          context.RGBA,
          context.UNSIGNED_BYTE,
          this._buffer
        );
      } catch (e2) {
        this.renderer.setRenderTarget(null);
        this._isWorkerBusy = false;
        return;
      }
      this.renderer.setRenderTarget(null);
      if (this.renderDebugFrame) {
        this.renderer.render(this.scene, this.camera);
      }
      this.worker.postMessage({
        buffer: this._buffer
      });
    });
    __publicField(this, "handleWorkerMessage", (event) => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      const colors = event.data.colors;
      let min = Number.MAX_VALUE;
      for (const value of colors) {
        if (value === 0) {
          continue;
        }
        if (value < min) {
          min = value;
        }
      }
      const camera2 = this.world.camera.three || OrthographicCamera;
      const normalized = min / 255;
      const maxFoundDistance = (normalized - 1) * -1 * (camera2.far - camera2.near);
      const maxValidDistance = Math.min(maxFoundDistance, camera2.far);
      this.onDistanceComputed.trigger(maxValidDistance);
      this._isWorkerBusy = false;
    });
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.components = components;
    this.world = world;
    const camera = world.camera.three;
    this.renderer = new WebGLRenderer();
    this.tempRT = new WebGLRenderTarget(this._width, this._height);
    this.bufferSize = this._width * this._height * 4;
    this._buffer = new Uint8Array(this.bufferSize);
    this.tempRT.texture.minFilter = NearestFilter;
    this.tempRT.texture.magFilter = NearestFilter;
    this.tempRT.stencilBuffer = false;
    this.tempRT.samples = 0;
    this.tempRT.depthTexture = new DepthTexture(
      this._width,
      this._height
    );
    this.tempRT.depthTexture.format = DepthFormat;
    this.tempRT.depthTexture.type = UnsignedShortType;
    this.resultRT = new WebGLRenderTarget(this._width, this._height);
    this.depthMaterial = new ShaderMaterial({
      vertexShader: `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
    `,
      fragmentShader: `
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform float cameraNear;
uniform float cameraFar;


float readDepth( sampler2D depthSampler, vec2 coord ) {
  float fragCoordZ = texture2D( depthSampler, coord ).x;
  float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
  return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
}

void main() {
  //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
  float depth = readDepth( tDepth, vUv );

  gl_FragColor.rgb = 1.0 - vec3( depth );
  gl_FragColor.a = 1.0;
}
    `,
      uniforms: {
        cameraNear: { value: camera.near },
        cameraFar: { value: camera.far },
        tDiffuse: { value: null },
        tDepth: { value: null }
      }
    });
    const postPlane = new PlaneGeometry(2, 2);
    this._postQuad = new Mesh(postPlane, this.depthMaterial);
    this.scene.add(this._postQuad);
    this.renderer.clippingPlanes = world.renderer.clippingPlanes;
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          colors.add(r);
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.addEventListener("message", this.handleWorkerMessage);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onDistanceComputed.reset();
    this.worker.terminate();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.tempRT.dispose();
    this.resultRT.dispose();
    const children = [...this.scene.children];
    this.excludedObjects.clear();
    for (const child of children) {
      child.removeFromParent();
    }
    this._postQuad.geometry.dispose();
    this._postQuad.removeFromParent();
    this._buffer = null;
    this.onDisposed.reset();
  }
};
var ShadowedScene = class extends SimpleScene {
  constructor() {
    super(...arguments);
    __publicField(this, "_distanceRenderer");
    __publicField(this, "autoBias", true);
    __publicField(this, "_defaultShadowConfig", {
      cascade: 1,
      resolution: 512
    });
    __publicField(this, "_lightsWithShadow", /* @__PURE__ */ new Map());
    __publicField(this, "_isComputingShadows", false);
    __publicField(this, "_shadowsEnabled", true);
    __publicField(this, "_bias", 0);
    __publicField(this, "recomputeShadows", (farthestDistance) => {
      if (!this._shadowsEnabled) {
        return;
      }
      if (this.autoBias) {
        this.bias = farthestDistance / -1e5;
      }
      const factor = 1.5;
      farthestDistance *= factor;
      if (!this.currentWorld) {
        throw new Error(
          "A world needs to be assigned to the scene before computing shadows!"
        );
      }
      if (!this._lightsWithShadow.size) {
        throw new Error("No shadows found!");
      }
      const camera = this.currentWorld.camera.three;
      if (!(camera instanceof PerspectiveCamera) && !(camera instanceof OrthographicCamera)) {
        throw new Error("Invalid camera type!");
      }
      const camDirection = new Vector3();
      camera.getWorldDirection(camDirection);
      let currentDistance = farthestDistance;
      const lightDirection = new Vector3();
      lightDirection.copy(this.config.directionalLight.position);
      lightDirection.normalize();
      for (const [index, id] of this._lightsWithShadow) {
        const light = this.directionalLights.get(id);
        if (!light) {
          throw new Error("Light not found.");
        }
        const shadowCenter = new Vector3();
        shadowCenter.copy(camDirection);
        const isLastShadow = index === this._lightsWithShadow.size - 1;
        const shadowOffset = isLastShadow ? currentDistance / 2 : currentDistance * 2 / 3;
        shadowCenter.multiplyScalar(shadowOffset);
        shadowCenter.add(camera.position);
        const shadowRadius = currentDistance - shadowOffset;
        const lightOffset = new Vector3();
        lightOffset.copy(lightDirection);
        lightOffset.multiplyScalar(shadowRadius);
        light.target.position.copy(shadowCenter);
        light.position.copy(shadowCenter);
        light.position.add(lightOffset);
        light.shadow.camera.right = shadowRadius;
        light.shadow.camera.left = -shadowRadius;
        light.shadow.camera.top = shadowRadius;
        light.shadow.camera.bottom = -shadowRadius;
        light.shadow.camera.far = shadowRadius * 2;
        light.shadow.camera.updateProjectionMatrix();
        light.shadow.camera.updateMatrix();
        if (!isLastShadow) {
          currentDistance /= 3;
        }
      }
      this._isComputingShadows = false;
    });
  }
  /**
   * The getter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  get bias() {
    return this._bias;
  }
  /**
   * The setter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  set bias(value) {
    this._bias = value;
    for (const [, id] of this._lightsWithShadow) {
      const light = this.directionalLights.get(id);
      if (light) {
        light.shadow.bias = value;
      }
    }
  }
  /**
   * Getter to see whether the shadows are enabled or not in this scene instance.
   */
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Setter to control whether the shadows are enabled or not in this scene instance.
   */
  set shadowsEnabled(value) {
    this._shadowsEnabled = value;
    for (const [, light] of this.directionalLights) {
      light.castShadow = value;
    }
  }
  /**
   * Getter to get the renderer used to determine the farthest distance from the camera.
   */
  get distanceRenderer() {
    if (!this._distanceRenderer) {
      throw new Error(
        "You must set up this component before accessing the distance renderer!"
      );
    }
    return this._distanceRenderer;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    super.setup(config);
    const fullConfig = {
      ...this._defaultConfig,
      ...this._defaultShadowConfig,
      ...config
    };
    if (fullConfig.cascade <= 0) {
      throw new Error(
        "Config.shadows.cascade must be a natural number greater than 0!"
      );
    }
    if (fullConfig.cascade > 1) {
      throw new Error("Multiple shadows not supported yet!");
    }
    if (!this.currentWorld) {
      throw new Error(
        "A world needs to be assigned to the scene before setting it up!"
      );
    }
    for (const [, light] of this.directionalLights) {
      light.target.removeFromParent();
      light.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    if (!this._distanceRenderer) {
      this._distanceRenderer = new DistanceRenderer(
        this.components,
        this.currentWorld
      );
      this._distanceRenderer.onDistanceComputed.add(this.recomputeShadows);
    }
    this._lightsWithShadow.clear();
    for (let i = 0; i < fullConfig.cascade; i++) {
      const light = new DirectionalLight();
      light.intensity = this.config.directionalLight.intensity;
      light.color = this.config.directionalLight.color;
      light.position.copy(this.config.directionalLight.position);
      light.shadow.mapSize.width = fullConfig.resolution;
      light.shadow.mapSize.height = fullConfig.resolution;
      this.three.add(light, light.target);
      this.directionalLights.set(light.uuid, light);
      this._lightsWithShadow.set(i, light.uuid);
      light.castShadow = true;
      light.shadow.bias = this._bias;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    if (this._distanceRenderer) {
      this._distanceRenderer.dispose();
    }
    this._lightsWithShadow.clear();
  }
  /** Update all the shadows of the scene. */
  async updateShadows() {
    if (this._isComputingShadows || !this._shadowsEnabled) {
      return;
    }
    this._isComputingShadows = true;
    await this.distanceRenderer.compute();
  }
};
var Mouse = class {
  constructor(dom) {
    __publicField(this, "_event");
    __publicField(this, "_position", new Vector2());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "updateMouseInfo", (event) => {
      this._event = event;
    });
    this.dom = dom;
    this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const bounds = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(bounds, this._event);
      this._position.y = this.getPositionY(bounds, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  getPositionY(bound, event) {
    const data = this.getDataObject(event);
    return -((data.clientY - bound.top) / (bound.bottom - bound.top)) * 2 + 1;
  }
  getPositionX(bound, event) {
    const data = this.getDataObject(event);
    return (data.clientX - bound.left) / (bound.right - bound.left) * 2 - 1;
  }
  getDataObject(event) {
    return event instanceof MouseEvent ? event : event.touches[0];
  }
  setupEvents(active) {
    if (active) {
      this.dom.addEventListener("pointermove", this.updateMouseInfo);
      this.dom.addEventListener("touchstart", this.updateMouseInfo);
    } else {
      this.dom.removeEventListener("pointermove", this.updateMouseInfo);
      this.dom.removeEventListener("touchstart", this.updateMouseInfo);
    }
  }
};
var SimpleRaycaster = class {
  constructor(components, world) {
    __publicField(this, "enabled", true);
    __publicField(this, "components");
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "mouse");
    __publicField(this, "three", new Raycaster());
    __publicField(this, "world");
    const renderer = world.renderer;
    if (!renderer) {
      throw new Error("A renderer is needed for the raycaster to work!");
    }
    this.world = world;
    this.mouse = new Mouse(renderer.three.domElement);
    this.components = components;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  castRay(items = Array.from(this.world.meshes), position = this.mouse.position) {
    if (!this.world) {
      throw new Error("A world is needed to cast rays!");
    }
    const camera = this.world.camera.three;
    this.three.setFromCamera(position, camera);
    return this.intersect(items);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(origin, direction, items = Array.from(this.world.meshes)) {
    this.three.set(origin, direction);
    return this.intersect(items);
  }
  intersect(items = Array.from(this.world.meshes)) {
    const result = this.three.intersectObjects(items);
    const filtered = this.filterClippingPlanes(result);
    return filtered.length > 0 ? filtered[0] : null;
  }
  filterClippingPlanes(objs) {
    if (!this.world.renderer) {
      throw new Error("Renderer not found!");
    }
    const renderer = this.world.renderer.three;
    if (!renderer.clippingPlanes) {
      return objs;
    }
    const planes = renderer.clippingPlanes;
    if (objs.length <= 0 || !planes || (planes == null ? void 0 : planes.length) <= 0)
      return objs;
    return objs.filter(
      (elem) => planes.every((elem2) => elem2.distanceToPoint(elem.point) > 0)
    );
  }
};
var _Raycasters = class _Raycasters2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "list", /* @__PURE__ */ new Map());
    __publicField(this, "onDisposed", new Event());
    components.add(_Raycasters2.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const raycaster = new SimpleRaycaster(this.components, world);
    this.list.set(world.uuid, raycaster);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return raycaster;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(world) {
    const raycaster = this.list.get(world.uuid);
    if (raycaster) {
      raycaster.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, raycaster] of this.list) {
      raycaster.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
};
__publicField(_Raycasters, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var Raycasters = _Raycasters;
var SimpleGridConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: true,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: true,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(value) {
    this._config.color.value = value;
    this._component.material.uniforms.uColor.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(value) {
    this._config.primarySize.value = value;
    this._component.material.uniforms.uSize1.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(value) {
    this._config.secondarySize.value = value;
    this._component.material.uniforms.uSize2.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(value) {
    this._config.distance.value = value;
    this._component.material.uniforms.uDistance.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
};
var SimpleGrid = class {
  constructor(components, world) {
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "isSetup", false);
    __publicField(this, "world");
    __publicField(this, "components");
    __publicField(this, "config");
    __publicField(this, "_defaultConfig", {
      visible: true,
      color: new Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    });
    __publicField(this, "three");
    __publicField(this, "_fade", 3);
    __publicField(this, "updateZoom", () => {
      if (!(this.world.camera instanceof SimpleCamera)) {
        return;
      }
      this.material.uniforms.uZoom.value = this.world.camera.three.zoom;
    });
    this.world = world;
    const { color, primarySize, secondarySize, distance } = this._defaultConfig;
    this.components = components;
    this.config = new SimpleGridConfigManager(this, this.components, "Grid");
    const geometry = new PlaneGeometry(2, 2, 1, 1);
    const material = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: primarySize
        },
        uSize2: {
          value: secondarySize
        },
        uColor: {
          value: color
        },
        uDistance: {
          value: distance
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        // derivatives: true,
      }
    });
    this.three = new Mesh(geometry, material);
    this.three.frustumCulled = false;
    world.scene.three.add(this.three);
    this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(visible) {
    if (visible) {
      const scene = this.world.scene.three;
      scene.add(this.three);
    } else {
      this.three.removeFromParent();
    }
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(active) {
    this._fade = active ? 3 : 0;
    this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.visible = true;
    this.config.color = fullConfig.color;
    this.config.primarySize = fullConfig.primarySize;
    this.config.secondarySize = fullConfig.secondarySize;
    this.config.distance = fullConfig.distance;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    const disposer = this.components.get(Disposer);
    disposer.destroy(this.three);
    this.onDisposed.trigger();
    this.onDisposed.reset();
    this.world = null;
    this.components = null;
  }
  setupEvents(active) {
    if (this.world.isDisposing) {
      return;
    }
    if (!(this.world.camera instanceof SimpleCamera)) {
      return;
    }
    const controls = this.world.camera.controls;
    if (active) {
      controls.addEventListener("update", this.updateZoom);
    } else {
      controls.removeEventListener("update", this.updateZoom);
    }
  }
};
var _Grids = class _Grids2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "list", /* @__PURE__ */ new Map());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "enabled", true);
    components.add(_Grids2.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      throw new Error("This world already has a grid!");
    }
    const grid = new SimpleGrid(this.components, world);
    this.list.set(world.uuid, grid);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return grid;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(world) {
    const grid = this.list.get(world.uuid);
    if (grid) {
      grid.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, grid] of this.list) {
      grid.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
__publicField(_Grids, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var Grids = _Grids;
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown", mode: null };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(camera, domElement = null) {
    super(void 0, domElement);
    const root = new TransformControlsRoot(this);
    this._root = root;
    const gizmo = new TransformControlsGizmo();
    this._gizmo = gizmo;
    root.add(gizmo);
    const plane = new TransformControlsPlane();
    this._plane = plane;
    root.add(plane);
    const scope = this;
    function defineProperty(propName2, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName2, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            plane[propName2] = value;
            gizmo[propName2] = value;
            scope.dispatchEvent({ type: propName2 + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName2] = defaultValue;
      plane[propName2] = defaultValue;
      gizmo[propName2] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    defineProperty("minX", -Infinity);
    defineProperty("maxX", Infinity);
    defineProperty("minY", -Infinity);
    defineProperty("maxY", Infinity);
    defineProperty("minZ", -Infinity);
    defineProperty("maxZ", Infinity);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    if (domElement !== null) {
      this.connect(domElement);
    }
  }
  connect(element) {
    super.connect(element);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "auto";
  }
  /**
   * Returns the visual representation of the controls. Add the helper to your scene to
   * visually transform the attached  3D object.
   *
   * @return {TransformControlsRoot} The helper.
   */
  getHelper() {
    return this._root;
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0)
      return;
    if (this.axis !== null) {
      if (pointer !== null)
        _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
      object.position.x = Math.max(this.minX, Math.min(this.maxX, object.position.x));
      object.position.y = Math.max(this.minY, Math.min(this.maxY, object.position.y));
      object.position.z = Math.max(this.minZ, Math.min(this.maxZ, object.position.z));
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer !== null && pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.disconnect();
    this._root.dispose();
  }
  /**
   * Sets the 3D object that should be transformed and ensures the controls UI is visible.
   *
   * @param {Object3D} object -  The 3D object that should be transformed.
   * @return {TransformControls} A reference to this controls.
   */
  attach(object) {
    this.object = object;
    this._root.visible = true;
    return this;
  }
  /**
   * Removes the current 3D object from the controls and makes the helper UI invisible.
   *
   * @return {TransformControls} A reference to this controls.
   */
  detach() {
    this.object = void 0;
    this.axis = null;
    this._root.visible = false;
    return this;
  }
  /**
   * Resets the object's position, rotation and scale to when the current transform began.
   */
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  /**
   * Returns the raycaster that is used for user interaction. This object is shared between all
   * instances of `TransformControls`.
   *
   * @returns {Raycaster} The internal raycaster.
   */
  getRaycaster() {
    return _raycaster;
  }
  /**
   * Returns the transformation mode.
   *
   * @returns {'translate'|'rotate'|'scale'} The transformation mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the given transformation mode.
   *
   * @param {'translate'|'rotate'|'scale'} mode - The transformation mode to set.
   */
  setMode(mode) {
    this.mode = mode;
  }
  /**
   * Sets the translation snap.
   *
   * @param {?number} translationSnap - The translation snap to set.
   */
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  /**
   * Sets the rotation snap.
   *
   * @param {?number} rotationSnap - The rotation snap to set.
   */
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  /**
   * Sets the scale snap.
   *
   * @param {?number} scaleSnap - The scale snap to set.
   */
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  /**
   * Sets the size of the helper UI.
   *
   * @param {number} size - The size to set.
   */
  setSize(size) {
    this.size = size;
  }
  /**
   * Sets the coordinate space in which transformations are applied.
   *
   * @param {'world'|'local'} space - The space to set.
   */
  setSpace(space) {
    this.space = space;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsRoot = class extends Object3D {
  constructor(controls) {
    super();
    this.isTransformControlsRoot = true;
    this.controls = controls;
    this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(force) {
    const controls = this.controls;
    if (controls.object !== void 0) {
      controls.object.updateMatrixWorld();
      if (controls.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        controls.object.parent.matrixWorld.decompose(controls._parentPosition, controls._parentQuaternion, controls._parentScale);
      }
      controls.object.matrixWorld.decompose(controls.worldPosition, controls.worldQuaternion, controls._worldScale);
      controls._parentQuaternionInv.copy(controls._parentQuaternion).invert();
      controls._worldQuaternionInv.copy(controls.worldQuaternion).invert();
    }
    controls.camera.updateMatrixWorld();
    controls.camera.matrixWorld.decompose(controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale);
    if (controls.camera.isOrthographicCamera) {
      controls.camera.getWorldDirection(controls.eye).negate();
    } else {
      controls.eye.copy(controls.cameraPosition).sub(controls.worldPosition).normalize();
    }
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
};
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};
var SimplePlane = class _SimplePlane {
  constructor(components, world, origin, normal, material, size = 5, activateControls = true) {
    __publicField(this, "onDraggingStarted", new Event());
    __publicField(this, "onDraggingEnded", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "normal");
    __publicField(this, "origin");
    __publicField(this, "three", new Plane());
    __publicField(this, "components");
    __publicField(this, "world");
    __publicField(this, "type", "default");
    __publicField(this, "_helper");
    __publicField(this, "_visible", true);
    __publicField(this, "_enabled", true);
    __publicField(this, "_controlsActive", false);
    __publicField(this, "_arrowBoundBox", new Mesh());
    __publicField(this, "_planeMesh");
    __publicField(this, "_controls");
    __publicField(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    }));
    __publicField(this, "update", () => {
      if (!this._enabled)
        return;
      this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    __publicField(this, "changeDrag", (event) => {
      this._visible = !event.value;
      this.preventCameraMovement();
      this.notifyDraggingChanged(event);
    });
    this.components = components;
    this.world = world;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.normal = normal;
    this.origin = origin;
    world.renderer.setPlane(true, this.three);
    this._planeMesh = _SimplePlane.newPlaneMesh(size, material);
    this._helper = this.newHelper();
    this._controls = this.newTransformControls();
    this.three.setFromNormalAndCoplanarPoint(normal, origin);
    if (activateControls) {
      this.toggleControls(true);
    }
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(state) {
    if (this.world.isDisposing) {
      return;
    }
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    this._enabled = state;
    this.world.renderer.setPlane(state, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    this._controls.object.visible = state;
    this._helper.visible = state;
    this.toggleControls(state);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(material) {
    this._planeMesh.material = material;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(size) {
    this._planeMesh.scale.set(size, size, size);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(normal, point) {
    this.reset();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
    this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    this.onDraggingStarted.reset();
    this.onDraggingEnded.reset();
    this._helper.removeFromParent();
    if (this.world.renderer) {
      this.world.renderer.setPlane(false, this.three);
    }
    this._arrowBoundBox.removeFromParent();
    this._arrowBoundBox.geometry.dispose();
    this._planeMesh.geometry.dispose();
    this._controls.object.removeFromParent();
    this._controls.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  reset() {
    const normal = new Vector3(1, 0, 0);
    const point = new Vector3();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
  }
  toggleControls(state) {
    if (state) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update);
      this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else {
      this._controls.removeEventListener("change", this.update);
      this._controls.removeEventListener("dragging-changed", this.changeDrag);
    }
    this._controlsActive = state;
  }
  newTransformControls() {
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    const camera = this.world.camera.three;
    const container = this.world.renderer.three.domElement;
    const controls = new TransformControls(camera, container);
    this.initializeControls(controls);
    this.world.scene.three.add(controls.object);
    return controls;
  }
  initializeControls(controls) {
    controls.attach(this._helper);
    controls.showX = false;
    controls.showY = false;
    controls.setSpace("local");
    this.createArrowBoundingBox();
    controls.object.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2);
    this._arrowBoundBox.material = this._hiddenMaterial;
    this._arrowBoundBox.rotateX(Math.PI / 2);
    this._arrowBoundBox.updateMatrix();
    this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(event) {
    if (event.value) {
      this.onDraggingStarted.trigger();
    } else {
      this.onDraggingEnded.trigger();
    }
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const helper = new Object3D();
    helper.lookAt(this.normal);
    helper.position.copy(this.origin);
    this._planeMesh.position.z += 0.01;
    helper.add(this._planeMesh);
    this.world.scene.three.add(helper);
    return helper;
  }
  static newPlaneMesh(size, material) {
    const planeGeom = new PlaneGeometry(1);
    const mesh = new Mesh(planeGeom, material);
    mesh.scale.set(size, size, size);
    return mesh;
  }
};
var ClipperConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      opacity: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      size: {
        type: "Number",
        interpolable: true,
        value: 2,
        min: 0,
        max: 100
      }
    });
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(value) {
    this._config.enabled.value = value;
    this._component.enabled = value;
  }
  get visible() {
    return this._config.visible.value;
  }
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  get color() {
    return this._config.color.value;
  }
  set color(value) {
    this._config.color.value = value;
    this._component.material.color.copy(value);
  }
  get opacity() {
    return this._config.opacity.value;
  }
  set opacity(value) {
    this._config.opacity.value = value;
    this._component.material.opacity = value;
  }
  get size() {
    return this._config.size.value;
  }
  set size(value) {
    this._config.size.value = value;
    this._component.size = value;
  }
};
var _Clipper = class _Clipper2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onSetup", new Event());
    __publicField(this, "onBeforeDrag", new Event());
    __publicField(this, "onAfterDrag", new Event());
    __publicField(this, "onBeforeCreate", new Event());
    __publicField(this, "onBeforeCancel", new Event());
    __publicField(this, "onAfterCancel", new Event());
    __publicField(this, "onBeforeDelete", new Event());
    __publicField(this, "onAfterCreate", new Event());
    __publicField(this, "onAfterDelete", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "isSetup", false);
    __publicField(this, "orthogonalY", false);
    __publicField(this, "toleranceOrthogonalY", 0.7);
    __publicField(this, "Type", SimplePlane);
    __publicField(this, "list", []);
    __publicField(this, "config", new ClipperConfigManager(
      this,
      this.components,
      "Clipper",
      _Clipper2.uuid
    ));
    __publicField(this, "_defaultConfig", {
      color: new Color(12255487),
      opacity: 0.2,
      size: 2
    });
    __publicField(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    __publicField(this, "_size", 5);
    __publicField(this, "_enabled", false);
    __publicField(this, "_visible", true);
    __publicField(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    __publicField(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(_Clipper2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(state) {
    this._enabled = state;
    for (const plane of this.list) {
      plane.enabled = state;
    }
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    for (const plane of this.list) {
      plane.visible = state;
    }
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(material) {
    this._material = material;
    for (const plane of this.list) {
      plane.planeMaterial = material;
    }
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(size) {
    this._size = size;
    for (const plane of this.list) {
      plane.size = size;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    for (const plane of this.list) {
      plane.dispose();
    }
    this.list.length = 0;
    this._material.dispose();
    this.onBeforeCreate.reset();
    this.onBeforeCancel.reset();
    this.onBeforeDelete.reset();
    this.onBeforeDrag.reset();
    this.onAfterCreate.reset();
    this.onAfterCancel.reset();
    this.onAfterDelete.reset();
    this.onAfterDrag.reset();
    this.onDisposed.trigger(_Clipper2.uuid);
    this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects2 = caster.castRay();
    if (intersects2) {
      return this.createPlaneFromIntersection(world, intersects2);
    }
    return null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(world, normal, point) {
    const plane = this.newPlane(world, point, normal);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(world, plane) {
    if (!plane) {
      plane = this.pickPlane(world);
    }
    if (!plane) {
      return;
    }
    this.deletePlane(plane);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(types) {
    const planes = [...this.list];
    for (const plane of planes) {
      if (!types || types.has(plane.type)) {
        this.delete(plane.world, plane);
        const index = this.list.indexOf(plane);
        if (index !== -1) {
          this.list.splice(index, 1);
        }
      }
    }
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.color = fullConfig.color;
    this.config.opacity = fullConfig.opacity;
    this.config.size = fullConfig.size;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  deletePlane(plane) {
    const index = this.list.indexOf(plane);
    if (index !== -1) {
      this.list.splice(index, 1);
      if (!plane.world.renderer) {
        throw new Error("Renderer not found for this plane's world!");
      }
      plane.world.renderer.setPlane(false, plane.three);
      plane.dispose();
      this.updateMaterialsAndPlanes();
      this.onAfterDelete.trigger(plane);
    }
  }
  pickPlane(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const meshes = this.getAllPlaneMeshes();
    const intersects2 = caster.castRay(meshes);
    if (intersects2) {
      const found = intersects2.object;
      return this.list.find((p) => p.meshes.includes(found));
    }
    return void 0;
  }
  getAllPlaneMeshes() {
    const meshes = [];
    for (const plane of this.list) {
      meshes.push(...plane.meshes);
    }
    return meshes;
  }
  createPlaneFromIntersection(world, intersect) {
    var _a22;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    const constant = intersect.point.distanceTo(new Vector3(0, 0, 0));
    const normal = (_a22 = intersect.face) == null ? void 0 : _a22.normal;
    if (!constant || !normal) {
      return null;
    }
    const worldNormal = this.getWorldNormal(intersect, normal);
    const plane = this.newPlane(world, intersect.point, worldNormal.negate());
    plane.visible = this._visible;
    plane.size = this._size;
    world.renderer.setPlane(true, plane.three);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  getWorldNormal(intersect, normal) {
    const object = intersect.object;
    let transform = intersect.object.matrixWorld.clone();
    const isInstance = object instanceof InstancedMesh;
    if (isInstance && intersect.instanceId !== void 0) {
      const temp5 = new Matrix4();
      object.getMatrixAt(intersect.instanceId, temp5);
      transform = temp5.multiply(transform);
    }
    const normalMatrix = new Matrix3().getNormalMatrix(transform);
    const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();
    this.normalizePlaneDirectionY(worldNormal);
    return worldNormal;
  }
  normalizePlaneDirectionY(normal) {
    if (this.orthogonalY) {
      if (normal.y > this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = 1;
        normal.z = 0;
      }
      if (normal.y < -this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = -1;
        normal.z = 0;
      }
    }
  }
  newPlane(world, point, normal) {
    const plane = new this.Type(
      this.components,
      world,
      point,
      normal,
      this._material
    );
    plane.onDraggingStarted.add(this._onStartDragging);
    plane.onDraggingEnded.add(this._onEndDragging);
    this.list.push(plane);
    this.onAfterCreate.trigger(plane);
    return plane;
  }
  updateMaterialsAndPlanes() {
    const worlds = this.components.get(Worlds);
    for (const [_id, world] of worlds.list) {
      if (!world.renderer) {
        continue;
      }
      world.renderer.updateClippingPlanes();
      const { clippingPlanes } = world.renderer;
      for (const model of world.meshes) {
        if (!model.material) {
          continue;
        }
        if (Array.isArray(model.material)) {
          for (const mat of model.material) {
            mat.clippingPlanes = clippingPlanes;
          }
        } else {
          model.material.clippingPlanes = clippingPlanes;
        }
      }
    }
  }
};
__publicField(_Clipper, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Clipper = _Clipper;
var FirstPersonMode = class {
  constructor(camera) {
    __publicField(this, "enabled", false);
    __publicField(this, "id", "FirstPerson");
    this.camera = camera;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      const projection = this.camera.projection.current;
      if (projection !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const controls = this.camera.controls;
    const newTargetPosition = new Vector3();
    controls.distance--;
    controls.getPosition(newTargetPosition);
    controls.minDistance = 1;
    controls.maxDistance = 1;
    controls.distance = 1;
    controls.moveTo(
      newTargetPosition.x,
      newTargetPosition.y,
      newTargetPosition.z
    );
    controls.truckSpeed = 50;
    controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var OrbitMode = class {
  constructor(camera) {
    __publicField(this, "enabled", true);
    __publicField(this, "id", "Orbit");
    this.camera = camera;
    this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      this.activateOrbitControls();
    }
  }
  activateOrbitControls() {
    const controls = this.camera.controls;
    controls.minDistance = 1;
    controls.maxDistance = 300;
    const position = new Vector3();
    controls.getPosition(position);
    const distance = position.length();
    controls.distance = distance;
    controls.truckSpeed = 2;
    const { rotation } = this.camera.three;
    const direction = new Vector3(0, 0, -1).applyEuler(rotation);
    const target = position.addScaledVector(direction, distance);
    controls.moveTo(target.x, target.y, target.z);
  }
};
var PlanMode = class {
  constructor(camera) {
    __publicField(this, "enabled", false);
    __publicField(this, "id", "Plan");
    __publicField(this, "mouseAction1");
    __publicField(this, "mouseAction2");
    __publicField(this, "mouseInitialized", false);
    __publicField(this, "defaultAzimuthSpeed");
    __publicField(this, "defaultPolarSpeed");
    this.camera = camera;
    this.defaultAzimuthSpeed = camera.controls.azimuthRotateSpeed;
    this.defaultPolarSpeed = camera.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    const controls = this.camera.controls;
    controls.azimuthRotateSpeed = active ? 0 : this.defaultAzimuthSpeed;
    controls.polarRotateSpeed = active ? 0 : this.defaultPolarSpeed;
    if (!this.mouseInitialized) {
      this.mouseAction1 = controls.touches.one;
      this.mouseAction2 = controls.touches.two;
      this.mouseInitialized = true;
    }
    if (active) {
      controls.mouseButtons.left = CameraControls.ACTION.TRUCK;
      controls.touches.one = CameraControls.ACTION.TOUCH_TRUCK;
      controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM;
    } else {
      controls.mouseButtons.left = CameraControls.ACTION.ROTATE;
      controls.touches.one = this.mouseAction1;
      controls.touches.two = this.mouseAction2;
    }
  }
};
var ProjectionManager = class {
  constructor(camera) {
    __publicField(this, "onChanged", new Event());
    __publicField(this, "current", "Perspective");
    __publicField(this, "camera");
    __publicField(this, "matchOrthoDistanceEnabled", false);
    __publicField(this, "_component");
    __publicField(this, "_previousDistance", -1);
    this._component = camera;
    this.camera = camera.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(projection) {
    if (this.current === projection)
      return;
    if (projection === "Orthographic") {
      this.setOrthoCamera();
    } else {
      await this.setPerspectiveCamera();
    }
    this.onChanged.trigger(this.camera);
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const isPerspective = this.current === "Perspective";
    const target = isPerspective ? "Orthographic" : "Perspective";
    await this.set(target);
  }
  setOrthoCamera() {
    if (this._component.mode === null)
      return;
    if (this._component.mode.id === "FirstPerson") {
      return;
    }
    this._previousDistance = this._component.controls.distance;
    this._component.controls.distance = 200;
    const dims = this.getPerspectiveDims();
    if (!dims) {
      return;
    }
    const { width, height } = dims;
    this.setupOrthoCamera(height, width);
    this.camera = this._component.threeOrtho;
    this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const world = this._component.currentWorld;
    if (!world || !world.renderer) {
      return null;
    }
    const lineOfSight = new Vector3();
    this._component.threePersp.getWorldDirection(lineOfSight);
    const target = new Vector3();
    this._component.controls.getTarget(target);
    const distance = target.clone().sub(this._component.threePersp.position);
    const depth = distance.dot(lineOfSight);
    const dims = world.renderer.getSize();
    const aspect = dims.x / dims.y;
    const camera = this._component.threePersp;
    const height = depth * 2 * Math.atan(camera.fov * (Math.PI / 180) / 2);
    const width = height * aspect;
    return { width, height };
  }
  setupOrthoCamera(height, width) {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.ZOOM;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.ZOOM;
    this._component.controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
    this._component.controls.touches.three = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
    this._component.controls.dollySpeed = 5;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    oCamera.zoom = 1;
    oCamera.left = width / -2;
    oCamera.right = width / 2;
    oCamera.top = height / 2;
    oCamera.bottom = height / -2;
    oCamera.updateProjectionMatrix();
    oCamera.position.copy(pCamera.position);
    oCamera.quaternion.copy(pCamera.quaternion);
    this._component.controls.camera = oCamera;
  }
  getDistance() {
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    const depth = (oCamera.top - oCamera.bottom) / oCamera.zoom / (2 * Math.atan(pCamera.fov * (Math.PI / 180) / 2));
    return depth;
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.DOLLY;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    pCamera.position.copy(oCamera.position);
    pCamera.quaternion.copy(oCamera.quaternion);
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._component.controls.touches.two = CameraControls.ACTION.TOUCH_DOLLY_TRUCK;
    this._component.controls.touches.three = CameraControls.ACTION.TOUCH_DOLLY_TRUCK;
    this._component.controls.dollySpeed = 5;
    if (this.matchOrthoDistanceEnabled) {
      this._component.controls.distance = this.getDistance();
    } else {
      this._component.controls.distance = this._previousDistance;
    }
    await this._component.controls.zoomTo(1);
    pCamera.updateProjectionMatrix();
    this._component.controls.camera = pCamera;
    this.camera = pCamera;
    this.current = "Perspective";
  }
};
var OrthoPerspectiveCamera = class extends SimpleCamera {
  constructor(components) {
    super(components);
    __publicField(this, "projection");
    __publicField(this, "threeOrtho");
    __publicField(this, "threePersp");
    __publicField(this, "_userInputButtons", {});
    __publicField(this, "_frustumSize", 50);
    __publicField(this, "_navigationModes", /* @__PURE__ */ new Map());
    __publicField(this, "_mode", null);
    __publicField(this, "previousSize", null);
    this.threePersp = this.three;
    this.threeOrtho = this.newOrthoCamera();
    this.projection = new ProjectionManager(this);
    this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    });
    this.projection.onChanged.add(
      (camera) => {
        this.three = camera;
        this.updateAspect();
      }
    );
    this.onWorldChanged.add(({ action }) => {
      if (action === "added") {
        this._navigationModes.clear();
        this._navigationModes.set("Orbit", new OrbitMode(this));
        this._navigationModes.set("FirstPerson", new FirstPersonMode(this));
        this._navigationModes.set("Plan", new PlanMode(this));
        this._mode = this._navigationModes.get("Orbit");
        this.mode.set(true, { preventTargetAdjustment: true });
        if (this.currentWorld && this.currentWorld.renderer) {
          this.previousSize = this.currentWorld.renderer.getSize().clone();
        }
      }
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode) {
      throw new Error("Mode not found, camera not initialized");
    }
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(mode) {
    if (this.mode === null)
      return;
    if (this.mode.id === mode)
      return;
    this.mode.set(false);
    if (!this._navigationModes.has(mode)) {
      throw new Error("The specified mode does not exist!");
    }
    this._mode = this._navigationModes.get(mode);
    this.mode.set(true);
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(meshes, offset = 1.5) {
    if (!this.enabled)
      return;
    const maxNum = Number.MAX_VALUE;
    const minNum = Number.MIN_VALUE;
    const min = new Vector3(maxNum, maxNum, maxNum);
    const max = new Vector3(minNum, minNum, minNum);
    for (const mesh of meshes) {
      const box2 = new Box3().setFromObject(mesh);
      if (box2.min.x < min.x)
        min.x = box2.min.x;
      if (box2.min.y < min.y)
        min.y = box2.min.y;
      if (box2.min.z < min.z)
        min.z = box2.min.z;
      if (box2.max.x > max.x)
        max.x = box2.max.x;
      if (box2.max.y > max.y)
        max.y = box2.max.y;
      if (box2.max.z > max.z)
        max.z = box2.max.z;
    }
    const box = new Box3(min, max);
    const sceneSize = new Vector3();
    box.getSize(sceneSize);
    const sceneCenter = new Vector3();
    box.getCenter(sceneCenter);
    const radius = Math.max(sceneSize.x, sceneSize.y, sceneSize.z) * offset;
    const sphere = new Sphere(sceneCenter, radius);
    await this.controls.fitToSphere(sphere, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(active) {
    if (active) {
      this.enableUserInput();
    } else {
      this.disableUserInput();
    }
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left;
    this._userInputButtons.right = this.controls.mouseButtons.right;
    this._userInputButtons.middle = this.controls.mouseButtons.middle;
    this._userInputButtons.wheel = this.controls.mouseButtons.wheel;
    this.controls.mouseButtons.left = 0;
    this.controls.mouseButtons.right = 0;
    this.controls.mouseButtons.middle = 0;
    this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    if (Object.keys(this._userInputButtons).length === 0)
      return;
    this.controls.mouseButtons.left = this._userInputButtons.left;
    this.controls.mouseButtons.right = this._userInputButtons.right;
    this.controls.mouseButtons.middle = this._userInputButtons.middle;
    this.controls.mouseButtons.wheel = this._userInputButtons.wheel;
  }
  newOrthoCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * aspect / -2,
      this._frustumSize * aspect / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer) {
      return;
    }
    if (!this.previousSize)
      return;
    const size = this.currentWorld.renderer.getSize();
    const previousHeight = this.threeOrtho.top;
    const previousWidth = this.threeOrtho.right;
    const heightSizeFactor = size.y / this.previousSize.y;
    const widthSizeFactor = size.x / this.previousSize.x;
    const newHeight = previousHeight * heightSizeFactor;
    const newWidth = previousWidth * widthSizeFactor;
    this.threeOrtho.left = -newWidth;
    this.threeOrtho.right = newWidth;
    this.threeOrtho.top = newHeight;
    this.threeOrtho.bottom = -newHeight;
    this.threeOrtho.updateProjectionMatrix();
    this.previousSize.copy(size);
  }
};
var relToAttributesMap = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelated: "Decomposes",
      forRelating: "IsDecomposedBy"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelated: "HasAssociations",
      forRelating: "AssociatedTo"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelated: "HasAssociations",
      forRelating: "ClassificationForObjects"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelated: "HasAssignments",
      forRelating: "IsGroupedBy"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ],
  [
    IFCRELFLOWCONTROLELEMENTS,
    {
      forRelated: "AssignedToFlowElement",
      forRelating: "HasControlElements"
    }
  ],
  [
    IFCRELCONNECTSELEMENTS,
    {
      forRelated: "ConnectedFrom",
      forRelating: "ConnectedTo"
    }
  ],
  [
    IFCRELASSIGNSTOPRODUCT,
    {
      forRelated: "HasAssignments",
      forRelating: "ReferencedBy"
    }
  ],
  [
    IFCRELDECLARES,
    {
      forRelated: "HasContext",
      forRelating: "Declares"
    }
  ],
  [
    IFCRELASSIGNSTOCONTROL,
    {
      forRelated: "HasAssignments",
      forRelating: "Controls"
    }
  ],
  [
    IFCRELNESTS,
    {
      forRelated: "Nests",
      forRelating: "IsNestedBy"
    }
  ],
  [
    IFCRELASSOCIATESDOCUMENT,
    {
      forRelated: "HasAssociations",
      forRelating: "DocumentRefForObjects"
    }
  ]
]);
var IfcElements = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var IfcCategories = class {
  getAll(webIfc, modelID) {
    const elementsCategories = {};
    const categoriesIDs = Object.keys(IfcElements).map((e2) => parseInt(e2, 10));
    for (let i = 0; i < categoriesIDs.length; i++) {
      const element = categoriesIDs[i];
      const lines = webIfc.GetLineIDsWithType(modelID, element);
      const size = lines.size();
      for (let i2 = 0; i2 < size; i2++) {
        elementsCategories[lines.get(i2)] = element;
      }
    }
    return elementsCategories;
  }
};
var IfcCategoryMap = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var IfcPropertiesUtils = class _IfcPropertiesUtils {
  static async getUnits(group) {
    var _a22, _b, _c2;
    const { IFCUNITASSIGNMENT: IFCUNITASSIGNMENT2 } = web_ifc_api_exports;
    const allUnitsSets = await group.getAllPropertiesOfType(IFCUNITASSIGNMENT2);
    if (!allUnitsSets) {
      return 1;
    }
    const unitIDs = Object.keys(allUnitsSets);
    const allUnits = allUnitsSets[parseInt(unitIDs[0], 10)];
    for (const unitRef of allUnits.Units) {
      if (unitRef.value === void 0 || unitRef.value === null)
        continue;
      const unit = await group.getProperties(unitRef.value);
      if (!unit || !unit.UnitType || !unit.UnitType.value) {
        continue;
      }
      const value = unit.UnitType.value;
      if (value !== "LENGTHUNIT")
        continue;
      let factor = 1;
      let unitValue = 1;
      if (unit.Name.value === "METRE") {
        unitValue = 1;
      }
      if (unit.Name.value === "FOOT") {
        unitValue = 0.3048;
      }
      if (((_a22 = unit.Prefix) == null ? void 0 : _a22.value) === "MILLI") {
        factor = 1e-3;
      } else if (((_b = unit.Prefix) == null ? void 0 : _b.value) === "CENTI") {
        factor = 0.01;
      } else if (((_c2 = unit.Prefix) == null ? void 0 : _c2.value) === "DECI") {
        factor = 0.1;
      }
      return unitValue * factor;
    }
    return 1;
  }
  static async findItemByGuid(model, guid) {
    var _a22;
    const ids = model.getAllPropertiesIDs();
    for (const id of ids) {
      const property = await model.getProperties(id);
      if (property && ((_a22 = property.GlobalId) == null ? void 0 : _a22.value) === guid) {
        return property;
      }
    }
    return null;
  }
  static async getRelationMap(model, relationType, onElementsFound) {
    var _a22;
    const defaultCallback = async () => {
    };
    const _onElementsFound = onElementsFound ?? defaultCallback;
    const result = {};
    const ids = model.getAllPropertiesIDs();
    for (const expressID of ids) {
      const prop = await model.getProperties(expressID);
      if (!prop) {
        continue;
      }
      const isRelation = prop.type === relationType;
      const relatingKey = Object.keys(prop).find(
        (key) => key.startsWith("Relating")
      );
      const relatedKey = Object.keys(prop).find(
        (key) => key.startsWith("Related")
      );
      if (!(isRelation && relatingKey && relatedKey))
        continue;
      const relating = await model.getProperties((_a22 = prop[relatingKey]) == null ? void 0 : _a22.value);
      const related = prop[relatedKey];
      if (!relating || !related) {
        continue;
      }
      if (!(related && Array.isArray(related)))
        continue;
      const elements = related.map((el) => {
        return el.value;
      });
      await _onElementsFound(relating.expressID, elements);
      result[relating.expressID] = elements;
    }
    return result;
  }
  static async getQsetQuantities(model, expressID, onQuantityFound) {
    const defaultCallback = () => {
    };
    const _onQuantityFound = onQuantityFound ?? defaultCallback;
    const pset = await model.getProperties(expressID);
    if (!pset || pset.type !== IFCELEMENTQUANTITY) {
      return null;
    }
    const quantities = pset.Quantities ?? [{}];
    const qtos = quantities.map((prop) => {
      if (prop.value)
        _onQuantityFound(prop.value);
      return prop.value;
    });
    return qtos.filter((prop) => prop !== null);
  }
  static async getPsetProps(model, expressID, onPropFound) {
    const defaultCallback = () => {
    };
    const _onPropFound = onPropFound ?? defaultCallback;
    const pset = await model.getProperties(expressID);
    if (!pset || pset.type !== IFCPROPERTYSET) {
      return null;
    }
    const hasProperties = pset.HasProperties ?? [{}];
    const props = hasProperties.map((prop) => {
      if (prop.value)
        _onPropFound(prop.value);
      return prop.value;
    });
    return props.filter((prop) => prop !== null);
  }
  static async getPsetRel(model, psetID) {
    var _a22;
    const prop = await model.getProperties(psetID);
    if (!prop) {
      return null;
    }
    const allPropsRels = await model.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!allPropsRels) {
      return null;
    }
    const allRels = Object.values(allPropsRels);
    let found = null;
    for (const rel of allRels) {
      if (((_a22 = rel.RelatingPropertyDefinition) == null ? void 0 : _a22.value) === psetID) {
        found = rel.expressID;
      }
    }
    return found;
  }
  static async getQsetRel(model, qsetID) {
    return _IfcPropertiesUtils.getPsetRel(model, qsetID);
  }
  static async getEntityName(model, entityID) {
    var _a22;
    const entity = await model.getProperties(entityID);
    if (!entity) {
      return { key: null, name: null };
    }
    const key = Object.keys(entity).find((key2) => key2.endsWith("Name")) ?? null;
    const name = key ? (_a22 = entity[key]) == null ? void 0 : _a22.value : null;
    return { key, name };
  }
  static async getQuantityValue(model, quantityID) {
    const quantity = await model.getProperties(quantityID);
    if (!quantity) {
      return { key: null, value: null };
    }
    const key = Object.keys(quantity).find((key2) => key2.endsWith("Value")) ?? null;
    let value;
    if (key === null) {
      value = null;
    } else if (quantity[key] === void 0 || quantity[key] === null) {
      value = null;
    } else {
      value = quantity[key].value;
    }
    return { key, value };
  }
  static isRel(expressID) {
    const entityName2 = IfcCategoryMap[expressID];
    return entityName2.startsWith("IFCREL");
  }
  static async attributeExists(model, expressID, attribute) {
    const entity = await model.getProperties(expressID);
    if (!entity) {
      return false;
    }
    return Object.keys(entity).includes(attribute);
  }
  static async groupEntitiesByType(model, expressIDs) {
    var _a22;
    const categoriesMap = /* @__PURE__ */ new Map();
    for (const expressID of expressIDs) {
      const entity = await model.getProperties(expressID);
      if (!entity) {
        continue;
      }
      const key = entity.type;
      const set = categoriesMap.get(key);
      if (!set)
        categoriesMap.set(key, /* @__PURE__ */ new Set());
      (_a22 = categoriesMap.get(key)) == null ? void 0 : _a22.add(expressID);
    }
    return categoriesMap;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var ifcCategoryCase = {
  IFCURIREFERENCE: "IfcUriReference",
  IFCTIME: "IfcTime",
  IFCTEMPERATURERATEOFCHANGEMEASURE: "IfcTemperatureRateOfChangeMeasure",
  IFCSOUNDPRESSURELEVELMEASURE: "IfcSoundPressureLevelMeasure",
  IFCSOUNDPOWERLEVELMEASURE: "IfcSoundPowerLevelMeasure",
  IFCPROPERTYSETDEFINITIONSET: "IfcPropertySetDefinitionSet",
  IFCPOSITIVEINTEGER: "IfcPositiveInteger",
  IFCNONNEGATIVELENGTHMEASURE: "IfcNonNegativeLengthMeasure",
  IFCLINEINDEX: "IfcLineIndex",
  IFCLANGUAGEID: "IfcLanguageId",
  IFCDURATION: "IfcDuration",
  IFCDAYINWEEKNUMBER: "IfcDayInWeekNumber",
  IFCDATETIME: "IfcDateTime",
  IFCDATE: "IfcDate",
  IFCCARDINALPOINTREFERENCE: "IfcCardinalPointReference",
  IFCBINARY: "IfcBinary",
  IFCAREADENSITYMEASURE: "IfcAreaDensityMeasure",
  IFCARCINDEX: "IfcArcIndex",
  IFCYEARNUMBER: "IfcYearNumber",
  IFCWARPINGMOMENTMEASURE: "IfcWarpingMomentMeasure",
  IFCWARPINGCONSTANTMEASURE: "IfcWarpingConstantMeasure",
  IFCVOLUMETRICFLOWRATEMEASURE: "IfcVolumetricFlowRateMeasure",
  IFCVOLUMEMEASURE: "IfcVolumeMeasure",
  IFCVAPORPERMEABILITYMEASURE: "IfcVaporPermeabilityMeasure",
  IFCTORQUEMEASURE: "IfcTorqueMeasure",
  IFCTIMESTAMP: "IfcTimestamp",
  IFCTIMEMEASURE: "IfcTimeMeasure",
  IFCTHERMODYNAMICTEMPERATUREMEASURE: "IfcThermodynamicTemperatureMeasure",
  IFCTHERMALTRANSMITTANCEMEASURE: "IfcThermalTransmittanceMeasure",
  IFCTHERMALRESISTANCEMEASURE: "IfcThermalResistanceMeasure",
  IFCTHERMALEXPANSIONCOEFFICIENTMEASURE: "IfcThermalExpansionCoefficientMeasure",
  IFCTHERMALCONDUCTIVITYMEASURE: "IfcThermalConductivityMeasure",
  IFCTHERMALADMITTANCEMEASURE: "IfcThermalAdmittanceMeasure",
  IFCTEXTTRANSFORMATION: "IfcTextTransformation",
  IFCTEXTFONTNAME: "IfcTextFontName",
  IFCTEXTDECORATION: "IfcTextDecoration",
  IFCTEXTALIGNMENT: "IfcTextAlignment",
  IFCTEXT: "IfcText",
  IFCTEMPERATUREGRADIENTMEASURE: "IfcTemperatureGradientMeasure",
  IFCSPECULARROUGHNESS: "IfcSpecularRoughness",
  IFCSPECULAREXPONENT: "IfcSpecularExponent",
  IFCSPECIFICHEATCAPACITYMEASURE: "IfcSpecificHeatCapacityMeasure",
  IFCSOUNDPRESSUREMEASURE: "IfcSoundPressureMeasure",
  IFCSOUNDPOWERMEASURE: "IfcSoundPowerMeasure",
  IFCSOLIDANGLEMEASURE: "IfcSolidAngleMeasure",
  IFCSHEARMODULUSMEASURE: "IfcShearModulusMeasure",
  IFCSECTIONALAREAINTEGRALMEASURE: "IfcSectionalAreaIntegralMeasure",
  IFCSECTIONMODULUSMEASURE: "IfcSectionModulusMeasure",
  IFCSECONDINMINUTE: "IfcSecondInMinute",
  IFCROTATIONALSTIFFNESSMEASURE: "IfcRotationalStiffnessMeasure",
  IFCROTATIONALMASSMEASURE: "IfcRotationalMassMeasure",
  IFCROTATIONALFREQUENCYMEASURE: "IfcRotationalFrequencyMeasure",
  IFCREAL: "IfcReal",
  IFCRATIOMEASURE: "IfcRatioMeasure",
  IFCRADIOACTIVITYMEASURE: "IfcRadioactivityMeasure",
  IFCPRESSUREMEASURE: "IfcPressureMeasure",
  IFCPRESENTABLETEXT: "IfcPresentableText",
  IFCPOWERMEASURE: "IfcPowerMeasure",
  IFCPOSITIVERATIOMEASURE: "IfcPositiveRatioMeasure",
  IFCPOSITIVEPLANEANGLEMEASURE: "IfcPositivePlaneAngleMeasure",
  IFCPOSITIVELENGTHMEASURE: "IfcPositiveLengthMeasure",
  IFCPLANEANGLEMEASURE: "IfcPlaneAngleMeasure",
  IFCPLANARFORCEMEASURE: "IfcPlanarForceMeasure",
  IFCPARAMETERVALUE: "IfcParameterValue",
  IFCPHMEASURE: "IfcPhMeasure",
  IFCNUMERICMEASURE: "IfcNumericMeasure",
  IFCNORMALISEDRATIOMEASURE: "IfcNormalisedRatioMeasure",
  IFCMONTHINYEARNUMBER: "IfcMonthInYearNumber",
  IFCMONETARYMEASURE: "IfcMonetaryMeasure",
  IFCMOMENTOFINERTIAMEASURE: "IfcMomentOfInertiaMeasure",
  IFCMOLECULARWEIGHTMEASURE: "IfcMolecularWeightMeasure",
  IFCMOISTUREDIFFUSIVITYMEASURE: "IfcMoistureDiffusivityMeasure",
  IFCMODULUSOFSUBGRADEREACTIONMEASURE: "IfcModulusOfSubgradeReactionMeasure",
  IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE: "IfcModulusOfRotationalSubgradeReactionMeasure",
  IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE: "IfcModulusOfLinearSubgradeReactionMeasure",
  IFCMODULUSOFELASTICITYMEASURE: "IfcModulusOfElasticityMeasure",
  IFCMINUTEINHOUR: "IfcMinuteInHour",
  IFCMASSPERLENGTHMEASURE: "IfcMassPerLengthMeasure",
  IFCMASSMEASURE: "IfcMassMeasure",
  IFCMASSFLOWRATEMEASURE: "IfcMassFlowRateMeasure",
  IFCMASSDENSITYMEASURE: "IfcMassDensityMeasure",
  IFCMAGNETICFLUXMEASURE: "IfcMagneticFluxMeasure",
  IFCMAGNETICFLUXDENSITYMEASURE: "IfcMagneticFluxDensityMeasure",
  IFCLUMINOUSINTENSITYMEASURE: "IfcLuminousIntensityMeasure",
  IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE: "IfcLuminousIntensityDistributionMeasure",
  IFCLUMINOUSFLUXMEASURE: "IfcLuminousFluxMeasure",
  IFCLOGICAL: "IfcLogical",
  IFCLINEARVELOCITYMEASURE: "IfcLinearVelocityMeasure",
  IFCLINEARSTIFFNESSMEASURE: "IfcLinearStiffnessMeasure",
  IFCLINEARMOMENTMEASURE: "IfcLinearMomentMeasure",
  IFCLINEARFORCEMEASURE: "IfcLinearForceMeasure",
  IFCLENGTHMEASURE: "IfcLengthMeasure",
  IFCLABEL: "IfcLabel",
  IFCKINEMATICVISCOSITYMEASURE: "IfcKinematicViscosityMeasure",
  IFCISOTHERMALMOISTURECAPACITYMEASURE: "IfcIsothermalMoistureCapacityMeasure",
  IFCIONCONCENTRATIONMEASURE: "IfcIonConcentrationMeasure",
  IFCINTEGERCOUNTRATEMEASURE: "IfcIntegerCountRateMeasure",
  IFCINTEGER: "IfcInteger",
  IFCINDUCTANCEMEASURE: "IfcInductanceMeasure",
  IFCILLUMINANCEMEASURE: "IfcIlluminanceMeasure",
  IFCIDENTIFIER: "IfcIdentifier",
  IFCHOURINDAY: "IfcHourInDay",
  IFCHEATINGVALUEMEASURE: "IfcHeatingValueMeasure",
  IFCHEATFLUXDENSITYMEASURE: "IfcHeatFluxDensityMeasure",
  IFCGLOBALLYUNIQUEID: "IfcGloballyUniqueId",
  IFCFREQUENCYMEASURE: "IfcFrequencyMeasure",
  IFCFORCEMEASURE: "IfcForceMeasure",
  IFCFONTWEIGHT: "IfcFontWeight",
  IFCFONTVARIANT: "IfcFontVariant",
  IFCFONTSTYLE: "IfcFontStyle",
  IFCENERGYMEASURE: "IfcEnergyMeasure",
  IFCELECTRICVOLTAGEMEASURE: "IfcElectricVoltageMeasure",
  IFCELECTRICRESISTANCEMEASURE: "IfcElectricResistanceMeasure",
  IFCELECTRICCURRENTMEASURE: "IfcElectricCurrentMeasure",
  IFCELECTRICCONDUCTANCEMEASURE: "IfcElectricConductanceMeasure",
  IFCELECTRICCHARGEMEASURE: "IfcElectricChargeMeasure",
  IFCELECTRICCAPACITANCEMEASURE: "IfcElectricCapacitanceMeasure",
  IFCDYNAMICVISCOSITYMEASURE: "IfcDynamicViscosityMeasure",
  IFCDOSEEQUIVALENTMEASURE: "IfcDoseEquivalentMeasure",
  IFCDIMENSIONCOUNT: "IfcDimensionCount",
  IFCDESCRIPTIVEMEASURE: "IfcDescriptiveMeasure",
  IFCDAYLIGHTSAVINGHOUR: "IfcDaylightSavingHour",
  IFCDAYINMONTHNUMBER: "IfcDayInMonthNumber",
  IFCCURVATUREMEASURE: "IfcCurvatureMeasure",
  IFCCOUNTMEASURE: "IfcCountMeasure",
  IFCCONTEXTDEPENDENTMEASURE: "IfcContextDependentMeasure",
  IFCCOMPOUNDPLANEANGLEMEASURE: "IfcCompoundPlaneAngleMeasure",
  IFCCOMPLEXNUMBER: "IfcComplexNumber",
  IFCBOXALIGNMENT: "IfcBoxAlignment",
  IFCBOOLEAN: "IfcBoolean",
  IFCAREAMEASURE: "IfcAreaMeasure",
  IFCANGULARVELOCITYMEASURE: "IfcAngularVelocityMeasure",
  IFCAMOUNTOFSUBSTANCEMEASURE: "IfcAmountOfSubstanceMeasure",
  IFCACCELERATIONMEASURE: "IfcAccelerationMeasure",
  IFCABSORBEDDOSEMEASURE: "IfcAbsorbedDoseMeasure",
  IFCGEOSLICE: "IfcGeoSlice",
  IFCGEOMODEL: "IfcGeoModel",
  IFCELECTRICFLOWTREATMENTDEVICE: "IfcElectricFlowTreatmentDevice",
  IFCDISTRIBUTIONBOARD: "IfcDistributionBoard",
  IFCCONVEYORSEGMENT: "IfcConveyorSegment",
  IFCCAISSONFOUNDATION: "IfcCaissonFoundation",
  IFCBOREHOLE: "IfcBorehole",
  IFCBEARING: "IfcBearing",
  IFCALIGNMENT: "IfcAlignment",
  IFCTRACKELEMENT: "IfcTrackElement",
  IFCSIGNAL: "IfcSignal",
  IFCREINFORCEDSOIL: "IfcReinforcedSoil",
  IFCRAIL: "IfcRail",
  IFCPAVEMENT: "IfcPavement",
  IFCNAVIGATIONELEMENT: "IfcNavigationElement",
  IFCMOORINGDEVICE: "IfcMooringDevice",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCE: "IfcMobileTelecommunicationsAppliance",
  IFCLIQUIDTERMINAL: "IfcLiquidTerminal",
  IFCLINEARPOSITIONINGELEMENT: "IfcLinearPositioningElement",
  IFCKERB: "IfcKerb",
  IFCGEOTECHNICALASSEMBLY: "IfcGeotechnicalAssembly",
  IFCELECTRICFLOWTREATMENTDEVICETYPE: "IfcElectricFlowTreatmentDeviceType",
  IFCEARTHWORKSFILL: "IfcEarthworksFill",
  IFCEARTHWORKSELEMENT: "IfcEarthworksElement",
  IFCEARTHWORKSCUT: "IfcEarthworksCut",
  IFCDISTRIBUTIONBOARDTYPE: "IfcDistributionBoardType",
  IFCDEEPFOUNDATION: "IfcDeepFoundation",
  IFCCOURSE: "IfcCourse",
  IFCCONVEYORSEGMENTTYPE: "IfcConveyorSegmentType",
  IFCCAISSONFOUNDATIONTYPE: "IfcCaissonFoundationType",
  IFCBUILTSYSTEM: "IfcBuiltSystem",
  IFCBUILTELEMENT: "IfcBuiltElement",
  IFCBRIDGEPART: "IfcBridgePart",
  IFCBRIDGE: "IfcBridge",
  IFCBEARINGTYPE: "IfcBearingType",
  IFCALIGNMENTVERTICAL: "IfcAlignmentVertical",
  IFCALIGNMENTSEGMENT: "IfcAlignmentSegment",
  IFCALIGNMENTHORIZONTAL: "IfcAlignmentHorizontal",
  IFCALIGNMENTCANT: "IfcAlignmentCant",
  IFCVIBRATIONDAMPERTYPE: "IfcVibrationDamperType",
  IFCVIBRATIONDAMPER: "IfcVibrationDamper",
  IFCVEHICLE: "IfcVehicle",
  IFCTRANSPORTATIONDEVICE: "IfcTransportationDevice",
  IFCTRACKELEMENTTYPE: "IfcTrackElementType",
  IFCTENDONCONDUITTYPE: "IfcTendonConduitType",
  IFCTENDONCONDUIT: "IfcTendonConduit",
  IFCSINESPIRAL: "IfcSineSpiral",
  IFCSIGNALTYPE: "IfcSignalType",
  IFCSIGNTYPE: "IfcSignType",
  IFCSIGN: "IfcSign",
  IFCSEVENTHORDERPOLYNOMIALSPIRAL: "IfcSeventhOrderPolynomialSpiral",
  IFCSEGMENTEDREFERENCECURVE: "IfcSegmentedReferenceCurve",
  IFCSECONDORDERPOLYNOMIALSPIRAL: "IfcSecondOrderPolynomialSpiral",
  IFCROADPART: "IfcRoadPart",
  IFCROAD: "IfcRoad",
  IFCRELADHERESTOELEMENT: "IfcRelAdheresToElement",
  IFCREFERENT: "IfcReferent",
  IFCRAILWAYPART: "IfcRailwayPart",
  IFCRAILWAY: "IfcRailway",
  IFCRAILTYPE: "IfcRailType",
  IFCPOSITIONINGELEMENT: "IfcPositioningElement",
  IFCPAVEMENTTYPE: "IfcPavementType",
  IFCNAVIGATIONELEMENTTYPE: "IfcNavigationElementType",
  IFCMOORINGDEVICETYPE: "IfcMooringDeviceType",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE: "IfcMobileTelecommunicationsApplianceType",
  IFCMARINEPART: "IfcMarinePart",
  IFCMARINEFACILITY: "IfcMarineFacility",
  IFCLIQUIDTERMINALTYPE: "IfcLiquidTerminalType",
  IFCLINEARELEMENT: "IfcLinearElement",
  IFCKERBTYPE: "IfcKerbType",
  IFCIMPACTPROTECTIONDEVICETYPE: "IfcImpactProtectionDeviceType",
  IFCIMPACTPROTECTIONDEVICE: "IfcImpactProtectionDevice",
  IFCGRADIENTCURVE: "IfcGradientCurve",
  IFCGEOTECHNICALSTRATUM: "IfcGeotechnicalStratum",
  IFCGEOTECHNICALELEMENT: "IfcGeotechnicalElement",
  IFCFACILITYPARTCOMMON: "IfcFacilityPartCommon",
  IFCFACILITYPART: "IfcFacilityPart",
  IFCFACILITY: "IfcFacility",
  IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID: "IfcDirectrixDerivedReferenceSweptAreaSolid",
  IFCDEEPFOUNDATIONTYPE: "IfcDeepFoundationType",
  IFCCOURSETYPE: "IfcCourseType",
  IFCCOSINESPIRAL: "IfcCosineSpiral",
  IFCCLOTHOID: "IfcClothoid",
  IFCBUILTELEMENTTYPE: "IfcBuiltElementType",
  IFCVEHICLETYPE: "IfcVehicleType",
  IFCTRIANGULATEDIRREGULARNETWORK: "IfcTriangulatedIrregularNetwork",
  IFCTRANSPORTATIONDEVICETYPE: "IfcTransportationDeviceType",
  IFCTHIRDORDERPOLYNOMIALSPIRAL: "IfcThirdOrderPolynomialSpiral",
  IFCSPIRAL: "IfcSpiral",
  IFCSECTIONEDSURFACE: "IfcSectionedSurface",
  IFCSECTIONEDSOLIDHORIZONTAL: "IfcSectionedSolidHorizontal",
  IFCSECTIONEDSOLID: "IfcSectionedSolid",
  IFCRELPOSITIONS: "IfcRelPositions",
  IFCRELASSOCIATESPROFILEDEF: "IfcRelAssociatesProfileDef",
  IFCPOLYNOMIALCURVE: "IfcPolynomialCurve",
  IFCOFFSETCURVEBYDISTANCES: "IfcOffsetCurveByDistances",
  IFCOFFSETCURVE: "IfcOffsetCurve",
  IFCINDEXEDPOLYGONALTEXTUREMAP: "IfcIndexedPolygonalTextureMap",
  IFCDIRECTRIXCURVESWEPTAREASOLID: "IfcDirectrixCurveSweptAreaSolid",
  IFCCURVESEGMENT: "IfcCurveSegment",
  IFCAXIS2PLACEMENTLINEAR: "IfcAxis2PlacementLinear",
  IFCSEGMENT: "IfcSegment",
  IFCPOINTBYDISTANCEEXPRESSION: "IfcPointByDistanceExpression",
  IFCOPENCROSSPROFILEDEF: "IfcOpenCrossProfileDef",
  IFCLINEARPLACEMENT: "IfcLinearPlacement",
  IFCALIGNMENTHORIZONTALSEGMENT: "IfcAlignmentHorizontalSegment",
  IFCALIGNMENTCANTSEGMENT: "IfcAlignmentCantSegment",
  IFCTEXTURECOORDINATEINDICESWITHVOIDS: "IfcTextureCoordinateIndicesWithVoids",
  IFCTEXTURECOORDINATEINDICES: "IfcTextureCoordinateIndices",
  IFCQUANTITYNUMBER: "IfcQuantityNumber",
  IFCALIGNMENTVERTICALSEGMENT: "IfcAlignmentVerticalSegment",
  IFCALIGNMENTPARAMETERSEGMENT: "IfcAlignmentParameterSegment",
  IFCCONTROLLER: "IfcController",
  IFCALARM: "IfcAlarm",
  IFCACTUATOR: "IfcActuator",
  IFCUNITARYCONTROLELEMENT: "IfcUnitaryControlElement",
  IFCSENSOR: "IfcSensor",
  IFCPROTECTIVEDEVICETRIPPINGUNIT: "IfcProtectiveDeviceTrippingUnit",
  IFCFLOWINSTRUMENT: "IfcFlowInstrument",
  IFCFIRESUPPRESSIONTERMINAL: "IfcFireSuppressionTerminal",
  IFCFILTER: "IfcFilter",
  IFCFAN: "IfcFan",
  IFCELECTRICTIMECONTROL: "IfcElectricTimeControl",
  IFCELECTRICMOTOR: "IfcElectricMotor",
  IFCELECTRICGENERATOR: "IfcElectricGenerator",
  IFCELECTRICFLOWSTORAGEDEVICE: "IfcElectricFlowStorageDevice",
  IFCELECTRICDISTRIBUTIONBOARD: "IfcElectricDistributionBoard",
  IFCELECTRICAPPLIANCE: "IfcElectricAppliance",
  IFCDUCTSILENCER: "IfcDuctSilencer",
  IFCDUCTSEGMENT: "IfcDuctSegment",
  IFCDUCTFITTING: "IfcDuctFitting",
  IFCDISTRIBUTIONCIRCUIT: "IfcDistributionCircuit",
  IFCDAMPER: "IfcDamper",
  IFCCOOLINGTOWER: "IfcCoolingTower",
  IFCCOOLEDBEAM: "IfcCooledBeam",
  IFCCONDENSER: "IfcCondenser",
  IFCCOMPRESSOR: "IfcCompressor",
  IFCCOMMUNICATIONSAPPLIANCE: "IfcCommunicationsAppliance",
  IFCCOIL: "IfcCoil",
  IFCCHILLER: "IfcChiller",
  IFCCABLESEGMENT: "IfcCableSegment",
  IFCCABLEFITTING: "IfcCableFitting",
  IFCCABLECARRIERSEGMENT: "IfcCableCarrierSegment",
  IFCCABLECARRIERFITTING: "IfcCableCarrierFitting",
  IFCBURNER: "IfcBurner",
  IFCBOILER: "IfcBoiler",
  IFCBEAMSTANDARDCASE: "IfcBeamStandardCase",
  IFCAUDIOVISUALAPPLIANCE: "IfcAudioVisualAppliance",
  IFCAIRTOAIRHEATRECOVERY: "IfcAirToAirHeatRecovery",
  IFCAIRTERMINALBOX: "IfcAirTerminalBox",
  IFCAIRTERMINAL: "IfcAirTerminal",
  IFCWINDOWSTANDARDCASE: "IfcWindowStandardCase",
  IFCWASTETERMINAL: "IfcWasteTerminal",
  IFCWALLELEMENTEDCASE: "IfcWallElementedCase",
  IFCVALVE: "IfcValve",
  IFCUNITARYEQUIPMENT: "IfcUnitaryEquipment",
  IFCUNITARYCONTROLELEMENTTYPE: "IfcUnitaryControlElementType",
  IFCTUBEBUNDLE: "IfcTubeBundle",
  IFCTRANSFORMER: "IfcTransformer",
  IFCTANK: "IfcTank",
  IFCSWITCHINGDEVICE: "IfcSwitchingDevice",
  IFCSTRUCTURALLOADCASE: "IfcStructuralLoadCase",
  IFCSTACKTERMINAL: "IfcStackTerminal",
  IFCSPACEHEATER: "IfcSpaceHeater",
  IFCSOLARDEVICE: "IfcSolarDevice",
  IFCSLABSTANDARDCASE: "IfcSlabStandardCase",
  IFCSLABELEMENTEDCASE: "IfcSlabElementedCase",
  IFCSHADINGDEVICE: "IfcShadingDevice",
  IFCSANITARYTERMINAL: "IfcSanitaryTerminal",
  IFCREINFORCINGBARTYPE: "IfcReinforcingBarType",
  IFCRATIONALBSPLINECURVEWITHKNOTS: "IfcRationalBSplineCurveWithKnots",
  IFCPUMP: "IfcPump",
  IFCPROTECTIVEDEVICETRIPPINGUNITTYPE: "IfcProtectiveDeviceTrippingUnitType",
  IFCPROTECTIVEDEVICE: "IfcProtectiveDevice",
  IFCPLATESTANDARDCASE: "IfcPlateStandardCase",
  IFCPIPESEGMENT: "IfcPipeSegment",
  IFCPIPEFITTING: "IfcPipeFitting",
  IFCOUTLET: "IfcOutlet",
  IFCOUTERBOUNDARYCURVE: "IfcOuterBoundaryCurve",
  IFCMOTORCONNECTION: "IfcMotorConnection",
  IFCMEMBERSTANDARDCASE: "IfcMemberStandardCase",
  IFCMEDICALDEVICE: "IfcMedicalDevice",
  IFCLIGHTFIXTURE: "IfcLightFixture",
  IFCLAMP: "IfcLamp",
  IFCJUNCTIONBOX: "IfcJunctionBox",
  IFCINTERCEPTOR: "IfcInterceptor",
  IFCHUMIDIFIER: "IfcHumidifier",
  IFCHEATEXCHANGER: "IfcHeatExchanger",
  IFCFLOWMETER: "IfcFlowMeter",
  IFCEXTERNALSPATIALELEMENT: "IfcExternalSpatialElement",
  IFCEVAPORATOR: "IfcEvaporator",
  IFCEVAPORATIVECOOLER: "IfcEvaporativeCooler",
  IFCENGINE: "IfcEngine",
  IFCELECTRICDISTRIBUTIONBOARDTYPE: "IfcElectricDistributionBoardType",
  IFCDOORSTANDARDCASE: "IfcDoorStandardCase",
  IFCDISTRIBUTIONSYSTEM: "IfcDistributionSystem",
  IFCCOMMUNICATIONSAPPLIANCETYPE: "IfcCommunicationsApplianceType",
  IFCCOLUMNSTANDARDCASE: "IfcColumnStandardCase",
  IFCCIVILELEMENT: "IfcCivilElement",
  IFCCHIMNEY: "IfcChimney",
  IFCCABLEFITTINGTYPE: "IfcCableFittingType",
  IFCBURNERTYPE: "IfcBurnerType",
  IFCBUILDINGSYSTEM: "IfcBuildingSystem",
  IFCBUILDINGELEMENTPARTTYPE: "IfcBuildingElementPartType",
  IFCBOUNDARYCURVE: "IfcBoundaryCurve",
  IFCBSPLINECURVEWITHKNOTS: "IfcBSplineCurveWithKnots",
  IFCAUDIOVISUALAPPLIANCETYPE: "IfcAudioVisualApplianceType",
  IFCWORKCALENDAR: "IfcWorkCalendar",
  IFCWINDOWTYPE: "IfcWindowType",
  IFCVOIDINGFEATURE: "IfcVoidingFeature",
  IFCVIBRATIONISOLATOR: "IfcVibrationIsolator",
  IFCTENDONTYPE: "IfcTendonType",
  IFCTENDONANCHORTYPE: "IfcTendonAnchorType",
  IFCSYSTEMFURNITUREELEMENT: "IfcSystemFurnitureElement",
  IFCSURFACEFEATURE: "IfcSurfaceFeature",
  IFCSTRUCTURALSURFACEACTION: "IfcStructuralSurfaceAction",
  IFCSTRUCTURALCURVEREACTION: "IfcStructuralCurveReaction",
  IFCSTRUCTURALCURVEACTION: "IfcStructuralCurveAction",
  IFCSTAIRTYPE: "IfcStairType",
  IFCSOLARDEVICETYPE: "IfcSolarDeviceType",
  IFCSHADINGDEVICETYPE: "IfcShadingDeviceType",
  IFCSEAMCURVE: "IfcSeamCurve",
  IFCROOFTYPE: "IfcRoofType",
  IFCREINFORCINGMESHTYPE: "IfcReinforcingMeshType",
  IFCREINFORCINGELEMENTTYPE: "IfcReinforcingElementType",
  IFCRATIONALBSPLINESURFACEWITHKNOTS: "IfcRationalBSplineSurfaceWithKnots",
  IFCRAMPTYPE: "IfcRampType",
  IFCPOLYGONALFACESET: "IfcPolygonalFaceSet",
  IFCPILETYPE: "IfcPileType",
  IFCOPENINGSTANDARDCASE: "IfcOpeningStandardCase",
  IFCMEDICALDEVICETYPE: "IfcMedicalDeviceType",
  IFCINTERSECTIONCURVE: "IfcIntersectionCurve",
  IFCINTERCEPTORTYPE: "IfcInterceptorType",
  IFCINDEXEDPOLYCURVE: "IfcIndexedPolyCurve",
  IFCGEOGRAPHICELEMENT: "IfcGeographicElement",
  IFCFURNITURE: "IfcFurniture",
  IFCFOOTINGTYPE: "IfcFootingType",
  IFCEXTERNALSPATIALSTRUCTUREELEMENT: "IfcExternalSpatialStructureElement",
  IFCEVENT: "IfcEvent",
  IFCENGINETYPE: "IfcEngineType",
  IFCELEMENTASSEMBLYTYPE: "IfcElementAssemblyType",
  IFCDOORTYPE: "IfcDoorType",
  IFCCYLINDRICALSURFACE: "IfcCylindricalSurface",
  IFCCONSTRUCTIONPRODUCTRESOURCETYPE: "IfcConstructionProductResourceType",
  IFCCONSTRUCTIONMATERIALRESOURCETYPE: "IfcConstructionMaterialResourceType",
  IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE: "IfcConstructionEquipmentResourceType",
  IFCCOMPOSITECURVEONSURFACE: "IfcCompositeCurveOnSurface",
  IFCCOMPLEXPROPERTYTEMPLATE: "IfcComplexPropertyTemplate",
  IFCCIVILELEMENTTYPE: "IfcCivilElementType",
  IFCCHIMNEYTYPE: "IfcChimneyType",
  IFCBSPLINESURFACEWITHKNOTS: "IfcBSplineSurfaceWithKnots",
  IFCBSPLINESURFACE: "IfcBSplineSurface",
  IFCADVANCEDBREPWITHVOIDS: "IfcAdvancedBrepWithVoids",
  IFCADVANCEDBREP: "IfcAdvancedBrep",
  IFCTRIANGULATEDFACESET: "IfcTriangulatedFaceSet",
  IFCTOROIDALSURFACE: "IfcToroidalSurface",
  IFCTESSELLATEDFACESET: "IfcTessellatedFaceSet",
  IFCTASKTYPE: "IfcTaskType",
  IFCSURFACECURVE: "IfcSurfaceCurve",
  IFCSUBCONTRACTRESOURCETYPE: "IfcSubContractResourceType",
  IFCSTRUCTURALSURFACEREACTION: "IfcStructuralSurfaceReaction",
  IFCSPHERICALSURFACE: "IfcSphericalSurface",
  IFCSPATIALZONETYPE: "IfcSpatialZoneType",
  IFCSPATIALZONE: "IfcSpatialZone",
  IFCSPATIALELEMENTTYPE: "IfcSpatialElementType",
  IFCSPATIALELEMENT: "IfcSpatialElement",
  IFCSIMPLEPROPERTYTEMPLATE: "IfcSimplePropertyTemplate",
  IFCREVOLVEDAREASOLIDTAPERED: "IfcRevolvedAreaSolidTapered",
  IFCREPARAMETRISEDCOMPOSITECURVESEGMENT: "IfcReparametrisedCompositeCurveSegment",
  IFCRELSPACEBOUNDARY2NDLEVEL: "IfcRelSpaceBoundary2ndLevel",
  IFCRELSPACEBOUNDARY1STLEVEL: "IfcRelSpaceBoundary1stLevel",
  IFCRELINTERFERESELEMENTS: "IfcRelInterferesElements",
  IFCRELDEFINESBYTEMPLATE: "IfcRelDefinesByTemplate",
  IFCRELDEFINESBYOBJECT: "IfcRelDefinesByObject",
  IFCRELDECLARES: "IfcRelDeclares",
  IFCRELASSIGNSTOGROUPBYFACTOR: "IfcRelAssignsToGroupByFactor",
  IFCPROPERTYTEMPLATE: "IfcPropertyTemplate",
  IFCPROPERTYSETTEMPLATE: "IfcPropertySetTemplate",
  IFCPROJECTLIBRARY: "IfcProjectLibrary",
  IFCPROCEDURETYPE: "IfcProcedureType",
  IFCPREDEFINEDPROPERTYSET: "IfcPredefinedPropertySet",
  IFCPCURVE: "IfcPCurve",
  IFCLABORRESOURCETYPE: "IfcLaborResourceType",
  IFCINDEXEDPOLYGONALFACEWITHVOIDS: "IfcIndexedPolygonalFaceWithVoids",
  IFCINDEXEDPOLYGONALFACE: "IfcIndexedPolygonalFace",
  IFCGEOGRAPHICELEMENTTYPE: "IfcGeographicElementType",
  IFCFIXEDREFERENCESWEPTAREASOLID: "IfcFixedReferenceSweptAreaSolid",
  IFCEXTRUDEDAREASOLIDTAPERED: "IfcExtrudedAreaSolidTapered",
  IFCEVENTTYPE: "IfcEventType",
  IFCCURVEBOUNDEDSURFACE: "IfcCurveBoundedSurface",
  IFCCREWRESOURCETYPE: "IfcCrewResourceType",
  IFCCONTEXT: "IfcContext",
  IFCCONSTRUCTIONRESOURCETYPE: "IfcConstructionResourceType",
  IFCCARTESIANPOINTLIST3D: "IfcCartesianPointList3D",
  IFCCARTESIANPOINTLIST2D: "IfcCartesianPointList2D",
  IFCCARTESIANPOINTLIST: "IfcCartesianPointList",
  IFCADVANCEDFACE: "IfcAdvancedFace",
  IFCTYPERESOURCE: "IfcTypeResource",
  IFCTYPEPROCESS: "IfcTypeProcess",
  IFCTESSELLATEDITEM: "IfcTessellatedItem",
  IFCSWEPTDISKSOLIDPOLYGONAL: "IfcSweptDiskSolidPolygonal",
  IFCRESOURCETIME: "IfcResourceTime",
  IFCRESOURCECONSTRAINTRELATIONSHIP: "IfcResourceConstraintRelationship",
  IFCRESOURCEAPPROVALRELATIONSHIP: "IfcResourceApprovalRelationship",
  IFCQUANTITYSET: "IfcQuantitySet",
  IFCPROPERTYTEMPLATEDEFINITION: "IfcPropertyTemplateDefinition",
  IFCPREDEFINEDPROPERTIES: "IfcPredefinedProperties",
  IFCMIRROREDPROFILEDEF: "IfcMirroredProfileDef",
  IFCMATERIALRELATIONSHIP: "IfcMaterialRelationship",
  IFCMATERIALPROFILESETUSAGETAPERING: "IfcMaterialProfileSetUsageTapering",
  IFCMATERIALPROFILESETUSAGE: "IfcMaterialProfileSetUsage",
  IFCMATERIALCONSTITUENTSET: "IfcMaterialConstituentSet",
  IFCMATERIALCONSTITUENT: "IfcMaterialConstituent",
  IFCLAGTIME: "IfcLagTime",
  IFCINDEXEDTRIANGLETEXTUREMAP: "IfcIndexedTriangleTextureMap",
  IFCINDEXEDTEXTUREMAP: "IfcIndexedTextureMap",
  IFCINDEXEDCOLOURMAP: "IfcIndexedColourMap",
  IFCEXTERNALREFERENCERELATIONSHIP: "IfcExternalReferenceRelationship",
  IFCEXTENDEDPROPERTIES: "IfcExtendedProperties",
  IFCEVENTTIME: "IfcEventTime",
  IFCCONVERSIONBASEDUNITWITHOFFSET: "IfcConversionBasedUnitWithOffset",
  IFCCOLOURRGBLIST: "IfcColourRgbList",
  IFCWORKTIME: "IfcWorkTime",
  IFCTIMEPERIOD: "IfcTimePeriod",
  IFCTEXTUREVERTEXLIST: "IfcTextureVertexList",
  IFCTASKTIMERECURRING: "IfcTaskTimeRecurring",
  IFCTASKTIME: "IfcTaskTime",
  IFCTABLECOLUMN: "IfcTableColumn",
  IFCSURFACEREINFORCEMENTAREA: "IfcSurfaceReinforcementArea",
  IFCSTRUCTURALLOADORRESULT: "IfcStructuralLoadOrResult",
  IFCSTRUCTURALLOADCONFIGURATION: "IfcStructuralLoadConfiguration",
  IFCSCHEDULINGTIME: "IfcSchedulingTime",
  IFCRESOURCELEVELRELATIONSHIP: "IfcResourceLevelRelationship",
  IFCREFERENCE: "IfcReference",
  IFCRECURRENCEPATTERN: "IfcRecurrencePattern",
  IFCPROPERTYABSTRACTION: "IfcPropertyAbstraction",
  IFCPROJECTEDCRS: "IfcProjectedCrs",
  IFCPRESENTATIONITEM: "IfcPresentationItem",
  IFCMATERIALUSAGEDEFINITION: "IfcMaterialUsageDefinition",
  IFCMATERIALPROFILEWITHOFFSETS: "IfcMaterialProfileWithOffsets",
  IFCMATERIALPROFILESET: "IfcMaterialProfileSet",
  IFCMATERIALPROFILE: "IfcMaterialProfile",
  IFCMATERIALLAYERWITHOFFSETS: "IfcMaterialLayerWithOffsets",
  IFCMATERIALDEFINITION: "IfcMaterialDefinition",
  IFCMAPCONVERSION: "IfcMapConversion",
  IFCEXTERNALINFORMATION: "IfcExternalInformation",
  IFCCOORDINATEREFERENCESYSTEM: "IfcCoordinateReferenceSystem",
  IFCCOORDINATEOPERATION: "IfcCoordinateOperation",
  IFCCONNECTIONVOLUMEGEOMETRY: "IfcConnectionVolumeGeometry",
  IFCREINFORCINGBAR: "IfcReinforcingBar",
  IFCELECTRICDISTRIBUTIONPOINT: "IfcElectricDistributionPoint",
  IFCDISTRIBUTIONCONTROLELEMENT: "IfcDistributionControlElement",
  IFCDISTRIBUTIONCHAMBERELEMENT: "IfcDistributionChamberElement",
  IFCCONTROLLERTYPE: "IfcControllerType",
  IFCCHAMFEREDGEFEATURE: "IfcChamferEdgeFeature",
  IFCBEAM: "IfcBeam",
  IFCALARMTYPE: "IfcAlarmType",
  IFCACTUATORTYPE: "IfcActuatorType",
  IFCWINDOW: "IfcWindow",
  IFCWALLSTANDARDCASE: "IfcWallStandardCase",
  IFCWALL: "IfcWall",
  IFCVIBRATIONISOLATORTYPE: "IfcVibrationIsolatorType",
  IFCTENDONANCHOR: "IfcTendonAnchor",
  IFCTENDON: "IfcTendon",
  IFCSTRUCTURALANALYSISMODEL: "IfcStructuralAnalysisModel",
  IFCSTAIRFLIGHT: "IfcStairFlight",
  IFCSTAIR: "IfcStair",
  IFCSLAB: "IfcSlab",
  IFCSENSORTYPE: "IfcSensorType",
  IFCROUNDEDEDGEFEATURE: "IfcRoundedEdgeFeature",
  IFCROOF: "IfcRoof",
  IFCREINFORCINGMESH: "IfcReinforcingMesh",
  IFCREINFORCINGELEMENT: "IfcReinforcingElement",
  IFCRATIONALBEZIERCURVE: "IfcRationalBezierCurve",
  IFCRAMPFLIGHT: "IfcRampFlight",
  IFCRAMP: "IfcRamp",
  IFCRAILING: "IfcRailing",
  IFCPLATE: "IfcPlate",
  IFCPILE: "IfcPile",
  IFCMEMBER: "IfcMember",
  IFCFOOTING: "IfcFooting",
  IFCFLOWTREATMENTDEVICE: "IfcFlowTreatmentDevice",
  IFCFLOWTERMINAL: "IfcFlowTerminal",
  IFCFLOWSTORAGEDEVICE: "IfcFlowStorageDevice",
  IFCFLOWSEGMENT: "IfcFlowSegment",
  IFCFLOWMOVINGDEVICE: "IfcFlowMovingDevice",
  IFCFLOWINSTRUMENTTYPE: "IfcFlowInstrumentType",
  IFCFLOWFITTING: "IfcFlowFitting",
  IFCFLOWCONTROLLER: "IfcFlowController",
  IFCFIRESUPPRESSIONTERMINALTYPE: "IfcFireSuppressionTerminalType",
  IFCFILTERTYPE: "IfcFilterType",
  IFCFANTYPE: "IfcFanType",
  IFCENERGYCONVERSIONDEVICE: "IfcEnergyConversionDevice",
  IFCELECTRICALELEMENT: "IfcElectricalElement",
  IFCELECTRICALCIRCUIT: "IfcElectricalCircuit",
  IFCELECTRICTIMECONTROLTYPE: "IfcElectricTimeControlType",
  IFCELECTRICMOTORTYPE: "IfcElectricMotorType",
  IFCELECTRICHEATERTYPE: "IfcElectricHeaterType",
  IFCELECTRICGENERATORTYPE: "IfcElectricGeneratorType",
  IFCELECTRICFLOWSTORAGEDEVICETYPE: "IfcElectricFlowStorageDeviceType",
  IFCELECTRICAPPLIANCETYPE: "IfcElectricApplianceType",
  IFCEDGEFEATURE: "IfcEdgeFeature",
  IFCDUCTSILENCERTYPE: "IfcDuctSilencerType",
  IFCDUCTSEGMENTTYPE: "IfcDuctSegmentType",
  IFCDUCTFITTINGTYPE: "IfcDuctFittingType",
  IFCDOOR: "IfcDoor",
  IFCDISTRIBUTIONPORT: "IfcDistributionPort",
  IFCDISTRIBUTIONFLOWELEMENT: "IfcDistributionFlowElement",
  IFCDISTRIBUTIONELEMENT: "IfcDistributionElement",
  IFCDISTRIBUTIONCONTROLELEMENTTYPE: "IfcDistributionControlElementType",
  IFCDISTRIBUTIONCHAMBERELEMENTTYPE: "IfcDistributionChamberElementType",
  IFCDISCRETEACCESSORYTYPE: "IfcDiscreteAccessoryType",
  IFCDISCRETEACCESSORY: "IfcDiscreteAccessory",
  IFCDIAMETERDIMENSION: "IfcDiameterDimension",
  IFCDAMPERTYPE: "IfcDamperType",
  IFCCURTAINWALL: "IfcCurtainWall",
  IFCCOVERING: "IfcCovering",
  IFCCOOLINGTOWERTYPE: "IfcCoolingTowerType",
  IFCCOOLEDBEAMTYPE: "IfcCooledBeamType",
  IFCCONSTRUCTIONPRODUCTRESOURCE: "IfcConstructionProductResource",
  IFCCONSTRUCTIONMATERIALRESOURCE: "IfcConstructionMaterialResource",
  IFCCONSTRUCTIONEQUIPMENTRESOURCE: "IfcConstructionEquipmentResource",
  IFCCONDITIONCRITERION: "IfcConditionCriterion",
  IFCCONDITION: "IfcCondition",
  IFCCONDENSERTYPE: "IfcCondenserType",
  IFCCOMPRESSORTYPE: "IfcCompressorType",
  IFCCOLUMN: "IfcColumn",
  IFCCOILTYPE: "IfcCoilType",
  IFCCIRCLE: "IfcCircle",
  IFCCHILLERTYPE: "IfcChillerType",
  IFCCABLESEGMENTTYPE: "IfcCableSegmentType",
  IFCCABLECARRIERSEGMENTTYPE: "IfcCableCarrierSegmentType",
  IFCCABLECARRIERFITTINGTYPE: "IfcCableCarrierFittingType",
  IFCBUILDINGELEMENTPROXYTYPE: "IfcBuildingElementProxyType",
  IFCBUILDINGELEMENTPROXY: "IfcBuildingElementProxy",
  IFCBUILDINGELEMENTPART: "IfcBuildingElementPart",
  IFCBUILDINGELEMENTCOMPONENT: "IfcBuildingElementComponent",
  IFCBUILDINGELEMENT: "IfcBuildingElement",
  IFCBOILERTYPE: "IfcBoilerType",
  IFCBEZIERCURVE: "IfcBezierCurve",
  IFCBEAMTYPE: "IfcBeamType",
  IFCBSPLINECURVE: "IfcBSplineCurve",
  IFCASSET: "IfcAsset",
  IFCANGULARDIMENSION: "IfcAngularDimension",
  IFCAIRTOAIRHEATRECOVERYTYPE: "IfcAirToAirHeatRecoveryType",
  IFCAIRTERMINALTYPE: "IfcAirTerminalType",
  IFCAIRTERMINALBOXTYPE: "IfcAirTerminalBoxType",
  IFCACTIONREQUEST: "IfcActionRequest",
  IFC2DCOMPOSITECURVE: "Ifc2DCompositeCurve",
  IFCZONE: "IfcZone",
  IFCWORKSCHEDULE: "IfcWorkSchedule",
  IFCWORKPLAN: "IfcWorkPlan",
  IFCWORKCONTROL: "IfcWorkControl",
  IFCWASTETERMINALTYPE: "IfcWasteTerminalType",
  IFCWALLTYPE: "IfcWallType",
  IFCVIRTUALELEMENT: "IfcVirtualElement",
  IFCVALVETYPE: "IfcValveType",
  IFCUNITARYEQUIPMENTTYPE: "IfcUnitaryEquipmentType",
  IFCTUBEBUNDLETYPE: "IfcTubeBundleType",
  IFCTRIMMEDCURVE: "IfcTrimmedCurve",
  IFCTRANSPORTELEMENT: "IfcTransportElement",
  IFCTRANSFORMERTYPE: "IfcTransformerType",
  IFCTIMESERIESSCHEDULE: "IfcTimeSeriesSchedule",
  IFCTANKTYPE: "IfcTankType",
  IFCSYSTEM: "IfcSystem",
  IFCSWITCHINGDEVICETYPE: "IfcSwitchingDeviceType",
  IFCSUBCONTRACTRESOURCE: "IfcSubContractResource",
  IFCSTRUCTURALSURFACECONNECTION: "IfcStructuralSurfaceConnection",
  IFCSTRUCTURALRESULTGROUP: "IfcStructuralResultGroup",
  IFCSTRUCTURALPOINTREACTION: "IfcStructuralPointReaction",
  IFCSTRUCTURALPOINTCONNECTION: "IfcStructuralPointConnection",
  IFCSTRUCTURALPOINTACTION: "IfcStructuralPointAction",
  IFCSTRUCTURALPLANARACTIONVARYING: "IfcStructuralPlanarActionVarying",
  IFCSTRUCTURALPLANARACTION: "IfcStructuralPlanarAction",
  IFCSTRUCTURALLOADGROUP: "IfcStructuralLoadGroup",
  IFCSTRUCTURALLINEARACTIONVARYING: "IfcStructuralLinearActionVarying",
  IFCSTRUCTURALLINEARACTION: "IfcStructuralLinearAction",
  IFCSTRUCTURALCURVEMEMBERVARYING: "IfcStructuralCurveMemberVarying",
  IFCSTRUCTURALCURVEMEMBER: "IfcStructuralCurveMember",
  IFCSTRUCTURALCURVECONNECTION: "IfcStructuralCurveConnection",
  IFCSTRUCTURALCONNECTION: "IfcStructuralConnection",
  IFCSTRUCTURALACTION: "IfcStructuralAction",
  IFCSTAIRFLIGHTTYPE: "IfcStairFlightType",
  IFCSTACKTERMINALTYPE: "IfcStackTerminalType",
  IFCSPACETYPE: "IfcSpaceType",
  IFCSPACEPROGRAM: "IfcSpaceProgram",
  IFCSPACEHEATERTYPE: "IfcSpaceHeaterType",
  IFCSPACE: "IfcSpace",
  IFCSLABTYPE: "IfcSlabType",
  IFCSITE: "IfcSite",
  IFCSERVICELIFE: "IfcServiceLife",
  IFCSCHEDULETIMECONTROL: "IfcScheduleTimeControl",
  IFCSANITARYTERMINALTYPE: "IfcSanitaryTerminalType",
  IFCRELASSIGNSTASKS: "IfcRelAssignsTasks",
  IFCRELAGGREGATES: "IfcRelAggregates",
  IFCRAMPFLIGHTTYPE: "IfcRampFlightType",
  IFCRAILINGTYPE: "IfcRailingType",
  IFCRADIUSDIMENSION: "IfcRadiusDimension",
  IFCPUMPTYPE: "IfcPumpType",
  IFCPROTECTIVEDEVICETYPE: "IfcProtectiveDeviceType",
  IFCPROJECTIONELEMENT: "IfcProjectionElement",
  IFCPROJECTORDERRECORD: "IfcProjectOrderRecord",
  IFCPROJECTORDER: "IfcProjectOrder",
  IFCPROCEDURE: "IfcProcedure",
  IFCPORT: "IfcPort",
  IFCPOLYLINE: "IfcPolyline",
  IFCPLATETYPE: "IfcPlateType",
  IFCPIPESEGMENTTYPE: "IfcPipeSegmentType",
  IFCPIPEFITTINGTYPE: "IfcPipeFittingType",
  IFCPERMIT: "IfcPermit",
  IFCPERFORMANCEHISTORY: "IfcPerformanceHistory",
  IFCOUTLETTYPE: "IfcOutletType",
  IFCORDERACTION: "IfcOrderAction",
  IFCOPENINGELEMENT: "IfcOpeningElement",
  IFCOCCUPANT: "IfcOccupant",
  IFCMOVE: "IfcMove",
  IFCMOTORCONNECTIONTYPE: "IfcMotorConnectionType",
  IFCMEMBERTYPE: "IfcMemberType",
  IFCMECHANICALFASTENERTYPE: "IfcMechanicalFastenerType",
  IFCMECHANICALFASTENER: "IfcMechanicalFastener",
  IFCLINEARDIMENSION: "IfcLinearDimension",
  IFCLIGHTFIXTURETYPE: "IfcLightFixtureType",
  IFCLAMPTYPE: "IfcLampType",
  IFCLABORRESOURCE: "IfcLaborResource",
  IFCJUNCTIONBOXTYPE: "IfcJunctionBoxType",
  IFCINVENTORY: "IfcInventory",
  IFCHUMIDIFIERTYPE: "IfcHumidifierType",
  IFCHEATEXCHANGERTYPE: "IfcHeatExchangerType",
  IFCGROUP: "IfcGroup",
  IFCGRID: "IfcGrid",
  IFCGASTERMINALTYPE: "IfcGasTerminalType",
  IFCFURNITURESTANDARD: "IfcFurnitureStandard",
  IFCFURNISHINGELEMENT: "IfcFurnishingElement",
  IFCFLOWTREATMENTDEVICETYPE: "IfcFlowTreatmentDeviceType",
  IFCFLOWTERMINALTYPE: "IfcFlowTerminalType",
  IFCFLOWSTORAGEDEVICETYPE: "IfcFlowStorageDeviceType",
  IFCFLOWSEGMENTTYPE: "IfcFlowSegmentType",
  IFCFLOWMOVINGDEVICETYPE: "IfcFlowMovingDeviceType",
  IFCFLOWMETERTYPE: "IfcFlowMeterType",
  IFCFLOWFITTINGTYPE: "IfcFlowFittingType",
  IFCFLOWCONTROLLERTYPE: "IfcFlowControllerType",
  IFCFEATUREELEMENTSUBTRACTION: "IfcFeatureElementSubtraction",
  IFCFEATUREELEMENTADDITION: "IfcFeatureElementAddition",
  IFCFEATUREELEMENT: "IfcFeatureElement",
  IFCFASTENERTYPE: "IfcFastenerType",
  IFCFASTENER: "IfcFastener",
  IFCFACETEDBREPWITHVOIDS: "IfcFacetedBrepWithVoids",
  IFCFACETEDBREP: "IfcFacetedBrep",
  IFCEVAPORATORTYPE: "IfcEvaporatorType",
  IFCEVAPORATIVECOOLERTYPE: "IfcEvaporativeCoolerType",
  IFCEQUIPMENTSTANDARD: "IfcEquipmentStandard",
  IFCEQUIPMENTELEMENT: "IfcEquipmentElement",
  IFCENERGYCONVERSIONDEVICETYPE: "IfcEnergyConversionDeviceType",
  IFCELLIPSE: "IfcEllipse",
  IFCELEMENTCOMPONENTTYPE: "IfcElementComponentType",
  IFCELEMENTCOMPONENT: "IfcElementComponent",
  IFCELEMENTASSEMBLY: "IfcElementAssembly",
  IFCELEMENT: "IfcElement",
  IFCELECTRICALBASEPROPERTIES: "IfcElectricalBaseProperties",
  IFCDISTRIBUTIONFLOWELEMENTTYPE: "IfcDistributionFlowElementType",
  IFCDISTRIBUTIONELEMENTTYPE: "IfcDistributionElementType",
  IFCDIMENSIONCURVEDIRECTEDCALLOUT: "IfcDimensionCurveDirectedCallout",
  IFCCURTAINWALLTYPE: "IfcCurtainWallType",
  IFCCREWRESOURCE: "IfcCrewResource",
  IFCCOVERINGTYPE: "IfcCoveringType",
  IFCCOSTSCHEDULE: "IfcCostSchedule",
  IFCCOSTITEM: "IfcCostItem",
  IFCCONTROL: "IfcControl",
  IFCCONSTRUCTIONRESOURCE: "IfcConstructionResource",
  IFCCONIC: "IfcConic",
  IFCCOMPOSITECURVE: "IfcCompositeCurve",
  IFCCOLUMNTYPE: "IfcColumnType",
  IFCCIRCLEHOLLOWPROFILEDEF: "IfcCircleHollowProfileDef",
  IFCBUILDINGSTOREY: "IfcBuildingStorey",
  IFCBUILDINGELEMENTTYPE: "IfcBuildingElementType",
  IFCBUILDING: "IfcBuilding",
  IFCBOUNDEDCURVE: "IfcBoundedCurve",
  IFCBOOLEANCLIPPINGRESULT: "IfcBooleanClippingResult",
  IFCBLOCK: "IfcBlock",
  IFCASYMMETRICISHAPEPROFILEDEF: "IfcAsymmetricIShapeProfileDef",
  IFCANNOTATION: "IfcAnnotation",
  IFCACTOR: "IfcActor",
  IFCTRANSPORTELEMENTTYPE: "IfcTransportElementType",
  IFCTASK: "IfcTask",
  IFCSYSTEMFURNITUREELEMENTTYPE: "IfcSystemFurnitureElementType",
  IFCSURFACEOFREVOLUTION: "IfcSurfaceOfRevolution",
  IFCSURFACEOFLINEAREXTRUSION: "IfcSurfaceOfLinearExtrusion",
  IFCSURFACECURVESWEPTAREASOLID: "IfcSurfaceCurveSweptAreaSolid",
  IFCSTRUCTUREDDIMENSIONCALLOUT: "IfcStructuredDimensionCallout",
  IFCSTRUCTURALSURFACEMEMBERVARYING: "IfcStructuralSurfaceMemberVarying",
  IFCSTRUCTURALSURFACEMEMBER: "IfcStructuralSurfaceMember",
  IFCSTRUCTURALREACTION: "IfcStructuralReaction",
  IFCSTRUCTURALMEMBER: "IfcStructuralMember",
  IFCSTRUCTURALITEM: "IfcStructuralItem",
  IFCSTRUCTURALACTIVITY: "IfcStructuralActivity",
  IFCSPHERE: "IfcSphere",
  IFCSPATIALSTRUCTUREELEMENTTYPE: "IfcSpatialStructureElementType",
  IFCSPATIALSTRUCTUREELEMENT: "IfcSpatialStructureElement",
  IFCRIGHTCIRCULARCYLINDER: "IfcRightCircularCylinder",
  IFCRIGHTCIRCULARCONE: "IfcRightCircularCone",
  IFCREVOLVEDAREASOLID: "IfcRevolvedAreaSolid",
  IFCRESOURCE: "IfcResource",
  IFCRELVOIDSELEMENT: "IfcRelVoidsElement",
  IFCRELSPACEBOUNDARY: "IfcRelSpaceBoundary",
  IFCRELSERVICESBUILDINGS: "IfcRelServicesBuildings",
  IFCRELSEQUENCE: "IfcRelSequence",
  IFCRELSCHEDULESCOSTITEMS: "IfcRelSchedulesCostItems",
  IFCRELREFERENCEDINSPATIALSTRUCTURE: "IfcRelReferencedInSpatialStructure",
  IFCRELPROJECTSELEMENT: "IfcRelProjectsElement",
  IFCRELOVERRIDESPROPERTIES: "IfcRelOverridesProperties",
  IFCRELOCCUPIESSPACES: "IfcRelOccupiesSpaces",
  IFCRELNESTS: "IfcRelNests",
  IFCRELINTERACTIONREQUIREMENTS: "IfcRelInteractionRequirements",
  IFCRELFLOWCONTROLELEMENTS: "IfcRelFlowControlElements",
  IFCRELFILLSELEMENT: "IfcRelFillsElement",
  IFCRELDEFINESBYTYPE: "IfcRelDefinesByType",
  IFCRELDEFINESBYPROPERTIES: "IfcRelDefinesByProperties",
  IFCRELDEFINES: "IfcRelDefines",
  IFCRELDECOMPOSES: "IfcRelDecomposes",
  IFCRELCOVERSSPACES: "IfcRelCoversSpaces",
  IFCRELCOVERSBLDGELEMENTS: "IfcRelCoversBldgElements",
  IFCRELCONTAINEDINSPATIALSTRUCTURE: "IfcRelContainedInSpatialStructure",
  IFCRELCONNECTSWITHREALIZINGELEMENTS: "IfcRelConnectsWithRealizingElements",
  IFCRELCONNECTSWITHECCENTRICITY: "IfcRelConnectsWithEccentricity",
  IFCRELCONNECTSSTRUCTURALMEMBER: "IfcRelConnectsStructuralMember",
  IFCRELCONNECTSSTRUCTURALELEMENT: "IfcRelConnectsStructuralElement",
  IFCRELCONNECTSSTRUCTURALACTIVITY: "IfcRelConnectsStructuralActivity",
  IFCRELCONNECTSPORTS: "IfcRelConnectsPorts",
  IFCRELCONNECTSPORTTOELEMENT: "IfcRelConnectsPortToElement",
  IFCRELCONNECTSPATHELEMENTS: "IfcRelConnectsPathElements",
  IFCRELCONNECTSELEMENTS: "IfcRelConnectsElements",
  IFCRELCONNECTS: "IfcRelConnects",
  IFCRELASSOCIATESPROFILEPROPERTIES: "IfcRelAssociatesProfileProperties",
  IFCRELASSOCIATESMATERIAL: "IfcRelAssociatesMaterial",
  IFCRELASSOCIATESLIBRARY: "IfcRelAssociatesLibrary",
  IFCRELASSOCIATESDOCUMENT: "IfcRelAssociatesDocument",
  IFCRELASSOCIATESCONSTRAINT: "IfcRelAssociatesConstraint",
  IFCRELASSOCIATESCLASSIFICATION: "IfcRelAssociatesClassification",
  IFCRELASSOCIATESAPPROVAL: "IfcRelAssociatesApproval",
  IFCRELASSOCIATESAPPLIEDVALUE: "IfcRelAssociatesAppliedValue",
  IFCRELASSOCIATES: "IfcRelAssociates",
  IFCRELASSIGNSTORESOURCE: "IfcRelAssignsToResource",
  IFCRELASSIGNSTOPROJECTORDER: "IfcRelAssignsToProjectOrder",
  IFCRELASSIGNSTOPRODUCT: "IfcRelAssignsToProduct",
  IFCRELASSIGNSTOPROCESS: "IfcRelAssignsToProcess",
  IFCRELASSIGNSTOGROUP: "IfcRelAssignsToGroup",
  IFCRELASSIGNSTOCONTROL: "IfcRelAssignsToControl",
  IFCRELASSIGNSTOACTOR: "IfcRelAssignsToActor",
  IFCRELASSIGNS: "IfcRelAssigns",
  IFCRECTANGULARTRIMMEDSURFACE: "IfcRectangularTrimmedSurface",
  IFCRECTANGULARPYRAMID: "IfcRectangularPyramid",
  IFCRECTANGLEHOLLOWPROFILEDEF: "IfcRectangleHollowProfileDef",
  IFCPROXY: "IfcProxy",
  IFCPROPERTYSET: "IfcPropertySet",
  IFCPROJECTIONCURVE: "IfcProjectionCurve",
  IFCPROJECT: "IfcProject",
  IFCPRODUCT: "IfcProduct",
  IFCPROCESS: "IfcProcess",
  IFCPLANE: "IfcPlane",
  IFCPLANARBOX: "IfcPlanarBox",
  IFCPERMEABLECOVERINGPROPERTIES: "IfcPermeableCoveringProperties",
  IFCOFFSETCURVE3D: "IfcOffsetCurve3D",
  IFCOFFSETCURVE2D: "IfcOffsetCurve2D",
  IFCOBJECT: "IfcObject",
  IFCMANIFOLDSOLIDBREP: "IfcManifoldSolidBrep",
  IFCLINE: "IfcLine",
  IFCLSHAPEPROFILEDEF: "IfcLShapeProfileDef",
  IFCISHAPEPROFILEDEF: "IfcIShapeProfileDef",
  IFCGEOMETRICCURVESET: "IfcGeometricCurveSet",
  IFCFURNITURETYPE: "IfcFurnitureType",
  IFCFURNISHINGELEMENTTYPE: "IfcFurnishingElementType",
  IFCFLUIDFLOWPROPERTIES: "IfcFluidFlowProperties",
  IFCFILLAREASTYLETILES: "IfcFillAreaStyleTiles",
  IFCFILLAREASTYLETILESYMBOLWITHSTYLE: "IfcFillAreaStyleTileSymbolWithStyle",
  IFCFILLAREASTYLEHATCHING: "IfcFillAreaStyleHatching",
  IFCFACEBASEDSURFACEMODEL: "IfcFaceBasedSurfaceModel",
  IFCEXTRUDEDAREASOLID: "IfcExtrudedAreaSolid",
  IFCENERGYPROPERTIES: "IfcEnergyProperties",
  IFCELLIPSEPROFILEDEF: "IfcEllipseProfileDef",
  IFCELEMENTARYSURFACE: "IfcElementarySurface",
  IFCELEMENTTYPE: "IfcElementType",
  IFCELEMENTQUANTITY: "IfcElementQuantity",
  IFCEDGELOOP: "IfcEdgeLoop",
  IFCDRAUGHTINGPREDEFINEDCURVEFONT: "IfcDraughtingPredefinedCurveFont",
  IFCDRAUGHTINGPREDEFINEDCOLOUR: "IfcDraughtingPredefinedColour",
  IFCDRAUGHTINGCALLOUT: "IfcDraughtingCallout",
  IFCDOORSTYLE: "IfcDoorStyle",
  IFCDOORPANELPROPERTIES: "IfcDoorPanelProperties",
  IFCDOORLININGPROPERTIES: "IfcDoorLiningProperties",
  IFCDIRECTION: "IfcDirection",
  IFCDIMENSIONCURVETERMINATOR: "IfcDimensionCurveTerminator",
  IFCDIMENSIONCURVE: "IfcDimensionCurve",
  IFCDEFINEDSYMBOL: "IfcDefinedSymbol",
  IFCCURVEBOUNDEDPLANE: "IfcCurveBoundedPlane",
  IFCCURVE: "IfcCurve",
  IFCCSGSOLID: "IfcCsgSolid",
  IFCCSGPRIMITIVE3D: "IfcCsgPrimitive3D",
  IFCCRANERAILFSHAPEPROFILEDEF: "IfcCraneRailFShapeProfileDef",
  IFCCRANERAILASHAPEPROFILEDEF: "IfcCraneRailAShapeProfileDef",
  IFCCOMPOSITECURVESEGMENT: "IfcCompositeCurveSegment",
  IFCCLOSEDSHELL: "IfcClosedShell",
  IFCCIRCLEPROFILEDEF: "IfcCircleProfileDef",
  IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM: "IfcCartesianTransformationOperator3DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR3D: "IfcCartesianTransformationOperator3D",
  IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM: "IfcCartesianTransformationOperator2DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR2D: "IfcCartesianTransformationOperator2D",
  IFCCARTESIANTRANSFORMATIONOPERATOR: "IfcCartesianTransformationOperator",
  IFCCARTESIANPOINT: "IfcCartesianPoint",
  IFCCSHAPEPROFILEDEF: "IfcCShapeProfileDef",
  IFCBOXEDHALFSPACE: "IfcBoxedHalfSpace",
  IFCBOUNDINGBOX: "IfcBoundingBox",
  IFCBOUNDEDSURFACE: "IfcBoundedSurface",
  IFCBOOLEANRESULT: "IfcBooleanResult",
  IFCAXIS2PLACEMENT3D: "IfcAxis2Placement3D",
  IFCAXIS2PLACEMENT2D: "IfcAxis2Placement2D",
  IFCAXIS1PLACEMENT: "IfcAxis1Placement",
  IFCANNOTATIONSURFACE: "IfcAnnotationSurface",
  IFCANNOTATIONFILLAREAOCCURRENCE: "IfcAnnotationFillAreaOccurrence",
  IFCANNOTATIONFILLAREA: "IfcAnnotationFillArea",
  IFCANNOTATIONCURVEOCCURRENCE: "IfcAnnotationCurveOccurrence",
  IFCZSHAPEPROFILEDEF: "IfcZShapeProfileDef",
  IFCWINDOWSTYLE: "IfcWindowStyle",
  IFCWINDOWPANELPROPERTIES: "IfcWindowPanelProperties",
  IFCWINDOWLININGPROPERTIES: "IfcWindowLiningProperties",
  IFCVERTEXLOOP: "IfcVertexLoop",
  IFCVECTOR: "IfcVector",
  IFCUSHAPEPROFILEDEF: "IfcUShapeProfileDef",
  IFCTYPEPRODUCT: "IfcTypeProduct",
  IFCTYPEOBJECT: "IfcTypeObject",
  IFCTWODIRECTIONREPEATFACTOR: "IfcTwoDirectionRepeatFactor",
  IFCTRAPEZIUMPROFILEDEF: "IfcTrapeziumProfileDef",
  IFCTEXTLITERALWITHEXTENT: "IfcTextLiteralWithExtent",
  IFCTEXTLITERAL: "IfcTextLiteral",
  IFCTERMINATORSYMBOL: "IfcTerminatorSymbol",
  IFCTSHAPEPROFILEDEF: "IfcTShapeProfileDef",
  IFCSWEPTSURFACE: "IfcSweptSurface",
  IFCSWEPTDISKSOLID: "IfcSweptDiskSolid",
  IFCSWEPTAREASOLID: "IfcSweptAreaSolid",
  IFCSURFACESTYLERENDERING: "IfcSurfaceStyleRendering",
  IFCSURFACE: "IfcSurface",
  IFCSUBEDGE: "IfcSubedge",
  IFCSTRUCTURALSTEELPROFILEPROPERTIES: "IfcStructuralSteelProfileProperties",
  IFCSTRUCTURALPROFILEPROPERTIES: "IfcStructuralProfileProperties",
  IFCSTRUCTURALLOADSINGLEFORCEWARPING: "IfcStructuralLoadSingleForceWarping",
  IFCSTRUCTURALLOADSINGLEFORCE: "IfcStructuralLoadSingleForce",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION: "IfcStructuralLoadSingleDisplacementDistortion",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENT: "IfcStructuralLoadSingleDisplacement",
  IFCSTRUCTURALLOADPLANARFORCE: "IfcStructuralLoadPlanarForce",
  IFCSTRUCTURALLOADLINEARFORCE: "IfcStructuralLoadLinearForce",
  IFCSPACETHERMALLOADPROPERTIES: "IfcSpaceThermalLoadProperties",
  IFCSOUNDVALUE: "IfcSoundValue",
  IFCSOUNDPROPERTIES: "IfcSoundProperties",
  IFCSOLIDMODEL: "IfcSolidModel",
  IFCSLIPPAGECONNECTIONCONDITION: "IfcSlippageConnectionCondition",
  IFCSHELLBASEDSURFACEMODEL: "IfcShellBasedSurfaceModel",
  IFCSERVICELIFEFACTOR: "IfcServiceLifeFactor",
  IFCSECTIONEDSPINE: "IfcSectionedSpine",
  IFCROUNDEDRECTANGLEPROFILEDEF: "IfcRoundedRectangleProfileDef",
  IFCRELATIONSHIP: "IfcRelationship",
  IFCREINFORCEMENTDEFINITIONPROPERTIES: "IfcReinforcementDefinitionProperties",
  IFCREGULARTIMESERIES: "IfcRegularTimeSeries",
  IFCRECTANGLEPROFILEDEF: "IfcRectangleProfileDef",
  IFCPROPERTYTABLEVALUE: "IfcPropertyTableValue",
  IFCPROPERTYSINGLEVALUE: "IfcPropertySingleValue",
  IFCPROPERTYSETDEFINITION: "IfcPropertySetDefinition",
  IFCPROPERTYREFERENCEVALUE: "IfcPropertyReferenceValue",
  IFCPROPERTYLISTVALUE: "IfcPropertyListValue",
  IFCPROPERTYENUMERATEDVALUE: "IfcPropertyEnumeratedValue",
  IFCPROPERTYDEFINITION: "IfcPropertyDefinition",
  IFCPROPERTYBOUNDEDVALUE: "IfcPropertyBoundedValue",
  IFCPRODUCTDEFINITIONSHAPE: "IfcProductDefinitionShape",
  IFCPREDEFINEDPOINTMARKERSYMBOL: "IfcPredefinedPointMarkerSymbol",
  IFCPREDEFINEDDIMENSIONSYMBOL: "IfcPredefinedDimensionSymbol",
  IFCPREDEFINEDCURVEFONT: "IfcPredefinedCurveFont",
  IFCPREDEFINEDCOLOUR: "IfcPredefinedColour",
  IFCPOLYGONALBOUNDEDHALFSPACE: "IfcPolygonalBoundedHalfSpace",
  IFCPOLYLOOP: "IfcPolyLoop",
  IFCPOINTONSURFACE: "IfcPointOnSurface",
  IFCPOINTONCURVE: "IfcPointOnCurve",
  IFCPOINT: "IfcPoint",
  IFCPLANAREXTENT: "IfcPlanarExtent",
  IFCPLACEMENT: "IfcPlacement",
  IFCPIXELTEXTURE: "IfcPixelTexture",
  IFCPHYSICALCOMPLEXQUANTITY: "IfcPhysicalComplexQuantity",
  IFCPATH: "IfcPath",
  IFCPARAMETERIZEDPROFILEDEF: "IfcParameterizedProfileDef",
  IFCORIENTEDEDGE: "IfcOrientedEdge",
  IFCOPENSHELL: "IfcOpenShell",
  IFCONEDIRECTIONREPEATFACTOR: "IfcOneDirectionRepeatFactor",
  IFCOBJECTDEFINITION: "IfcObjectDefinition",
  IFCMECHANICALCONCRETEMATERIALPROPERTIES: "IfcMechanicalConcreteMaterialProperties",
  IFCMATERIALDEFINITIONREPRESENTATION: "IfcMaterialDefinitionRepresentation",
  IFCMAPPEDITEM: "IfcMappedItem",
  IFCLOOP: "IfcLoop",
  IFCLOCALPLACEMENT: "IfcLocalPlacement",
  IFCLIGHTSOURCESPOT: "IfcLightSourceSpot",
  IFCLIGHTSOURCEPOSITIONAL: "IfcLightSourcePositional",
  IFCLIGHTSOURCEGONIOMETRIC: "IfcLightSourceGoniometric",
  IFCLIGHTSOURCEDIRECTIONAL: "IfcLightSourceDirectional",
  IFCLIGHTSOURCEAMBIENT: "IfcLightSourceAmbient",
  IFCLIGHTSOURCE: "IfcLightSource",
  IFCIRREGULARTIMESERIES: "IfcIrregularTimeSeries",
  IFCIMAGETEXTURE: "IfcImageTexture",
  IFCHYGROSCOPICMATERIALPROPERTIES: "IfcHygroscopicMaterialProperties",
  IFCHALFSPACESOLID: "IfcHalfSpaceSolid",
  IFCGRIDPLACEMENT: "IfcGridPlacement",
  IFCGEOMETRICSET: "IfcGeometricSet",
  IFCGEOMETRICREPRESENTATIONSUBCONTEXT: "IfcGeometricRepresentationSubContext",
  IFCGEOMETRICREPRESENTATIONITEM: "IfcGeometricRepresentationItem",
  IFCGEOMETRICREPRESENTATIONCONTEXT: "IfcGeometricRepresentationContext",
  IFCGENERALPROFILEPROPERTIES: "IfcGeneralProfileProperties",
  IFCGENERALMATERIALPROPERTIES: "IfcGeneralMaterialProperties",
  IFCFUELPROPERTIES: "IfcFuelProperties",
  IFCFILLAREASTYLE: "IfcFillAreaStyle",
  IFCFAILURECONNECTIONCONDITION: "IfcFailureConnectionCondition",
  IFCFACESURFACE: "IfcFaceSurface",
  IFCFACEOUTERBOUND: "IfcFaceOuterBound",
  IFCFACEBOUND: "IfcFaceBound",
  IFCFACE: "IfcFace",
  IFCEXTENDEDMATERIALPROPERTIES: "IfcExtendedMaterialProperties",
  IFCEDGECURVE: "IfcEdgeCurve",
  IFCEDGE: "IfcEdge",
  IFCDRAUGHTINGPREDEFINEDTEXTFONT: "IfcDraughtingPredefinedTextFont",
  IFCDOCUMENTREFERENCE: "IfcDocumentReference",
  IFCDIMENSIONPAIR: "IfcDimensionPair",
  IFCDIMENSIONCALLOUTRELATIONSHIP: "IfcDimensionCalloutRelationship",
  IFCDERIVEDPROFILEDEF: "IfcDerivedProfileDef",
  IFCCURVESTYLE: "IfcCurveStyle",
  IFCCONVERSIONBASEDUNIT: "IfcConversionBasedUnit",
  IFCCONTEXTDEPENDENTUNIT: "IfcContextDependentUnit",
  IFCCONNECTIONPOINTECCENTRICITY: "IfcConnectionPointEccentricity",
  IFCCONNECTIONCURVEGEOMETRY: "IfcConnectionCurveGeometry",
  IFCCONNECTEDFACESET: "IfcConnectedFaceSet",
  IFCCOMPOSITEPROFILEDEF: "IfcCompositeProfileDef",
  IFCCOMPLEXPROPERTY: "IfcComplexProperty",
  IFCCOLOURRGB: "IfcColourRgb",
  IFCCLASSIFICATIONREFERENCE: "IfcClassificationReference",
  IFCCENTERLINEPROFILEDEF: "IfcCenterLineProfileDef",
  IFCBLOBTEXTURE: "IfcBlobTexture",
  IFCARBITRARYPROFILEDEFWITHVOIDS: "IfcArbitraryProfileDefWithVoids",
  IFCARBITRARYOPENPROFILEDEF: "IfcArbitraryOpenProfileDef",
  IFCARBITRARYCLOSEDPROFILEDEF: "IfcArbitraryClosedProfileDef",
  IFCANNOTATIONTEXTOCCURRENCE: "IfcAnnotationTextOccurrence",
  IFCANNOTATIONSYMBOLOCCURRENCE: "IfcAnnotationSymbolOccurrence",
  IFCANNOTATIONSURFACEOCCURRENCE: "IfcAnnotationSurfaceOccurrence",
  IFCANNOTATIONOCCURRENCE: "IfcAnnotationOccurrence",
  IFCWATERPROPERTIES: "IfcWaterProperties",
  IFCVIRTUALGRIDINTERSECTION: "IfcVirtualGridIntersection",
  IFCVERTEXPOINT: "IfcVertexPoint",
  IFCVERTEXBASEDTEXTUREMAP: "IfcVertexBasedTextureMap",
  IFCVERTEX: "IfcVertex",
  IFCUNITASSIGNMENT: "IfcUnitAssignment",
  IFCTOPOLOGYREPRESENTATION: "IfcTopologyRepresentation",
  IFCTOPOLOGICALREPRESENTATIONITEM: "IfcTopologicalRepresentationItem",
  IFCTIMESERIESVALUE: "IfcTimeSeriesValue",
  IFCTIMESERIESREFERENCERELATIONSHIP: "IfcTimeSeriesReferenceRelationship",
  IFCTIMESERIES: "IfcTimeSeries",
  IFCTHERMALMATERIALPROPERTIES: "IfcThermalMaterialProperties",
  IFCTEXTUREVERTEX: "IfcTextureVertex",
  IFCTEXTUREMAP: "IfcTextureMap",
  IFCTEXTURECOORDINATEGENERATOR: "IfcTextureCoordinateGenerator",
  IFCTEXTURECOORDINATE: "IfcTextureCoordinate",
  IFCTEXTSTYLEWITHBOXCHARACTERISTICS: "IfcTextStyleWithBoxCharacteristics",
  IFCTEXTSTYLETEXTMODEL: "IfcTextStyleTextModel",
  IFCTEXTSTYLEFORDEFINEDFONT: "IfcTextStyleForDefinedFont",
  IFCTEXTSTYLEFONTMODEL: "IfcTextStyleFontModel",
  IFCTEXTSTYLE: "IfcTextStyle",
  IFCTELECOMADDRESS: "IfcTelecomAddress",
  IFCTABLEROW: "IfcTableRow",
  IFCTABLE: "IfcTable",
  IFCSYMBOLSTYLE: "IfcSymbolStyle",
  IFCSURFACETEXTURE: "IfcSurfaceTexture",
  IFCSURFACESTYLEWITHTEXTURES: "IfcSurfaceStyleWithTextures",
  IFCSURFACESTYLESHADING: "IfcSurfaceStyleShading",
  IFCSURFACESTYLEREFRACTION: "IfcSurfaceStyleRefraction",
  IFCSURFACESTYLELIGHTING: "IfcSurfaceStyleLighting",
  IFCSURFACESTYLE: "IfcSurfaceStyle",
  IFCSTYLEDREPRESENTATION: "IfcStyledRepresentation",
  IFCSTYLEDITEM: "IfcStyledItem",
  IFCSTYLEMODEL: "IfcStyleModel",
  IFCSTRUCTURALLOADTEMPERATURE: "IfcStructuralLoadTemperature",
  IFCSTRUCTURALLOADSTATIC: "IfcStructuralLoadStatic",
  IFCSTRUCTURALLOAD: "IfcStructuralLoad",
  IFCSTRUCTURALCONNECTIONCONDITION: "IfcStructuralConnectionCondition",
  IFCSIMPLEPROPERTY: "IfcSimpleProperty",
  IFCSHAPEREPRESENTATION: "IfcShapeRepresentation",
  IFCSHAPEMODEL: "IfcShapeModel",
  IFCSHAPEASPECT: "IfcShapeAspect",
  IFCSECTIONREINFORCEMENTPROPERTIES: "IfcSectionReinforcementProperties",
  IFCSECTIONPROPERTIES: "IfcSectionProperties",
  IFCSIUNIT: "IfcSIUnit",
  IFCROOT: "IfcRoot",
  IFCRIBPLATEPROFILEPROPERTIES: "IfcRibPlateProfileProperties",
  IFCREPRESENTATIONMAP: "IfcRepresentationMap",
  IFCREPRESENTATIONITEM: "IfcRepresentationItem",
  IFCREPRESENTATIONCONTEXT: "IfcRepresentationContext",
  IFCREPRESENTATION: "IfcRepresentation",
  IFCRELAXATION: "IfcRelaxation",
  IFCREINFORCEMENTBARPROPERTIES: "IfcReinforcementBarProperties",
  IFCREFERENCESVALUEDOCUMENT: "IfcReferencesValueDocument",
  IFCQUANTITYWEIGHT: "IfcQuantityWeight",
  IFCQUANTITYVOLUME: "IfcQuantityVolume",
  IFCQUANTITYTIME: "IfcQuantityTime",
  IFCQUANTITYLENGTH: "IfcQuantityLength",
  IFCQUANTITYCOUNT: "IfcQuantityCount",
  IFCQUANTITYAREA: "IfcQuantityArea",
  IFCPROPERTYENUMERATION: "IfcPropertyEnumeration",
  IFCPROPERTYDEPENDENCYRELATIONSHIP: "IfcPropertyDependencyRelationship",
  IFCPROPERTYCONSTRAINTRELATIONSHIP: "IfcPropertyConstraintRelationship",
  IFCPROPERTY: "IfcProperty",
  IFCPROFILEPROPERTIES: "IfcProfileProperties",
  IFCPROFILEDEF: "IfcProfileDef",
  IFCPRODUCTSOFCOMBUSTIONPROPERTIES: "IfcProductsOfCombustionProperties",
  IFCPRODUCTREPRESENTATION: "IfcProductRepresentation",
  IFCPRESENTATIONSTYLEASSIGNMENT: "IfcPresentationStyleAssignment",
  IFCPRESENTATIONSTYLE: "IfcPresentationStyle",
  IFCPRESENTATIONLAYERWITHSTYLE: "IfcPresentationLayerWithStyle",
  IFCPRESENTATIONLAYERASSIGNMENT: "IfcPresentationLayerAssignment",
  IFCPREDEFINEDTEXTFONT: "IfcPredefinedTextFont",
  IFCPREDEFINEDTERMINATORSYMBOL: "IfcPredefinedTerminatorSymbol",
  IFCPREDEFINEDSYMBOL: "IfcPredefinedSymbol",
  IFCPREDEFINEDITEM: "IfcPredefinedItem",
  IFCPOSTALADDRESS: "IfcPostalAddress",
  IFCPHYSICALSIMPLEQUANTITY: "IfcPhysicalSimpleQuantity",
  IFCPHYSICALQUANTITY: "IfcPhysicalQuantity",
  IFCPERSONANDORGANIZATION: "IfcPersonAndOrganization",
  IFCPERSON: "IfcPerson",
  IFCOWNERHISTORY: "IfcOwnerHistory",
  IFCORGANIZATIONRELATIONSHIP: "IfcOrganizationRelationship",
  IFCORGANIZATION: "IfcOrganization",
  IFCOPTICALMATERIALPROPERTIES: "IfcOpticalMaterialProperties",
  IFCOBJECTIVE: "IfcObjective",
  IFCOBJECTPLACEMENT: "IfcObjectPlacement",
  IFCNAMEDUNIT: "IfcNamedUnit",
  IFCMONETARYUNIT: "IfcMonetaryUnit",
  IFCMETRIC: "IfcMetric",
  IFCMECHANICALSTEELMATERIALPROPERTIES: "IfcMechanicalSteelMaterialProperties",
  IFCMECHANICALMATERIALPROPERTIES: "IfcMechanicalMaterialProperties",
  IFCMEASUREWITHUNIT: "IfcMeasureWithUnit",
  IFCMATERIALPROPERTIES: "IfcMaterialProperties",
  IFCMATERIALLIST: "IfcMaterialList",
  IFCMATERIALLAYERSETUSAGE: "IfcMaterialLayerSetUsage",
  IFCMATERIALLAYERSET: "IfcMaterialLayerSet",
  IFCMATERIALLAYER: "IfcMaterialLayer",
  IFCMATERIALCLASSIFICATIONRELATIONSHIP: "IfcMaterialClassificationRelationship",
  IFCMATERIAL: "IfcMaterial",
  IFCLOCALTIME: "IfcLocalTime",
  IFCLIGHTINTENSITYDISTRIBUTION: "IfcLightIntensityDistribution",
  IFCLIGHTDISTRIBUTIONDATA: "IfcLightDistributionData",
  IFCLIBRARYREFERENCE: "IfcLibraryReference",
  IFCLIBRARYINFORMATION: "IfcLibraryInformation",
  IFCIRREGULARTIMESERIESVALUE: "IfcIrregularTimeSeriesValue",
  IFCGRIDAXIS: "IfcGridAxis",
  IFCEXTERNALLYDEFINEDTEXTFONT: "IfcExternallyDefinedTextFont",
  IFCEXTERNALLYDEFINEDSYMBOL: "IfcExternallyDefinedSymbol",
  IFCEXTERNALLYDEFINEDSURFACESTYLE: "IfcExternallyDefinedSurfaceStyle",
  IFCEXTERNALLYDEFINEDHATCHSTYLE: "IfcExternallyDefinedHatchStyle",
  IFCEXTERNALREFERENCE: "IfcExternalReference",
  IFCENVIRONMENTALIMPACTVALUE: "IfcEnvironmentalImpactValue",
  IFCDRAUGHTINGCALLOUTRELATIONSHIP: "IfcDraughtingCalloutRelationship",
  IFCDOCUMENTINFORMATIONRELATIONSHIP: "IfcDocumentInformationRelationship",
  IFCDOCUMENTINFORMATION: "IfcDocumentInformation",
  IFCDOCUMENTELECTRONICFORMAT: "IfcDocumentElectronicFormat",
  IFCDIMENSIONALEXPONENTS: "IfcDimensionalExponents",
  IFCDERIVEDUNITELEMENT: "IfcDerivedUnitElement",
  IFCDERIVEDUNIT: "IfcDerivedUnit",
  IFCDATEANDTIME: "IfcDateAndTime",
  IFCCURVESTYLEFONTPATTERN: "IfcCurveStyleFontPattern",
  IFCCURVESTYLEFONTANDSCALING: "IfcCurveStyleFontAndScaling",
  IFCCURVESTYLEFONT: "IfcCurveStyleFont",
  IFCCURRENCYRELATIONSHIP: "IfcCurrencyRelationship",
  IFCCOSTVALUE: "IfcCostValue",
  IFCCOORDINATEDUNIVERSALTIMEOFFSET: "IfcCoordinatedUniversalTimeOffset",
  IFCCONSTRAINTRELATIONSHIP: "IfcConstraintRelationship",
  IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP: "IfcConstraintClassificationRelationship",
  IFCCONSTRAINTAGGREGATIONRELATIONSHIP: "IfcConstraintAggregationRelationship",
  IFCCONSTRAINT: "IfcConstraint",
  IFCCONNECTIONSURFACEGEOMETRY: "IfcConnectionSurfaceGeometry",
  IFCCONNECTIONPORTGEOMETRY: "IfcConnectionPortGeometry",
  IFCCONNECTIONPOINTGEOMETRY: "IfcConnectionPointGeometry",
  IFCCONNECTIONGEOMETRY: "IfcConnectionGeometry",
  IFCCOLOURSPECIFICATION: "IfcColourSpecification",
  IFCCLASSIFICATIONNOTATIONFACET: "IfcClassificationNotationFacet",
  IFCCLASSIFICATIONNOTATION: "IfcClassificationNotation",
  IFCCLASSIFICATIONITEMRELATIONSHIP: "IfcClassificationItemRelationship",
  IFCCLASSIFICATIONITEM: "IfcClassificationItem",
  IFCCLASSIFICATION: "IfcClassification",
  IFCCALENDARDATE: "IfcCalendarDate",
  IFCBOUNDARYNODECONDITIONWARPING: "IfcBoundaryNodeConditionWarping",
  IFCBOUNDARYNODECONDITION: "IfcBoundaryNodeCondition",
  IFCBOUNDARYFACECONDITION: "IfcBoundaryFaceCondition",
  IFCBOUNDARYEDGECONDITION: "IfcBoundaryEdgeCondition",
  IFCBOUNDARYCONDITION: "IfcBoundaryCondition",
  IFCAPPROVALRELATIONSHIP: "IfcApprovalRelationship",
  IFCAPPROVALPROPERTYRELATIONSHIP: "IfcApprovalPropertyRelationship",
  IFCAPPROVALACTORRELATIONSHIP: "IfcApprovalActorRelationship",
  IFCAPPROVAL: "IfcApproval",
  IFCAPPLIEDVALUERELATIONSHIP: "IfcAppliedValueRelationship",
  IFCAPPLIEDVALUE: "IfcAppliedValue",
  IFCAPPLICATION: "IfcApplication",
  IFCADDRESS: "IfcAddress",
  IFCACTORROLE: "IfcActorRole"
};
var Units = class {
  constructor() {
    __publicField(this, "factor", 1);
    __publicField(this, "complement", 1);
  }
  apply(matrix) {
    const scale = this.getScaleMatrix();
    const result = scale.multiply(matrix);
    matrix.copy(result);
  }
  setUp(webIfc) {
    var _a22, _b, _c2;
    this.factor = 1;
    const length = this.getLengthUnits(webIfc);
    if (!length) {
      return;
    }
    const isLengthNull = length === void 0 || length === null;
    const isValueNull = length.Name === void 0 || length.Name === null;
    if (isLengthNull || isValueNull) {
      return;
    }
    if (length.Name.value === "FOOT") {
      this.factor = 0.3048;
    }
    if (((_a22 = length.Prefix) == null ? void 0 : _a22.value) === "MILLI") {
      this.complement = 1e-3;
    } else if (((_b = length.Prefix) == null ? void 0 : _b.value) === "CENTI") {
      this.complement = 0.01;
    } else if (((_c2 = length.Prefix) == null ? void 0 : _c2.value) === "DECI") {
      this.complement = 0.01;
    }
  }
  getLengthUnits(webIfc) {
    try {
      const allUnitsAssigns = webIfc.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      );
      const unitsAssign = allUnitsAssigns.get(0);
      const unitsAssignProps = webIfc.GetLine(0, unitsAssign);
      for (const units of unitsAssignProps.Units) {
        if (!units || units.value === null || units.value === void 0) {
          continue;
        }
        const unitsProps = webIfc.GetLine(0, units.value);
        if (unitsProps.UnitType && unitsProps.UnitType.value === "LENGTHUNIT") {
          return unitsProps;
        }
      }
      return null;
    } catch (e2) {
      console.log("Could not get units");
      return null;
    }
  }
  getScaleMatrix() {
    const f = this.factor;
    return new Matrix4().fromArray([
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var SpatialStructure = class {
  constructor() {
    __publicField(this, "itemsByFloor", {});
    __publicField(this, "_units", new Units());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(webIfc) {
    this._units.setUp(webIfc);
    this.cleanUp();
    try {
      const spatialRels = webIfc.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      );
      const allRooms = /* @__PURE__ */ new Set();
      const rooms = webIfc.GetLineIDsWithType(0, IFCSPACE);
      for (let i = 0; i < rooms.size(); i++) {
        allRooms.add(rooms.get(i));
      }
      const aggregates = webIfc.GetLineIDsWithType(0, IFCRELAGGREGATES);
      const aggregatesSize = aggregates.size();
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          if (allRooms.has(childID)) {
            this.itemsByFloor[childID] = parentID;
          }
        }
      }
      const itemsContainedInRooms = {};
      const spatialRelsSize = spatialRels.size();
      for (let i = 0; i < spatialRelsSize; i++) {
        const id = spatialRels.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingStructure || !properties.RelatedElements) {
          continue;
        }
        const structureID = properties.RelatingStructure.value;
        const relatedItems = properties.RelatedElements;
        if (allRooms.has(structureID)) {
          for (const related of relatedItems) {
            if (!itemsContainedInRooms[structureID]) {
              itemsContainedInRooms[structureID] = [];
            }
            const id2 = related.value;
            itemsContainedInRooms[structureID].push(id2);
          }
        } else {
          for (const related of relatedItems) {
            const id2 = related.value;
            this.itemsByFloor[id2] = structureID;
          }
        }
      }
      for (const roomID in itemsContainedInRooms) {
        const roomFloor = this.itemsByFloor[roomID];
        if (roomFloor !== void 0) {
          const items = itemsContainedInRooms[roomID];
          for (const item of items) {
            this.itemsByFloor[item] = roomFloor;
          }
        }
      }
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          const parentStructure = this.itemsByFloor[parentID];
          if (parentStructure !== void 0) {
            this.itemsByFloor[childID] = parentStructure;
          }
        }
      }
    } catch (e2) {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var IfcFragmentSettings = class {
  constructor() {
    __publicField(this, "includeProperties", true);
    __publicField(this, "optionalCategories", [IFCSPACE]);
    __publicField(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    });
    __publicField(this, "excludedCategories", /* @__PURE__ */ new Set());
    __publicField(this, "includedCategories", /* @__PURE__ */ new Set());
    __publicField(this, "saveLocations", false);
    __publicField(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    });
    __publicField(this, "autoSetWasm", true);
    __publicField(this, "customLocateFileHandler", null);
  }
};
var CivilReader = class {
  constructor() {
    __publicField(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(webIfc) {
    const IfcAlignment = webIfc.GetAllAlignments(0);
    const IfcCrossSection2D = webIfc.GetAllCrossSections2D(0);
    const IfcCrossSection3D = webIfc.GetAllCrossSections3D(0);
    const civilItems = {
      IfcAlignment,
      IfcCrossSection2D,
      IfcCrossSection3D
    };
    return this.get(civilItems);
  }
  get(civilItems) {
    if (civilItems.IfcAlignment) {
      const alignments = /* @__PURE__ */ new Map();
      for (const ifcAlign of civilItems.IfcAlignment) {
        const alignment = new Gc();
        alignment.absolute = this.getCurves(ifcAlign.curve3D, alignment);
        alignment.horizontal = this.getCurves(ifcAlign.horizontal, alignment);
        alignment.vertical = this.getCurves(ifcAlign.vertical, alignment);
        alignments.set(alignments.size, alignment);
      }
      return { alignments, coordinationMatrix: new Matrix4() };
    }
    return void 0;
  }
  getCurves(ifcAlignData, alignment) {
    const curves = [];
    let index = 0;
    for (const curve of ifcAlignData) {
      const data = {};
      if (curve.data) {
        for (const entry of curve.data) {
          const [key, value] = entry.split(": ");
          const numValue = parseFloat(value);
          data[key] = numValue || value;
        }
      }
      const { points } = curve;
      const array = new Float32Array(points.length * 3);
      for (let i = 0; i < points.length; i++) {
        const { x, y, z: z2 } = points[i];
        array[i * 3] = x;
        array[i * 3 + 1] = y;
        array[i * 3 + 2] = z2 || 0;
      }
      const attr = new BufferAttribute(array, 3);
      const geometry = new EdgesGeometry();
      geometry.setAttribute("position", attr);
      const mesh = new Yc(
        index,
        data,
        alignment,
        geometry,
        this.defLineMat
      );
      curves.push(mesh.curve);
      index++;
    }
    return curves;
  }
};
var IfcMetadataReader = class {
  getNameInfo(webIfc) {
    var _a22;
    const data = {};
    const { arguments: dataArguments } = webIfc.GetHeaderLine(0, FILE_NAME) || {};
    if (!dataArguments)
      return data;
    const [
      name,
      timeStamp,
      author,
      organization,
      preprocessorVersion,
      originatingSystem,
      authorization
    ] = dataArguments;
    if (name == null ? void 0 : name.value)
      data.name = name.value;
    if (timeStamp == null ? void 0 : timeStamp.value)
      data.creationDate = new Date(timeStamp.value);
    if (author) {
      data.author = {};
      const [authorName, authorEmail] = author;
      if (authorName == null ? void 0 : authorName.value)
        data.author.name = authorName.value;
      if (authorEmail == null ? void 0 : authorEmail.value)
        data.author.email = authorEmail.value;
    }
    if (organization && ((_a22 = organization[0]) == null ? void 0 : _a22.value)) {
      data.organization = organization[0].value;
    }
    if (preprocessorVersion == null ? void 0 : preprocessorVersion.value) {
      data.preprocessorVersion = preprocessorVersion == null ? void 0 : preprocessorVersion.value;
    }
    if (originatingSystem == null ? void 0 : originatingSystem.value) {
      data.originatingSystem = originatingSystem == null ? void 0 : originatingSystem.value;
    }
    if (authorization == null ? void 0 : authorization.value) {
      data.authorization = authorization == null ? void 0 : authorization.value;
    }
    return data;
  }
  getDescriptionInfo(webIfc) {
    var _a22;
    const data = {};
    const { arguments: dataArguments } = webIfc.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!dataArguments)
      return data;
    const [description, implementationLevel] = dataArguments;
    if (Array.isArray(description) && ((_a22 = description[0]) == null ? void 0 : _a22.value)) {
      const viewDefinition = description[0].value.match(/\[([^\]]+)\]/);
      if (viewDefinition && viewDefinition[1]) {
        data.viewDefinition = viewDefinition[1];
      }
    }
    if (implementationLevel == null ? void 0 : implementationLevel.value)
      data.implementationLevel = implementationLevel.value;
    return data;
  }
};
var SpatialIdsFinder = class {
  static get(model, webIfc) {
    const spatialTypes = [
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE,
      IFCROAD,
      IFCFACILITY,
      IFCFACILITYPART,
      IFCBRIDGE
    ];
    const data = model.data;
    for (const category of spatialTypes) {
      const ids = webIfc.GetLineIDsWithType(0, category);
      const size = ids.size();
      for (let i = 0; i < size; i++) {
        const id = ids.get(i);
        if (!data.has(id)) {
          data.set(id, [[], [0, category]]);
        }
      }
    }
  }
};
var GeometryTypes = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014,
  2916149573
]);
var _IfcJsonExporter = class _IfcJsonExporter2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    components.add(_IfcJsonExporter2.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(webIfc, modelID, indirect = false, recursiveSpatial = true) {
    const properties = {};
    const allIfcEntities = new Set(webIfc.GetIfcEntityList(modelID));
    const spatialStructure = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const type of spatialStructure) {
      allIfcEntities.add(type);
    }
    for (const type of allIfcEntities) {
      if (GeometryTypes.has(type)) {
        continue;
      }
      const recursive = spatialStructure.has(type) && recursiveSpatial;
      const ids = webIfc.GetLineIDsWithType(modelID, type);
      for (const id of ids) {
        try {
          const property = webIfc.GetLine(0, id, recursive, indirect);
          properties[property.expressID] = property;
        } catch (e2) {
          console.log(
            `Could not get property ${id}, with recursive ${recursive} and indirect ${indirect}.`
          );
        }
      }
    }
    return properties;
  }
};
__publicField(_IfcJsonExporter, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var IfcJsonExporter = _IfcJsonExporter;
var _IfcLoader = class _IfcLoader2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onIfcStartedLoading", new Event());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "settings", new IfcFragmentSettings());
    __publicField(this, "webIfc", new IfcAPI2());
    __publicField(this, "enabled", true);
    __publicField(this, "_material", new MeshLambertMaterial());
    __publicField(this, "_spatialTree", new SpatialStructure());
    __publicField(this, "_metaData", new IfcMetadataReader());
    __publicField(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    __publicField(this, "_civil", new CivilReader());
    __publicField(this, "_visitedFragments", /* @__PURE__ */ new Map());
    __publicField(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(_IfcLoader2.uuid, this);
    this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null;
    this.onDisposed.trigger(_IfcLoader2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(config) {
    this.settings = { ...this.settings, ...config };
    if (this.settings.autoSetWasm) {
      await this.autoSetWasm();
    }
    this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(data, coordinate = true, name = "") {
    const before = performance.now();
    this.onIfcStartedLoading.trigger();
    await this.readIfcFile(data);
    const group = await this.getAllGeometries();
    group.name = name;
    const jsonExporter = this.components.get(IfcJsonExporter);
    const properties = await jsonExporter.export(this.webIfc, 0);
    group.setLocalProperties(properties);
    const fragments = this.components.get(FragmentsManager);
    fragments.groups.set(group.uuid, group);
    for (const frag of group.items) {
      fragments.list.set(frag.id, frag);
      frag.mesh.uuid = frag.id;
      frag.group = group;
    }
    fragments.onFragmentsLoaded.trigger(group);
    if (coordinate) {
      fragments.coordinate([group]);
    }
    for (const [expressID] of group.data) {
      const props = properties[expressID];
      if (!props || !props.GlobalId)
        continue;
      const globalID = props.GlobalId.value || props.GlobalId;
      group.globalToExpressIDs.set(globalID, expressID);
    }
    SpatialIdsFinder.get(group, this.webIfc);
    this.cleanUp();
    console.log(`Streaming the IFC took ${performance.now() - before} ms!`);
    return group;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init(this.settings.customLocateFileHandler || void 0);
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    return this.webIfc.OpenModel(data, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch (e2) {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
    this._visitedFragments.clear();
    this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const allIfcEntities = this.webIfc.GetIfcEntityList(0);
    const group = new Bc();
    group.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const ids = [];
    for (const type of allIfcEntities) {
      if (!this.webIfc.IsIfcElement(type) && type !== IFCSPACE) {
        continue;
      }
      const included = this.settings.includedCategories;
      if (included.size > 0 && !included.has(type)) {
        continue;
      } else if (this.settings.excludedCategories.has(type)) {
        continue;
      }
      const result = this.webIfc.GetLineIDsWithType(0, type);
      const size = result.size();
      for (let i = 0; i < size; i++) {
        const itemID = result.get(i);
        ids.push(itemID);
        const level = this._spatialTree.itemsByFloor[itemID] || 0;
        group.data.set(itemID, [[], [level, type]]);
      }
    }
    this._spatialTree.cleanUp();
    this.webIfc.StreamMeshes(0, ids, (mesh) => {
      this.getMesh(mesh, group);
    });
    for (const entry of this._visitedFragments) {
      const { index, fragment } = entry[1];
      group.keyFragments.set(index, fragment.id);
    }
    for (const fragment of group.items) {
      const fragmentData = this._fragmentInstances.get(fragment.id);
      if (!fragmentData) {
        throw new Error("Fragment not found!");
      }
      const items = [];
      for (const [_geomID, item] of fragmentData) {
        items.push(item);
      }
      fragment.add(items);
    }
    const matrix = this.webIfc.GetCoordinationMatrix(0);
    group.coordinationMatrix.fromArray(matrix);
    group.civilData = this._civil.read(this.webIfc);
    return group;
  }
  getMesh(mesh, group) {
    const size = mesh.geometries.size();
    const id = mesh.expressID;
    for (let i = 0; i < size; i++) {
      const geometry = mesh.geometries.get(i);
      const { x, y, z: z2, w } = geometry.color;
      const transparent = w !== 1;
      const { geometryExpressID } = geometry;
      const geometryID = `${geometryExpressID}-${transparent}`;
      if (!this._visitedFragments.has(geometryID)) {
        const bufferGeometry = this.getGeometry(this.webIfc, geometryExpressID);
        const material = transparent ? this._materialT : this._material;
        const fragment2 = new Ac(bufferGeometry, material, 1);
        group.add(fragment2.mesh);
        group.items.push(fragment2);
        const index = this._visitedFragments.size;
        this._visitedFragments.set(geometryID, { index, fragment: fragment2 });
      }
      const color = new Color().setRGB(x, y, z2, "srgb");
      const transform = new Matrix4();
      transform.fromArray(geometry.flatTransformation);
      const fragmentData = this._visitedFragments.get(geometryID);
      if (fragmentData === void 0) {
        throw new Error("Error getting geometry data for streaming!");
      }
      const data = group.data.get(id);
      if (!data) {
        throw new Error("Data not found!");
      }
      data[0].push(fragmentData.index);
      const { fragment } = fragmentData;
      if (!this._fragmentInstances.has(fragment.id)) {
        this._fragmentInstances.set(fragment.id, /* @__PURE__ */ new Map());
      }
      const instances = this._fragmentInstances.get(fragment.id);
      if (!instances) {
        throw new Error("Instances not found!");
      }
      if (instances.has(id)) {
        const instance = instances.get(id);
        if (!instance) {
          throw new Error("Instance not found!");
        }
        instance.transforms.push(transform);
        if (instance.colors) {
          instance.colors.push(color);
        }
      } else {
        instances.set(id, { id, transforms: [transform], colors: [color] });
      }
    }
  }
  getGeometry(webIfc, id) {
    const geometry = webIfc.GetGeometry(0, id);
    const index = webIfc.GetIndexArray(
      geometry.GetIndexData(),
      geometry.GetIndexDataSize()
    );
    const vertexData = webIfc.GetVertexArray(
      geometry.GetVertexData(),
      geometry.GetVertexDataSize()
    );
    const position = new Float32Array(vertexData.length / 2);
    const normal = new Float32Array(vertexData.length / 2);
    for (let i = 0; i < vertexData.length; i += 6) {
      position[i / 2] = vertexData[i];
      position[i / 2 + 1] = vertexData[i + 1];
      position[i / 2 + 2] = vertexData[i + 2];
      normal[i / 2] = vertexData[i + 3];
      normal[i / 2 + 1] = vertexData[i + 4];
      normal[i / 2 + 2] = vertexData[i + 5];
    }
    const bufferGeometry = new BufferGeometry();
    const posAttr = new BufferAttribute(position, 3);
    const norAttr = new BufferAttribute(normal, 3);
    bufferGeometry.setAttribute("position", posAttr);
    bufferGeometry.setAttribute("normal", norAttr);
    bufferGeometry.setIndex(Array.from(index));
    geometry.delete();
    return bufferGeometry;
  }
  async autoSetWasm() {
    const componentsPackage = await fetch(
      `https://unpkg.com/@thatopen/components@${Components.release}/package.json`
    );
    if (!componentsPackage.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const componentsPackageJSON = await componentsPackage.json();
    if (!("web-ifc" in componentsPackageJSON.peerDependencies)) {
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    } else {
      const webIfcVer = componentsPackageJSON.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${webIfcVer}/`;
      this.settings.wasm.absolute = true;
    }
  }
};
__publicField(_IfcLoader, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var IfcLoader = _IfcLoader;
var ifcRelAttrsPosition = {
  // IfcRelAssigns
  IfcRelAssignsToControl: { related: 5, relating: 7 },
  IfcRelAssignsToGroup: { related: 5, relating: 7 },
  IfcRelAssignsToProduct: { related: 5, relating: 7 },
  // IfcRelAssociates
  IfcRelAssociatesClassification: { related: 5, relating: 6 },
  IfcRelAssociatesMaterial: { related: 5, relating: 6 },
  IfcRelAssociatesDocument: { related: 5, relating: 6 },
  // IfcRelConnects
  IfcRelContainedInSpatialStructure: { related: 5, relating: 6 },
  IfcRelFlowControlElements: { related: 5, relating: 6 },
  IfcRelConnectsElements: { related: 7, relating: 6 },
  // IfcRelDeclares
  IfcRelDeclares: { related: 6, relating: 5 },
  // IfcRelDecomposes
  IfcRelAggregates: { related: 6, relating: 5 },
  IfcRelNests: { related: 6, relating: 5 },
  // IfcRelDefines
  IfcRelDefinesByProperties: { related: 5, relating: 6 },
  IfcRelDefinesByType: { related: 5, relating: 6 },
  IfcRelDefinesByTemplate: { related: 5, relating: 6 }
};
var ifcRelClassNames = {
  // IfcRelAssigns
  [IFCRELASSIGNSTOCONTROL]: "IfcRelAssignsToControl",
  [IFCRELASSIGNSTOGROUP]: "IfcRelAssignsToGroup",
  [IFCRELASSIGNSTOPRODUCT]: "IfcRelAssignsToProduct",
  // IfcRelAssociates
  [IFCRELASSOCIATESCLASSIFICATION]: "IfcRelAssociatesClassification",
  [IFCRELASSOCIATESMATERIAL]: "IfcRelAssociatesMaterial",
  [IFCRELASSOCIATESDOCUMENT]: "IfcRelAssociatesDocument",
  // IfcRelConnects
  [IFCRELCONTAINEDINSPATIALSTRUCTURE]: "IfcRelContainedInSpatialStructure",
  [IFCRELCONNECTSELEMENTS]: "IfcRelConnectsElements",
  [IFCRELFLOWCONTROLELEMENTS]: "IfcRelFlowControlElements",
  // IfcRelDeclares
  [IFCRELDECLARES]: "IfcRelDeclares",
  // IfcRelDecomposes
  [IFCRELAGGREGATES]: "IfcRelAggregates",
  [IFCRELNESTS]: "IfcRelNests",
  // IfcRelDefines
  [IFCRELDEFINESBYPROPERTIES]: "IfcRelDefinesByProperties",
  [IFCRELDEFINESBYTYPE]: "IfcRelDefinesByType",
  [IFCRELDEFINESBYTEMPLATE]: "IfcRelDefinesByTemplate"
};
var _IfcPropertiesManager = class _IfcPropertiesManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onRequestFile", new Event());
    __publicField(this, "ifcToExport", null);
    __publicField(this, "onElementToPset", new Event());
    __publicField(this, "onPropToPset", new Event());
    __publicField(this, "onPsetRemoved", new Event());
    __publicField(this, "onDataChanged", new Event());
    __publicField(this, "wasm", {
      path: "/",
      absolute: false
    });
    __publicField(this, "enabled", true);
    __publicField(this, "attributeListeners", {});
    __publicField(this, "selectedModel");
    __publicField(this, "changeMap", {});
    this.components.add(_IfcPropertiesManager2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0;
    this.attributeListeners = {};
    this.changeMap = {};
    this.onElementToPset.reset();
    this.onPropToPset.reset();
    this.onPsetRemoved.reset();
    this.onDataChanged.reset();
    this.onDisposed.trigger(_IfcPropertiesManager2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(model) {
    const schema = model.ifcMetadata.schema;
    if (!schema) {
      throw new Error("IFC Schema not found");
    }
    if (schema.startsWith("IFC2X3")) {
      return "IFC2X3";
    }
    if (schema.startsWith("IFC4") && schema.replace("IFC4", "") === "") {
      return "IFC4";
    }
    if (schema.startsWith("IFC4X3")) {
      return "IFC4X3";
    }
    return schema;
  }
  /**
   * Method to add or update entity attributes in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(model, ...dataToSave) {
    for (const data of dataToSave) {
      const { expressID } = data;
      if (!expressID || expressID === -1) {
        data.expressID = this.getNewExpressID(model);
      }
      await model.setProperties(data.expressID, data);
      this.registerChange(model, data.expressID);
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(model, name, description) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const { handle: ownerHistoryHandle } = await this.getOwnerHistory(model);
    const psetGlobalId = this.newGUID(model);
    const psetName = new web_ifc_api_exports[schema].IfcLabel(name);
    const psetDescription = description ? new web_ifc_api_exports[schema].IfcText(description) : null;
    const pset = new web_ifc_api_exports[schema].IfcPropertySet(
      psetGlobalId,
      ownerHistoryHandle,
      psetName,
      psetDescription,
      []
    );
    pset.expressID = this.getNewExpressID(model);
    await this.setData(model, pset);
    return { pset };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(model, ...psetID) {
    for (const expressID of psetID) {
      const pset = await model.getProperties(expressID);
      if ((pset == null ? void 0 : pset.type) !== IFCPROPERTYSET)
        continue;
      const relID = await IfcPropertiesUtils.getPsetRel(model, expressID);
      if (relID) {
        await model.setProperties(relID, null);
        this.registerChange(model, relID);
      }
      if (pset) {
        for (const propHandle of pset.HasProperties) {
          await model.setProperties(propHandle.value, null);
        }
        await model.setProperties(expressID, null);
        this.onPsetRemoved.trigger({ model, psetID: expressID });
        this.registerChange(model, expressID);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(model, psetID, propID) {
    const pset = await model.getProperties(psetID);
    const prop = await model.getProperties(propID);
    if (!pset || !prop)
      return;
    if (!(pset.type === IFCPROPERTYSET && prop))
      return;
    pset.HasProperties = pset.HasProperties.filter((handle) => {
      return handle.value !== propID;
    });
    await model.setProperties(propID, null);
    this.registerChange(model, psetID, propID);
  }
  /**
   * @deprecated Use indexer.addEntitiesRelation instead. This will be removed in future releases.
   */
  addElementToPset(model, psetID, ...expressIDs) {
    const indexer = this.components.get(IfcRelationsIndexer);
    indexer.addEntitiesRelation(
      model,
      psetID,
      { type: IFCRELDEFINESBYPROPERTIES, inv: "DefinesOcurrence" },
      ...expressIDs
    );
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(model, psetID, ...propID) {
    const pset = await model.getProperties(psetID);
    if (!pset)
      return;
    for (const expressID of propID) {
      if (pset.HasProperties.includes(expressID)) {
        continue;
      }
      const elementHandle = new Handle(expressID);
      pset.HasProperties.push(elementHandle);
      this.onPropToPset.trigger({ model, psetID, propID: expressID });
    }
    this.registerChange(model, psetID);
  }
  /**
   * Creates a new instance of a relationship between entities in the IFC model.
   *
   * @param model - The FragmentsGroup model in which to create the relationship.
   * @param type - The type of the relationship to create.
   * @param relatingID - The express ID of the entity that is related to the other entities.
   * @param relatedIDs - The express IDs of the entities that are related to the relating entity.
   *
   * @returns A promise that resolves with the newly created relationship.
   *
   * @throws Will throw an error if the relationship type is unsupported.
   */
  async createIfcRel(model, type, relatingID, relatedIDs) {
    const relName = ifcRelClassNames[type];
    if (!relName) {
      throw new Error(`IfcPropertiesManager: ${relName} is unsoported.`);
    }
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const attributePositions = ifcRelAttrsPosition[relName];
    const RelClass = web_ifc_api_exports[schema][relName];
    if (!(attributePositions && RelClass)) {
      throw new Error(`IfcPropertiesManager: ${relName} is unsoported.`);
    }
    const args = [new web_ifc_api_exports[schema].IfcGloballyUniqueId(UUID.create())];
    const { related, relating } = attributePositions;
    const relatedIDsSet = new Set(relatedIDs);
    const relatingHandles = [...relatedIDsSet].map(
      (expressID) => new Handle(expressID)
    );
    const addNulls = (start, end) => {
      for (let i = start; i < end - 1; i++)
        args.push(null);
    };
    if (related < relating) {
      addNulls(1, related);
      args.push(relatingHandles);
      addNulls(related, relating);
      args.push(new Handle(relatingID));
    } else {
      addNulls(1, relating);
      addNulls(relating, related);
      args.push(new Handle(relatingID));
      args.push(relatingHandles);
    }
    const ifcRel = new RelClass(...args);
    await this.setData(model, ifcRel);
    return ifcRel;
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(model, ifcToSaveOn) {
    const ifcLoader = this.components.get(IfcLoader);
    const ifcApi = ifcLoader.webIfc;
    const modelID = await ifcLoader.readIfcFile(ifcToSaveOn);
    const indexer = this.components.get(IfcRelationsIndexer);
    await indexer.applyRelationChanges();
    const changes = this.changeMap[model.uuid] ?? [];
    for (const expressID of changes) {
      const data = await model.getProperties(expressID);
      if (!data) {
        const existed = ifcApi.GetLine(modelID, expressID);
        if (existed)
          ifcApi.DeleteLine(modelID, expressID);
      } else {
        ifcApi.WriteLine(modelID, data);
      }
    }
    const modifiedIFC = ifcApi.SaveModel(modelID);
    ifcLoader.webIfc.CloseModel(modelID);
    ifcLoader.cleanUp();
    return modifiedIFC;
  }
  /**
   * Retrieves all the entities of a specific type from the model and returns their express IDs wrapped in Handles.
   * This is used to make references of an entity inside another entity attributes.
   *
   * @param model - The FragmentsGroup model from which to retrieve the entities.
   * @param type - The type of the entities to retrieve. This should be the express ID of the IFC type.
   *
   * @returns A promise that resolves with an array of Handles, each containing the express ID of an entity of the specified type.
   * @returns null if the model doesn't have any entity of that type
   */
  async getEntityRef(model, type) {
    const entities = await model.getAllPropertiesOfType(type);
    if (!entities)
      return null;
    const handles = [];
    for (const id in entities) {
      const handle = new Handle(Number(id));
      handles.push(handle);
    }
    return handles;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(model, expressID, attributeName) {
    if (!this.attributeListeners[model.uuid])
      this.attributeListeners[model.uuid] = {};
    const existingListener = this.attributeListeners[model.uuid][expressID] ? this.attributeListeners[model.uuid][expressID][attributeName] : null;
    if (existingListener)
      return existingListener;
    const entity = await model.getProperties(expressID);
    if (!entity) {
      throw new Error(`Entity with expressID ${expressID} doesn't exists.`);
    }
    const attribute = entity[attributeName];
    if (Array.isArray(attribute) || !attribute) {
      throw new Error(
        `Attribute ${attributeName} is array or null, and it can't have a listener.`
      );
    }
    const value = attribute.value;
    if (value === void 0 || value == null) {
      throw new Error(`Attribute ${attributeName} has a badly defined handle.`);
    }
    const event = new Event();
    Object.defineProperty(entity[attributeName], "value", {
      get() {
        return this._value;
      },
      async set(value2) {
        this._value = value2;
        event.trigger(value2);
      }
    });
    entity[attributeName].value = value;
    if (!this.attributeListeners[model.uuid][expressID])
      this.attributeListeners[model.uuid][expressID] = {};
    this.attributeListeners[model.uuid][expressID][attributeName] = event;
    return event;
  }
  getNewExpressID(model) {
    model.ifcMetadata.maxExpressID++;
    return model.ifcMetadata.maxExpressID;
  }
  newGUID(model) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    return new web_ifc_api_exports[schema].IfcGloballyUniqueId(UUID.create());
  }
  async getOwnerHistory(model) {
    const ownerHistories = await model.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!ownerHistories) {
      throw new Error("No OwnerHistory was found.");
    }
    const keys = Object.keys(ownerHistories).map((key) => parseInt(key, 10));
    const entity = ownerHistories[keys[0]];
    const handle = new Handle(entity.expressID);
    return { entity, handle };
  }
  registerChange(model, ...expressID) {
    if (!this.changeMap[model.uuid]) {
      this.changeMap[model.uuid] = /* @__PURE__ */ new Set();
    }
    for (const id of expressID) {
      this.changeMap[model.uuid].add(id);
      this.onDataChanged.trigger({ model, expressID: id });
    }
  }
  async newSingleProperty(model, type, name, value) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const propName2 = new web_ifc_api_exports[schema].IfcIdentifier(name);
    const propValue = new web_ifc_api_exports[schema][type](value);
    const prop = new web_ifc_api_exports[schema].IfcPropertySingleValue(
      propName2,
      null,
      propValue,
      null
    );
    prop.expressID = this.getNewExpressID(model);
    await this.setData(model, prop);
    return prop;
  }
};
__publicField(_IfcPropertiesManager, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var IfcPropertiesManager = _IfcPropertiesManager;
var _IfcRelationsIndexer = class _IfcRelationsIndexer2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onRelationsIndexed", new Event());
    __publicField(this, "relationMaps", {});
    __publicField(this, "enabled", true);
    __publicField(this, "_relToAttributesMap", relToAttributesMap);
    __publicField(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements",
      "HasControlElements",
      "AssignedToFlowElement",
      "ConnectedTo",
      "ConnectedFrom",
      "ReferencedBy",
      "Declares",
      "HasContext",
      "Controls",
      "IsNestedBy",
      "Nests",
      "DocumentRefForObjects"
    ]);
    __publicField(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELFLOWCONTROLELEMENTS,
      IFCRELCONNECTSELEMENTS,
      IFCRELASSIGNSTOPRODUCT,
      IFCRELDECLARES,
      IFCRELASSIGNSTOCONTROL,
      IFCRELNESTS,
      IFCRELASSOCIATESDOCUMENT
    ]);
    __publicField(this, "onFragmentsDisposed", (data) => {
      delete this.relationMaps[data.groupID];
    });
    __publicField(this, "_changeMap", {});
    __publicField(this, "onEntitiesRelated", new Event());
    this.components.add(_IfcRelationsIndexer2.uuid, this);
    const fragmentManager = components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(relationsMap, relAttrs, related, relating) {
    const relatingKey = Object.keys(relAttrs).find(
      (key) => key.startsWith("Relating")
    );
    const relatedKey = Object.keys(relAttrs).find(
      (key) => key.startsWith("Related")
    );
    if (!(relatingKey && relatedKey))
      return;
    const relatingID = relAttrs[relatingKey].value;
    const relatedIDs = relAttrs[relatedKey].map((el) => el.value);
    const indexMap = this.getEntityRelations(
      relationsMap,
      relatingID,
      relating
    );
    for (const id of relatedIDs) {
      indexMap.push(id);
    }
    for (const id of relatedIDs) {
      const relations = this.getEntityRelations(relationsMap, id, related);
      relations.push(relatingID);
    }
  }
  getAttributeIndex(inverseAttribute) {
    const index = this._inverseAttributes.indexOf(inverseAttribute);
    if (index === -1) {
      throw new Error(
        `IfcRelationsIndexer: ${inverseAttribute} is not a valid IFC Inverse Attribute name or its not supported yet by this component.`
      );
    }
    return index;
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(model, relationMap) {
    this.relationMaps[model.uuid] = relationMap;
    this.onRelationsIndexed.trigger({
      modelID: model.uuid,
      relationsMap: relationMap
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(model, config) {
    if (!model.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap) {
      relationsMap = /* @__PURE__ */ new Map();
      this.relationMaps[model.uuid] = relationsMap;
    }
    const entities = model.getLocalProperties();
    if (!entities)
      return relationsMap;
    const relationsToProcess = (config == null ? void 0 : config.relationsToProcess) ?? this._ifcRels;
    for (const [_, entity] of Object.entries(entities)) {
      if (!relationsToProcess.includes(entity.type))
        continue;
      const relInverseAttributes = this._relToAttributesMap.get(entity.type);
      if (!relInverseAttributes) {
        continue;
      }
      const { forRelated: related, forRelating: relating } = relInverseAttributes;
      this.indexRelations(relationsMap, entity, related, relating);
    }
    this.setRelationMap(model, relationsMap);
    return relationsMap;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(ifcApi, modelID) {
    const relationsMap = /* @__PURE__ */ new Map();
    for (const relType of this._ifcRels) {
      const relInverseAttributes = this._relToAttributesMap.get(relType);
      if (!relInverseAttributes)
        continue;
      const { forRelated: related, forRelating: relating } = relInverseAttributes;
      const relExpressIDs = ifcApi.GetLineIDsWithType(modelID, relType);
      for (let i = 0; i < relExpressIDs.size(); i++) {
        const relAttrs = await ifcApi.properties.getItemProperties(
          modelID,
          relExpressIDs.get(i)
        );
        this.indexRelations(relationsMap, relAttrs, related, relating);
      }
    }
    this.onRelationsIndexed.trigger({
      modelID: modelID.toString(),
      relationsMap
    });
    return relationsMap;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity, or its UUID.
   * @param expressID The unique identifier of the entity within the model.
   * @param attribute The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities. If the array is empty, no relations were found.
   */
  getEntityRelations(model, expressID, attribute) {
    const index = this.getAttributeIndex(attribute);
    let relationsMap;
    if (model instanceof Bc) {
      relationsMap = this.relationMaps[model.uuid];
    } else if (typeof model === "string") {
      relationsMap = this.relationMaps[model];
    } else {
      relationsMap = model;
    }
    if (!relationsMap && (model instanceof Bc || typeof model === "string")) {
      relationsMap = /* @__PURE__ */ new Map();
      const id = model instanceof Bc ? model.uuid : model;
      this.relationMaps[id] = relationsMap;
    }
    let entityRelations = relationsMap.get(expressID);
    if (!entityRelations) {
      entityRelations = /* @__PURE__ */ new Map();
      relationsMap.set(expressID, entityRelations);
    }
    let relations = entityRelations.get(index);
    if (!relations) {
      relations = [];
      entityRelations.set(index, relations);
    }
    return relations;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(relationMap) {
    const object = {};
    for (const [expressID, relations] of relationMap.entries()) {
      if (!object[expressID])
        object[expressID] = {};
      for (const [relationID, relationEntities] of relations.entries()) {
        object[expressID][relationID] = relationEntities;
      }
    }
    return JSON.stringify(object);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(model) {
    const relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap)
      return null;
    const json = this.serializeRelations(relationsMap);
    return json;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const jsonObject = {};
    for (const uuid in this.relationMaps) {
      const indexMap = this.relationMaps[uuid];
      const object = {};
      for (const [expressID, relations] of indexMap.entries()) {
        if (!object[expressID])
          object[expressID] = {};
        for (const [relationID, relationEntities] of relations.entries()) {
          object[expressID][relationID] = relationEntities;
        }
      }
      jsonObject[uuid] = object;
    }
    return JSON.stringify(jsonObject);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(json) {
    const relations = JSON.parse(json);
    const indexMap = /* @__PURE__ */ new Map();
    for (const expressID in relations) {
      const expressIDRelations = relations[expressID];
      const relationMap = /* @__PURE__ */ new Map();
      for (const relationID in expressIDRelations) {
        relationMap.set(Number(relationID), expressIDRelations[relationID]);
      }
      indexMap.set(Number(expressID), relationMap);
    }
    return indexMap;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {};
    const fragmentManager = this.components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.remove(this.onFragmentsDisposed);
    this.onDisposed.trigger(_IfcRelationsIndexer2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Retrieves the entities within a model that have a specific relation with a given entity.
   *
   * @param model - The BIM model to search for related entities.
   * @param inv - The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @param expressID - The expressID of the entity within the model.
   *
   * @returns A `Set` with the expressIDs of the entities that have the specified relation with the given entity.
   *
   * @throws An error if the model relations are not indexed or if the inverse attribute name is invalid.
   */
  getEntitiesWithRelation(model, inv, expressID) {
    const relations = this.relationMaps[model.uuid];
    if (!relations)
      throw new Error(
        "IfcRelationsIndexer: the model relations are not indexed!"
      );
    const set = /* @__PURE__ */ new Set();
    for (const [id, map] of relations) {
      const index = this.getAttributeIndex(inv);
      const rels = map.get(index);
      if (rels && rels.includes(expressID))
        set.add(id);
    }
    return set;
  }
  /**
   * Adds relations between an entity and other entities in a BIM model.
   *
   * @param model - The BIM model to which the relations will be added.
   * @param expressID - The expressID of the entity within the model.
   * @param relationName - The IFC schema inverse attribute of the relation to add (e.g., "IsDefinedBy", "ContainsElements").
   * @param relIDs - The expressIDs of the related entities within the model.
   * @deprecated Use addEntitiesRelation instead. This will be removed in future versions.
   *
   * @throws An error if the relation name is not a valid relation name.
   */
  addEntityRelations(model, expressID, relationName, ...relIDs) {
    const existingRelations = this.getEntityRelations(
      model,
      expressID,
      relationName
    );
    if (!existingRelations) {
      const attributeIndex = this.getAttributeIndex(relationName);
      const entityRelations = this.relationMaps[model.uuid].get(expressID);
      entityRelations == null ? void 0 : entityRelations.set(attributeIndex, relIDs);
    } else {
      existingRelations.push(...relIDs);
    }
  }
  /**
   * Converts the relations made into actual IFC data.
   *
   * @remarks This function iterates through the changes made to the relations and applies them to the corresponding BIM model.
   * It only make sense to use it if the relations need to be write in the IFC file.
   *
   * @returns A promise that resolves when all the relation changes have been applied.
   */
  async applyRelationChanges() {
    const fragments = this.components.get(FragmentsManager);
    const propsManager = this.components.get(IfcPropertiesManager);
    for (const modelID in this._changeMap) {
      const model = fragments.groups.get(modelID);
      if (!model)
        continue;
      const relations = this._changeMap[modelID];
      for (const [relType, data] of relations) {
        for (const [relatingID, relationInfo] of data) {
          const { related, relID } = relationInfo;
          if (relID) {
            const rel = await model.getProperties(relID);
            if (!rel)
              continue;
            const keys = Object.keys(rel);
            const relatedKey = keys.find((key) => key.startsWith("Related"));
            const relatingKey = keys.find((key) => key.startsWith("Relating"));
            if (!(relatedKey && relatingKey))
              continue;
            rel[relatedKey] = [...related].map((id) => new Handle(id));
            rel[relatingKey] = new Handle(relatingID);
            await propsManager.setData(model, rel);
          } else {
            const rel = await propsManager.createIfcRel(
              model,
              relType,
              relatingID,
              [...related]
            );
            if (!rel)
              continue;
            relationInfo.relID = rel.expressID;
          }
        }
      }
    }
  }
  addEntitiesRelation(model, relatingID, rel, ...relatedIDs) {
    const { type, inv } = rel;
    let relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap) {
      relationsMap = /* @__PURE__ */ new Map();
      this.relationMaps[model.uuid] = relationsMap;
    }
    if (!this._ifcRels.includes(type))
      return;
    const relInvAttrs = relToAttributesMap.get(type);
    if (!relInvAttrs)
      return;
    const { forRelated: related, forRelating: relating } = relInvAttrs;
    if (!(related === inv || relating === inv))
      return;
    let modelChangeMap = this._changeMap[model.uuid];
    if (!modelChangeMap) {
      modelChangeMap = new DataMap();
      this._changeMap[model.uuid] = modelChangeMap;
    }
    const relatingExpressID = relating === inv ? [relatingID] : relatedIDs;
    const relatedExpressID = related === inv ? [relatingID] : relatedIDs;
    let typeChangeMap = modelChangeMap.get(type);
    if (!typeChangeMap) {
      typeChangeMap = new DataMap();
      typeChangeMap.onItemSet.add(
        () => this.onEntitiesRelated.trigger({
          invAttribute: inv,
          relType: type,
          relatingIDs: relatingExpressID,
          relatedIDs: relatedExpressID
        })
      );
      typeChangeMap.onItemUpdated.add(
        () => this.onEntitiesRelated.trigger({
          invAttribute: inv,
          relType: type,
          relatingIDs: relatingExpressID,
          relatedIDs: relatedExpressID
        })
      );
      modelChangeMap.set(type, typeChangeMap);
    }
    for (const relating2 of relatingExpressID) {
      let relatingData = typeChangeMap.get(relating2);
      if (!relatingData) {
        relatingData = { related: new DataSet() };
        typeChangeMap.set(relating2, relatingData);
      }
      relatingData.related.add(...relatedExpressID);
    }
    for (const id of relatingExpressID) {
      const indexMap = this.getEntityRelations(model, id, relating);
      indexMap.push(...relatedExpressID);
    }
    for (const id of relatedExpressID) {
      const relations = this.getEntityRelations(model, id, related);
      relations.push(...relatingExpressID);
    }
  }
  /**
   * Gets the children of the given element recursively. E.g. in a model with project - site - building - storeys - rooms, passing a storey will include all its children and the children of the rooms contained in it.
   *
   * @param model The BIM model whose children to get.
   * @param expressID The expressID of the item whose children to get.
   * @param found An optional parameter that includes a set of expressIDs where the found element IDs will be added.
   *
   * @returns A `Set` with the expressIDs of the found items.
   */
  getEntityChildren(model, expressID, found = /* @__PURE__ */ new Set()) {
    found.add(expressID);
    const modelRelations = this.relationMaps[model.uuid];
    if (modelRelations === void 0) {
      throw new Error(
        "The provided model has no indices. You have to generate them first."
      );
    }
    const spatialRels = this.getEntityRelations(
      model,
      expressID,
      "IsDecomposedBy"
    );
    if (spatialRels) {
      for (const id of spatialRels) {
        this.getEntityChildren(model, id, found);
      }
    }
    const rels = this.getEntityRelations(model, expressID, "ContainsElements");
    if (rels) {
      for (const id of rels) {
        this.getEntityChildren(model, id, found);
      }
    }
    return found;
  }
};
__publicField(_IfcRelationsIndexer, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var IfcRelationsIndexer = _IfcRelationsIndexer;
var _FragmentsManager = class _FragmentsManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onFragmentsLoaded", new Event());
    __publicField(this, "onFragmentsDisposed", new Event());
    __publicField(this, "list", new DataMap());
    __publicField(this, "groups", new DataMap());
    __publicField(this, "baseCoordinationModel", "");
    __publicField(this, "baseCoordinationMatrix", new Matrix4());
    __publicField(this, "enabled", true);
    __publicField(this, "_loader", new Uc());
    this.components.add(_FragmentsManager2.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const meshes = [];
    for (const [_id, fragment] of this.list) {
      meshes.push(fragment.mesh);
    }
    return meshes;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, group] of this.groups) {
      group.dispose(true);
    }
    this.baseCoordinationModel = "";
    this.groups.clear();
    this.list.clear();
    this.onFragmentsLoaded.reset();
    this.onFragmentsDisposed.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(group) {
    const { uuid: groupID } = group;
    const fragmentIDs = [];
    for (const fragment of group.items) {
      fragmentIDs.push(fragment.id);
      this.list.delete(fragment.id);
    }
    group.dispose(true);
    this.groups.delete(group.uuid);
    if (this.groups.size === 0) {
      this.baseCoordinationModel = "";
      this.baseCoordinationMatrix = new Matrix4();
    }
    this.onFragmentsDisposed.trigger({
      groupID,
      fragmentIDs
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.isStreamed - Optional setting to determine whether this model is streamed or not.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(data, config) {
    const defaultConfig = { coordinate: true };
    const _config = { ...defaultConfig, ...config };
    const { coordinate, name, properties, relationsMap } = _config;
    const model = this._loader.import(data);
    if (config) {
      model.isStreamed = config.isStreamed || false;
    }
    if (name)
      model.name = name;
    for (const fragment of model.items) {
      fragment.group = model;
      this.list.set(fragment.id, fragment);
    }
    if (coordinate) {
      this.coordinate([model]);
    }
    this.groups.set(model.uuid, model);
    if (properties) {
      model.setLocalProperties(properties);
    }
    if (relationsMap) {
      const indexer = this.components.get(IfcRelationsIndexer);
      indexer.setRelationMap(model, relationsMap);
    }
    this.onFragmentsLoaded.trigger(model);
    return model;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(group) {
    return this._loader.export(group);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(fragmentIdMap) {
    const map = {};
    for (const fragmentID in fragmentIdMap) {
      const fragment = this.list.get(fragmentID);
      if (!(fragment && fragment.group))
        continue;
      const model = fragment.group;
      if (!(model.uuid in map))
        map[model.uuid] = /* @__PURE__ */ new Set();
      const expressIDs = fragmentIdMap[fragmentID];
      for (const expressID of expressIDs) {
        map[model.uuid].add(expressID);
      }
    }
    return map;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(modelIdMap) {
    let fragmentIdMap = {};
    for (const modelID in modelIdMap) {
      const model = this.groups.get(modelID);
      if (!model)
        continue;
      const expressIDs = modelIdMap[modelID];
      const map = model.getFragmentMap(expressIDs);
      fragmentIdMap = { ...fragmentIdMap, ...map };
    }
    return fragmentIdMap;
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  guidToFragmentIdMap(guids) {
    const modelIdMap = {};
    for (const [id, model] of this.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of guids) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    const fragmentIdMap = this.modelIdToFragmentIdMap(modelIdMap);
    return fragmentIdMap;
  }
  /**
   * Converts a fragment ID map to a collection of IFC GUIDs.
   *
   * @param fragmentIdMap - A fragment ID map to be converted to a collection of IFC GUIDs.
   *
   * @returns An array of IFC GUIDs.
   */
  fragmentIdMapToGuids(fragmentIdMap) {
    const guids = [];
    const modelIdMap = this.getModelIdMap(fragmentIdMap);
    for (const modelID in modelIdMap) {
      const model = this.groups.get(modelID);
      if (!model)
        continue;
      const expressIDs = modelIdMap[modelID];
      for (const expressID of expressIDs) {
        for (const [guid, id] of model.globalToExpressIDs.entries()) {
          if (id === expressID) {
            guids.push(guid);
            break;
          }
        }
      }
    }
    return guids;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all models are used.
   */
  coordinate(models = Array.from(this.groups.values())) {
    const isFirstModel = this.baseCoordinationModel.length === 0;
    if (isFirstModel) {
      const first = models.pop();
      if (!first) {
        return;
      }
      this.baseCoordinationModel = first.uuid;
      this.baseCoordinationMatrix = first.coordinationMatrix.clone();
    }
    if (!models.length) {
      return;
    }
    for (const model of models) {
      if (model.coordinationMatrix.equals(this.baseCoordinationMatrix)) {
        continue;
      }
      model.position.set(0, 0, 0);
      model.rotation.set(0, 0, 0);
      model.scale.set(1, 1, 1);
      model.updateMatrix();
      this.applyBaseCoordinateSystem(model, model.coordinationMatrix);
    }
  }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(object, originalCoordinateSystem) {
    if (originalCoordinateSystem) {
      object.applyMatrix4(originalCoordinateSystem.clone().invert());
    }
    object.applyMatrix4(this.baseCoordinationMatrix);
  }
  /**
   * Creates a copy of the whole model or a part of it.
   *
   * @param model - The model to clone.
   * @param items - Optional - The part of the model to be cloned. If not given, the whole group is cloned.
   *
   */
  clone(model, items) {
    const clone = model.cloneGroup(items);
    this.groups.set(clone.uuid, clone);
    for (const frag of clone.items) {
      this.list.set(frag.id, frag);
    }
    return clone;
  }
};
__publicField(_FragmentsManager, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var FragmentsManager = _FragmentsManager;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
(function(module, exports) {
  !function(e2) {
    module.exports = e2();
  }(function() {
    return function s(a, o, h) {
      function u(r, e22) {
        if (!o[r]) {
          if (!a[r]) {
            var t15 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e22 && t15)
              return t15(r, true);
            if (l)
              return l(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e3) {
            var t22 = a[r][1][e3];
            return u(t22 || e3);
          }, i, i.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h.length; e2++)
        u(h[e2]);
      return u;
    }({ 1: [function(e2, t15, r) {
      var d = e2("./utils"), c = e2("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e22) {
        for (var t22, r2, n, i, s, a, o, h = [], u = 0, l = e22.length, f = l, c2 = "string" !== d.getTypeOf(e22); u < e22.length; )
          f = l - u, n = c2 ? (t22 = e22[u++], r2 = u < l ? e22[u++] : 0, u < l ? e22[u++] : 0) : (t22 = e22.charCodeAt(u++), r2 = u < l ? e22.charCodeAt(u++) : 0, u < l ? e22.charCodeAt(u++) : 0), i = t22 >> 2, s = (3 & t22) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
        return h.join("");
      }, r.decode = function(e22) {
        var t22, r2, n, i, s, a, o = 0, h = 0, u = "data:";
        if (e22.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (e22 = e22.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e22.charAt(e22.length - 1) === p.charAt(64) && f--, e22.charAt(e22.length - 2) === p.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e22.length; )
          t22 = p.indexOf(e22.charAt(o++)) << 2 | (i = p.indexOf(e22.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e22.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e22.charAt(o++))), l[h++] = t22, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t15, r) {
      var n = e2("./external"), i = e2("./stream/DataWorker"), s = e2("./stream/Crc32Probe"), a = e2("./stream/DataLengthProbe");
      function o(e22, t22, r2, n2, i2) {
        this.compressedSize = e22, this.uncompressedSize = t22, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e22 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t22 = this;
        return e22.on("end", function() {
          if (this.streamInfo.data_length !== t22.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e22;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e22, t22, r2) {
        return e22.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t22.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t22);
      }, t15.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t15, r) {
      var n = e2("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e2("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t15, r) {
      var n = e2("./utils");
      var o = function() {
        for (var e22, t22 = [], r2 = 0; r2 < 256; r2++) {
          e22 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            e22 = 1 & e22 ? 3988292384 ^ e22 >>> 1 : e22 >>> 1;
          t22[r2] = e22;
        }
        return t22;
      }();
      t15.exports = function(e22, t22) {
        return void 0 !== e22 && e22.length ? "string" !== n.getTypeOf(e22) ? function(e3, t32, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t32[a])];
          return -1 ^ e3;
        }(0 | t22, e22, e22.length, 0) : function(e3, t32, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t32.charCodeAt(a))];
          return -1 ^ e3;
        }(0 | t22, e22, e22.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e2, t15, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e2, t15, r) {
      var n = null;
      n = "undefined" != typeof Promise ? Promise : e2("lie"), t15.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e2, t15, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e2("pako"), s = e2("./utils"), a = e2("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h(e22, t22) {
        a.call(this, "FlateWorker/" + e22), this._pako = null, this._pakoAction = e22, this._pakoOptions = t22, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e22) {
        this.meta = e22.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e22.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t22 = this;
        this._pako.onData = function(e22) {
          t22.push({ data: e22, meta: t22.meta });
        };
      }, r.compressWorker = function(e22) {
        return new h("Deflate", e22);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t15, r) {
      function A(e22, t22) {
        var r2, n2 = "";
        for (r2 = 0; r2 < t22; r2++)
          n2 += String.fromCharCode(255 & e22), e22 >>>= 8;
        return n2;
      }
      function n(e22, t22, r2, n2, i2, s2) {
        var a, o, h = e22.file, u = e22.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t22 && !r2 || (x.crc32 = e22.crc32, x.compressedSize = e22.compressedSize, x.uncompressedSize = e22.uncompressedSize);
        var S = 0;
        t22 && (S |= 8), l || !_ && !g || (S |= 2048);
        var z2 = 0, C = 0;
        w && (z2 |= 16), "UNIX" === i2 ? (C = 798, z2 |= function(e3, t32) {
          var r3 = e3;
          return e3 || (r3 = t32 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z2 |= function(e3) {
          return 63 & (e3 || 0);
        }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B2(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B2(p), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E = "";
        return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b + p };
      }
      var I = e2("../utils"), i = e2("../stream/GenericWorker"), O = e2("../utf8"), B2 = e2("../crc32"), R = e2("../signature");
      function s(e22, t22, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t22, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e22, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, i), s.prototype.push = function(e22) {
        var t22 = e22.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e22) : (this.bytesWritten += e22.data.length, i.prototype.push.call(this, { data: e22.data, meta: { currentFile: this.currentFile, percent: r2 ? (t22 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e22) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e22.file.name;
        var t22 = this.streamFiles && !e22.file.dir;
        if (t22) {
          var r2 = n(e22, t22, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e22) {
        this.accumulate = false;
        var t22 = this.streamFiles && !e22.file.dir, r2 = n(e22, t22, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t22)
          this.push({ data: function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          }(e22), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e22 = this.bytesWritten, t22 = 0; t22 < this.dirRecords.length; t22++)
          this.push({ data: this.dirRecords[t22], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e22, n2 = function(e3, t32, r3, n3, i2) {
          var s2 = I.transformTo("string", i2(n3));
          return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t32, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e22, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e22) {
        this._sources.push(e22);
        var t22 = this;
        return e22.on("data", function(e3) {
          t22.processChunk(e3);
        }), e22.on("end", function() {
          t22.closedSource(t22.previous.streamInfo), t22._sources.length ? t22.prepareNextSource() : t22.end();
        }), e22.on("error", function(e3) {
          t22.error(e3);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(e22) {
        var t22 = this._sources;
        if (!i.prototype.error.call(this, e22))
          return false;
        for (var r2 = 0; r2 < t22.length; r2++)
          try {
            t22[r2].error(e22);
          } catch (e3) {
          }
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e22 = this._sources, t22 = 0; t22 < e22.length; t22++)
          e22[t22].lock();
      }, t15.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t15, r) {
      var u = e2("../compressions"), n = e2("./ZipFileWorker");
      r.generateWorker = function(e22, a, t22) {
        var o = new n(a.streamFiles, t22, a.platform, a.encodeFileName), h = 0;
        try {
          e22.forEach(function(e3, t32) {
            h++;
            var r2 = function(e4, t42) {
              var r3 = e4 || t42, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t32.options.compression, a.compression), n2 = t32.options.compressionOptions || a.compressionOptions || {}, i = t32.dir, s = t32.date;
            t32._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t32.comment || "", unixPermissions: t32.unixPermissions, dosPermissions: t32.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (e3) {
          o.error(e3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t15, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e22 = new n();
          for (var t22 in this)
            "function" != typeof this[t22] && (e22[t22] = this[t22]);
          return e22;
        };
      }
      (n.prototype = e2("./object")).loadAsync = e2("./load"), n.support = e2("./support"), n.defaults = e2("./defaults"), n.version = "3.10.1", n.loadAsync = function(e22, t22) {
        return new n().loadAsync(e22, t22);
      }, n.external = e2("./external"), t15.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t15, r) {
      var u = e2("./utils"), i = e2("./external"), n = e2("./utf8"), s = e2("./zipEntries"), a = e2("./stream/Crc32Probe"), l = e2("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e22, t22) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a());
          r2.on("error", function(e3) {
            t22(e3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t22(new Error("Corrupted zip : CRC32 mismatch")) : e22();
          }).resume();
        });
      }
      t15.exports = function(e22, o) {
        var h = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e22) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e22, true, o.optimizedBinaryString, o.base64).then(function(e3) {
          var t22 = new s(o);
          return t22.load(e3), t22;
        }).then(function(e3) {
          var t22 = [i.Promise.resolve(e3)], r2 = e3.files;
          if (o.checkCRC32)
            for (var n2 = 0; n2 < r2.length; n2++)
              t22.push(f(r2[n2]));
          return i.Promise.all(t22);
        }).then(function(e3) {
          for (var t22 = e3.shift(), r2 = t22.files, n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
          }
          return t22.zipComment.length && (h.comment = t22.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t15, r) {
      var n = e2("../utils"), i = e2("../stream/GenericWorker");
      function s(e22, t22) {
        i.call(this, "Nodejs stream input adapter for " + e22), this._upstreamEnded = false, this._bindStream(t22);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e22) {
        var t22 = this;
        (this._stream = e22).pause(), e22.on("data", function(e3) {
          t22.push({ data: e3, meta: { percent: 0 } });
        }).on("error", function(e3) {
          t22.isPaused ? this.generatedError = e3 : t22.error(e3);
        }).on("end", function() {
          t22.isPaused ? t22._upstreamEnded = true : t22.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t15.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t15, r) {
      var i = e2("readable-stream").Readable;
      function n(e22, t22, r2) {
        i.call(this, t22), this._helper = e22;
        var n2 = this;
        e22.on("data", function(e3, t32) {
          n2.push(e3) || n2._helper.pause(), r2 && r2(t32);
        }).on("error", function(e3) {
          n2.emit("error", e3);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e2("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t15.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t15, r) {
      t15.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e22, t22) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e22, t22);
        if ("number" == typeof e22)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e22, t22);
      }, allocBuffer: function(e22) {
        if (Buffer.alloc)
          return Buffer.alloc(e22);
        var t22 = new Buffer(e22);
        return t22.fill(0), t22;
      }, isBuffer: function(e22) {
        return Buffer.isBuffer(e22);
      }, isStream: function(e22) {
        return e22 && "function" == typeof e22.on && "function" == typeof e22.pause && "function" == typeof e22.resume;
      } };
    }, {}], 15: [function(e2, t15, r) {
      function s(e22, t22, r2) {
        var n2, i2 = u.getTypeOf(t22), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e22 = g(e22)), s2.createFolders && (n2 = _(e22)) && b.call(this, n2, true);
        var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
        r2 && void 0 !== r2.binary || (s2.binary = !a2), (t22 instanceof c && 0 === t22.uncompressedSize || s2.dir || !t22 || 0 === t22.length) && (s2.base64 = false, s2.binary = true, t22 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t22 instanceof c || t22 instanceof l ? t22 : p.isNode && p.isStream(t22) ? new m(e22, t22) : u.prepareContent(e22, t22, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new d(e22, o2, s2);
        this.files[e22] = h2;
      }
      var i = e2("./utf8"), u = e2("./utils"), l = e2("./stream/GenericWorker"), a = e2("./stream/StreamHelper"), f = e2("./defaults"), c = e2("./compressedObject"), d = e2("./zipObject"), o = e2("./generate"), p = e2("./nodejsUtils"), m = e2("./nodejs/NodejsStreamInputAdapter"), _ = function(e22) {
        "/" === e22.slice(-1) && (e22 = e22.substring(0, e22.length - 1));
        var t22 = e22.lastIndexOf("/");
        return 0 < t22 ? e22.substring(0, t22) : "";
      }, g = function(e22) {
        return "/" !== e22.slice(-1) && (e22 += "/"), e22;
      }, b = function(e22, t22) {
        return t22 = void 0 !== t22 ? t22 : f.createFolders, e22 = g(e22), this.files[e22] || s.call(this, e22, null, { dir: true, createFolders: t22 }), this.files[e22];
      };
      function h(e22) {
        return "[object RegExp]" === Object.prototype.toString.call(e22);
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e22) {
        var t22, r2, n2;
        for (t22 in this.files)
          n2 = this.files[t22], (r2 = t22.slice(this.root.length, t22.length)) && t22.slice(0, this.root.length) === this.root && e22(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e22, t22) {
          r2(e22, t22) && n2.push(t22);
        }), n2;
      }, file: function(e22, t22, r2) {
        if (1 !== arguments.length)
          return e22 = this.root + e22, s.call(this, e22, t22, r2), this;
        if (h(e22)) {
          var n2 = e22;
          return this.filter(function(e3, t32) {
            return !t32.dir && n2.test(e3);
          });
        }
        var i2 = this.files[this.root + e22];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(e3, t32) {
            return t32.dir && r2.test(e3);
          });
        var e22 = this.root + r2, t22 = b.call(this, e22), n2 = this.clone();
        return n2.root = t22.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e22 = this.files[r2];
        if (e22 || ("/" !== r2.slice(-1) && (r2 += "/"), e22 = this.files[r2]), e22 && !e22.dir)
          delete this.files[r2];
        else
          for (var t22 = this.filter(function(e3, t32) {
            return t32.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t22.length; n2++)
            delete this.files[t22[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e22) {
        var t22, r2 = {};
        try {
          if ((r2 = u.extend(e22 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t22 = o.generateWorker(this, r2, n2);
        } catch (e3) {
          (t22 = new l("error")).error(e3);
        }
        return new a(t22, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e22, t22) {
        return this.generateInternalStream(e22).accumulate(t22);
      }, generateNodeStream: function(e22, t22) {
        return (e22 = e22 || {}).type || (e22.type = "nodebuffer"), this.generateInternalStream(e22).toNodejsStream(t22);
      } };
      t15.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t15, r) {
      t15.exports = e2("stream");
    }, { stream: void 0 }], 17: [function(e2, t15, r) {
      var n = e2("./DataReader");
      function i(e22) {
        n.call(this, e22);
        for (var t22 = 0; t22 < this.data.length; t22++)
          e22[t22] = 255 & e22[t22];
      }
      e2("../utils").inherits(i, n), i.prototype.byteAt = function(e22) {
        return this.data[this.zero + e22];
      }, i.prototype.lastIndexOfSignature = function(e22) {
        for (var t22 = e22.charCodeAt(0), r2 = e22.charCodeAt(1), n2 = e22.charCodeAt(2), i2 = e22.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === t22 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e22) {
        var t22 = e22.charCodeAt(0), r2 = e22.charCodeAt(1), n2 = e22.charCodeAt(2), i2 = e22.charCodeAt(3), s = this.readData(4);
        return t22 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e22) {
        if (this.checkOffset(e22), 0 === e22)
          return [];
        var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
        return this.index += e22, t22;
      }, t15.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t15, r) {
      var n = e2("../utils");
      function i(e22) {
        this.data = e22, this.length = e22.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e22) {
        this.checkIndex(this.index + e22);
      }, checkIndex: function(e22) {
        if (this.length < this.zero + e22 || e22 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e22 + "). Corrupted zip ?");
      }, setIndex: function(e22) {
        this.checkIndex(e22), this.index = e22;
      }, skip: function(e22) {
        this.setIndex(this.index + e22);
      }, byteAt: function() {
      }, readInt: function(e22) {
        var t22, r2 = 0;
        for (this.checkOffset(e22), t22 = this.index + e22 - 1; t22 >= this.index; t22--)
          r2 = (r2 << 8) + this.byteAt(t22);
        return this.index += e22, r2;
      }, readString: function(e22) {
        return n.transformTo("string", this.readData(e22));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e22 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e22 >> 25 & 127), (e22 >> 21 & 15) - 1, e22 >> 16 & 31, e22 >> 11 & 31, e22 >> 5 & 63, (31 & e22) << 1));
      } }, t15.exports = i;
    }, { "../utils": 32 }], 19: [function(e2, t15, r) {
      var n = e2("./Uint8ArrayReader");
      function i(e22) {
        n.call(this, e22);
      }
      e2("../utils").inherits(i, n), i.prototype.readData = function(e22) {
        this.checkOffset(e22);
        var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
        return this.index += e22, t22;
      }, t15.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t15, r) {
      var n = e2("./DataReader");
      function i(e22) {
        n.call(this, e22);
      }
      e2("../utils").inherits(i, n), i.prototype.byteAt = function(e22) {
        return this.data.charCodeAt(this.zero + e22);
      }, i.prototype.lastIndexOfSignature = function(e22) {
        return this.data.lastIndexOf(e22) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e22) {
        return e22 === this.readData(4);
      }, i.prototype.readData = function(e22) {
        this.checkOffset(e22);
        var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
        return this.index += e22, t22;
      }, t15.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t15, r) {
      var n = e2("./ArrayReader");
      function i(e22) {
        n.call(this, e22);
      }
      e2("../utils").inherits(i, n), i.prototype.readData = function(e22) {
        if (this.checkOffset(e22), 0 === e22)
          return new Uint8Array(0);
        var t22 = this.data.subarray(this.zero + this.index, this.zero + this.index + e22);
        return this.index += e22, t22;
      }, t15.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t15, r) {
      var n = e2("../utils"), i = e2("../support"), s = e2("./ArrayReader"), a = e2("./StringReader"), o = e2("./NodeBufferReader"), h = e2("./Uint8ArrayReader");
      t15.exports = function(e22) {
        var t22 = n.getTypeOf(e22);
        return n.checkSupport(t22), "string" !== t22 || i.uint8array ? "nodebuffer" === t22 ? new o(e22) : i.uint8array ? new h(n.transformTo("uint8array", e22)) : new s(n.transformTo("array", e22)) : new a(e22);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t15, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e2, t15, r) {
      var n = e2("./GenericWorker"), i = e2("../utils");
      function s(e22) {
        n.call(this, "ConvertWorker to " + e22), this.destType = e22;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e22) {
        this.push({ data: i.transformTo(this.destType, e22.data), meta: e22.meta });
      }, t15.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t15, r) {
      var n = e2("./GenericWorker"), i = e2("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e2("../utils").inherits(s, n), s.prototype.processChunk = function(e22) {
        this.streamInfo.crc32 = i(e22.data, this.streamInfo.crc32 || 0), this.push(e22);
      }, t15.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t15, r) {
      var n = e2("../utils"), i = e2("./GenericWorker");
      function s(e22) {
        i.call(this, "DataLengthProbe for " + e22), this.propName = e22, this.withStreamInfo(e22, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e22) {
        if (e22) {
          var t22 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t22 + e22.data.length;
        }
        i.prototype.processChunk.call(this, e22);
      }, t15.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t15, r) {
      var n = e2("../utils"), i = e2("./GenericWorker");
      function s(e22) {
        i.call(this, "DataWorker");
        var t22 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e22.then(function(e3) {
          t22.dataIsReady = true, t22.data = e3, t22.max = e3 && e3.length || 0, t22.type = n.getTypeOf(e3), t22.isPaused || t22._tickAndRepeat();
        }, function(e3) {
          t22.error(e3);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e22 = null, t22 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e22 = this.data.substring(this.index, t22);
            break;
          case "uint8array":
            e22 = this.data.subarray(this.index, t22);
            break;
          case "array":
          case "nodebuffer":
            e22 = this.data.slice(this.index, t22);
        }
        return this.index = t22, this.push({ data: e22, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t15.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t15, r) {
      function n(e22) {
        this.name = e22 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e22) {
        this.emit("data", e22);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e22) {
          this.emit("error", e22);
        }
        return true;
      }, error: function(e22) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e22 : (this.isFinished = true, this.emit("error", e22), this.previous && this.previous.error(e22), this.cleanUp()), true);
      }, on: function(e22, t22) {
        return this._listeners[e22].push(t22), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e22, t22) {
        if (this._listeners[e22])
          for (var r2 = 0; r2 < this._listeners[e22].length; r2++)
            this._listeners[e22][r2].call(this, t22);
      }, pipe: function(e22) {
        return e22.registerPrevious(this);
      }, registerPrevious: function(e22) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e22.streamInfo, this.mergeStreamInfo(), this.previous = e22;
        var t22 = this;
        return e22.on("data", function(e3) {
          t22.processChunk(e3);
        }), e22.on("end", function() {
          t22.end();
        }), e22.on("error", function(e3) {
          t22.error(e3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e22 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e22 = true), this.previous && this.previous.resume(), !e22;
      }, flush: function() {
      }, processChunk: function(e22) {
        this.push(e22);
      }, withStreamInfo: function(e22, t22) {
        return this.extraStreamInfo[e22] = t22, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e22 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e22) && (this.streamInfo[e22] = this.extraStreamInfo[e22]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e22 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e22 : e22;
      } }, t15.exports = n;
    }, {}], 29: [function(e2, t15, r) {
      var h = e2("../utils"), i = e2("./ConvertWorker"), s = e2("./GenericWorker"), u = e2("../base64"), n = e2("../support"), a = e2("../external"), o = null;
      if (n.nodestream)
        try {
          o = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e22) {
        }
      function l(e22, o2) {
        return new a.Promise(function(t22, r2) {
          var n2 = [], i2 = e22._internalType, s2 = e22._outputType, a2 = e22._mimeType;
          e22.on("data", function(e3, t32) {
            n2.push(e3), o2 && o2(t32);
          }).on("error", function(e3) {
            n2 = [], r2(e3);
          }).on("end", function() {
            try {
              var e3 = function(e4, t32, r3) {
                switch (e4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", t32), r3);
                  case "base64":
                    return u.encode(t32);
                  default:
                    return h.transformTo(e4, t32);
                }
              }(s2, function(e4, t32) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0; r3 < t32.length; r3++)
                  s3 += t32[r3].length;
                switch (e4) {
                  case "string":
                    return t32.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t32);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0; r3 < t32.length; r3++)
                      i3.set(t32[r3], n3), n3 += t32[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t32);
                  default:
                    throw new Error("concat : unsupported type '" + e4 + "'");
                }
              }(i2, n2), a2);
              t22(e3);
            } catch (e4) {
              r2(e4);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e22, t22, r2) {
        var n2 = t22;
        switch (t22) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t22, this._mimeType = r2, h.checkSupport(n2), this._worker = e22.pipe(new i(n2)), e22.lock();
        } catch (e3) {
          this._worker = new s("error"), this._worker.error(e3);
        }
      }
      f.prototype = { accumulate: function(e22) {
        return l(this, e22);
      }, on: function(e22, t22) {
        var r2 = this;
        return "data" === e22 ? this._worker.on(e22, function(e3) {
          t22.call(r2, e3.data, e3.meta);
        }) : this._worker.on(e22, function() {
          h.delay(t22, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e22) {
        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e22);
      } }, t15.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t15, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
        } catch (e22) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
          } catch (e3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e2("readable-stream").Readable;
      } catch (e22) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e2, t15, s) {
      for (var o = e2("./utils"), h = e2("./support"), r = e2("./nodejsUtils"), n = e2("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e22) {
        return h.nodebuffer ? r.newBufferFrom(e22, "utf-8") : function(e3) {
          var t22, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
          for (i2 = 0; i2 < a2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t22 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t22[s2++] = r2 : (r2 < 2048 ? t22[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t22[s2++] = 224 | r2 >>> 12 : (t22[s2++] = 240 | r2 >>> 18, t22[s2++] = 128 | r2 >>> 12 & 63), t22[s2++] = 128 | r2 >>> 6 & 63), t22[s2++] = 128 | 63 & r2);
          return t22;
        }(e22);
      }, s.utf8decode = function(e22) {
        return h.nodebuffer ? o.transformTo("nodebuffer", e22).toString("utf-8") : function(e3) {
          var t22, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
          for (t22 = r2 = 0; t22 < s2; )
            if ((n2 = e3[t22++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t22 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t22 < s2; )
                n2 = n2 << 6 | 63 & e3[t22++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e22 = o.transformTo(h.uint8array ? "uint8array" : "array", e22));
      }, o.inherits(a, n), a.prototype.processChunk = function(e22) {
        var t22 = o.transformTo(h.uint8array ? "uint8array" : "array", e22.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = t22;
            (t22 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t22.set(r2, this.leftOver.length);
          } else
            t22 = this.leftOver.concat(t22);
          this.leftOver = null;
        }
        var n2 = function(e3, t32) {
          var r3;
          for ((t32 = t32 || e3.length) > e3.length && (t32 = e3.length), r3 = t32 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t32 : 0 === r3 ? t32 : r3 + u[e3[r3]] > t32 ? r3 : t32;
        }(t22), i2 = t22;
        n2 !== t22.length && (h.uint8array ? (i2 = t22.subarray(0, n2), this.leftOver = t22.subarray(n2, t22.length)) : (i2 = t22.slice(0, n2), this.leftOver = t22.slice(n2, t22.length))), this.push({ data: s.utf8decode(i2), meta: e22.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e22) {
        this.push({ data: s.utf8encode(e22.data), meta: e22.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t15, a) {
      var o = e2("./support"), h = e2("./base64"), r = e2("./nodejsUtils"), u = e2("./external");
      function n(e22) {
        return e22;
      }
      function l(e22, t22) {
        for (var r2 = 0; r2 < e22.length; ++r2)
          t22[r2] = 255 & e22.charCodeAt(r2);
        return t22;
      }
      e2("setimmediate"), a.newBlob = function(t22, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t22], { type: r2 });
        } catch (e22) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t22), n2.getBlob(r2);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e22, t22, r2) {
        var n2 = [], i2 = 0, s2 = e22.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e22);
        for (; i2 < s2; )
          "array" === t22 || "nodebuffer" === t22 ? n2.push(String.fromCharCode.apply(null, e22.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e22.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e22) {
        for (var t22 = "", r2 = 0; r2 < e22.length; r2++)
          t22 += String.fromCharCode(e22[r2]);
        return t22;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e22) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
        } catch (e22) {
          return false;
        }
      }() } };
      function s(e22) {
        var t22 = 65536, r2 = a.getTypeOf(e22), n2 = true;
        if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (; 1 < t22; )
            try {
              return i.stringifyByChunk(e22, r2, t22);
            } catch (e3) {
              t22 = Math.floor(t22 / 2);
            }
        return i.stringifyByChar(e22);
      }
      function f(e22, t22) {
        for (var r2 = 0; r2 < e22.length; r2++)
          t22[r2] = e22[r2];
        return t22;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e22) {
        return l(e22, new Array(e22.length));
      }, arraybuffer: function(e22) {
        return c.string.uint8array(e22).buffer;
      }, uint8array: function(e22) {
        return l(e22, new Uint8Array(e22.length));
      }, nodebuffer: function(e22) {
        return l(e22, r.allocBuffer(e22.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e22) {
        return new Uint8Array(e22).buffer;
      }, uint8array: function(e22) {
        return new Uint8Array(e22);
      }, nodebuffer: function(e22) {
        return r.newBufferFrom(e22);
      } }, c.arraybuffer = { string: function(e22) {
        return s(new Uint8Array(e22));
      }, array: function(e22) {
        return f(new Uint8Array(e22), new Array(e22.byteLength));
      }, arraybuffer: n, uint8array: function(e22) {
        return new Uint8Array(e22);
      }, nodebuffer: function(e22) {
        return r.newBufferFrom(new Uint8Array(e22));
      } }, c.uint8array = { string: s, array: function(e22) {
        return f(e22, new Array(e22.length));
      }, arraybuffer: function(e22) {
        return e22.buffer;
      }, uint8array: n, nodebuffer: function(e22) {
        return r.newBufferFrom(e22);
      } }, c.nodebuffer = { string: s, array: function(e22) {
        return f(e22, new Array(e22.length));
      }, arraybuffer: function(e22) {
        return c.nodebuffer.uint8array(e22).buffer;
      }, uint8array: function(e22) {
        return f(e22, new Uint8Array(e22.length));
      }, nodebuffer: n }, a.transformTo = function(e22, t22) {
        if (t22 = t22 || "", !e22)
          return t22;
        a.checkSupport(e22);
        var r2 = a.getTypeOf(t22);
        return c[r2][e22](t22);
      }, a.resolve = function(e22) {
        for (var t22 = e22.split("/"), r2 = [], n2 = 0; n2 < t22.length; n2++) {
          var i2 = t22[n2];
          "." === i2 || "" === i2 && 0 !== n2 && n2 !== t22.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e22) {
        return "string" == typeof e22 ? "string" : "[object Array]" === Object.prototype.toString.call(e22) ? "array" : o.nodebuffer && r.isBuffer(e22) ? "nodebuffer" : o.uint8array && e22 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e22 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(e22) {
        if (!o[e22.toLowerCase()])
          throw new Error(e22 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e22) {
        var t22, r2, n2 = "";
        for (r2 = 0; r2 < (e22 || "").length; r2++)
          n2 += "\\x" + ((t22 = e22.charCodeAt(r2)) < 16 ? "0" : "") + t22.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e22, t22, r2) {
        setImmediate(function() {
          e22.apply(r2 || null, t22 || []);
        });
      }, a.inherits = function(e22, t22) {
        function r2() {
        }
        r2.prototype = t22.prototype, e22.prototype = new r2();
      }, a.extend = function() {
        var e22, t22, r2 = {};
        for (e22 = 0; e22 < arguments.length; e22++)
          for (t22 in arguments[e22])
            Object.prototype.hasOwnProperty.call(arguments[e22], t22) && void 0 === r2[t22] && (r2[t22] = arguments[e22][t22]);
        return r2;
      }, a.prepareContent = function(r2, e22, n2, i2, s2) {
        return u.Promise.resolve(e22).then(function(n3) {
          return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t22, r3) {
            var e3 = new FileReader();
            e3.onload = function(e4) {
              t22(e4.target.result);
            }, e3.onerror = function(e4) {
              r3(e4.target.error);
            }, e3.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e3) {
          var t22 = a.getTypeOf(e3);
          return t22 ? ("arraybuffer" === t22 ? e3 = a.transformTo("uint8array", e3) : "string" === t22 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
            return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
          }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t15, r) {
      var n = e2("./reader/readerFor"), i = e2("./utils"), s = e2("./signature"), a = e2("./zipEntry"), o = e2("./support");
      function h(e22) {
        this.files = [], this.loadOptions = e22;
      }
      h.prototype = { checkSignature: function(e22) {
        if (!this.reader.readAndCheckSignature(e22)) {
          this.reader.index -= 4;
          var t22 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t22) + ", expected " + i.pretty(e22) + ")");
        }
      }, isSignature: function(e22, t22) {
        var r2 = this.reader.index;
        this.reader.setIndex(e22);
        var n2 = this.reader.readString(4) === t22;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e22 = this.reader.readData(this.zipCommentLength), t22 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t22, e22);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e22, t22, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          e22 = this.reader.readInt(2), t22 = this.reader.readInt(4), r2 = this.reader.readData(t22), this.zip64ExtensibleData[e22] = { id: e22, length: t22, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e22, t22;
        for (e22 = 0; e22 < this.files.length; e22++)
          t22 = this.files[e22], this.reader.setIndex(t22.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t22.readLocalPart(this.reader), t22.handleUTF8(), t22.processAttributes();
      }, readCentralDir: function() {
        var e22;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e22 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e22);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e22 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e22 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e22);
        var t22 = e22;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e22 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e22), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t22 - r2;
        if (0 < n2)
          this.isSignature(t22, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e22) {
        this.reader = n(e22);
      }, load: function(e22) {
        this.prepareReader(e22), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t15.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t15, r) {
      var n = e2("./reader/readerFor"), s = e2("./utils"), i = e2("./compressedObject"), a = e2("./crc32"), o = e2("./utf8"), h = e2("./compressions"), u = e2("./support");
      function l(e22, t22) {
        this.options = e22, this.loadOptions = t22;
      }
      l.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e22) {
        var t22, r2;
        if (e22.skip(22), this.fileNameLength = e22.readInt(2), r2 = e22.readInt(2), this.fileName = e22.readData(this.fileNameLength), e22.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t22 = function(e3) {
          for (var t32 in h)
            if (Object.prototype.hasOwnProperty.call(h, t32) && h[t32].magic === e3)
              return h[t32];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t22, e22.readData(this.compressedSize));
      }, readCentralPart: function(e22) {
        this.versionMadeBy = e22.readInt(2), e22.skip(2), this.bitFlag = e22.readInt(2), this.compressionMethod = e22.readString(2), this.date = e22.readDate(), this.crc32 = e22.readInt(4), this.compressedSize = e22.readInt(4), this.uncompressedSize = e22.readInt(4);
        var t22 = e22.readInt(2);
        if (this.extraFieldsLength = e22.readInt(2), this.fileCommentLength = e22.readInt(2), this.diskNumberStart = e22.readInt(2), this.internalFileAttributes = e22.readInt(2), this.externalFileAttributes = e22.readInt(4), this.localHeaderOffset = e22.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e22.skip(t22), this.readExtraFields(e22), this.parseZIP64ExtraField(e22), this.fileComment = e22.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e22 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e22 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e22 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e22 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e22.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e22.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e22.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e22.readInt(4));
        }
      }, readExtraFields: function(e22) {
        var t22, r2, n2, i2 = e22.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e22.index + 4 < i2; )
          t22 = e22.readInt(2), r2 = e22.readInt(2), n2 = e22.readData(r2), this.extraFields[t22] = { id: t22, length: r2, value: n2 };
        e22.setIndex(i2);
      }, handleUTF8: function() {
        var e22 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t22 = this.findExtraFieldUnicodePath();
          if (null !== t22)
            this.fileNameStr = t22;
          else {
            var r2 = s.transformTo(e22, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (null !== n2)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e22, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e22 = this.extraFields[28789];
        if (e22) {
          var t22 = n(e22.value);
          return 1 !== t22.readInt(1) ? null : a(this.fileName) !== t22.readInt(4) ? null : o.utf8decode(t22.readData(e22.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e22 = this.extraFields[25461];
        if (e22) {
          var t22 = n(e22.value);
          return 1 !== t22.readInt(1) ? null : a(this.fileComment) !== t22.readInt(4) ? null : o.utf8decode(t22.readData(e22.length - 5));
        }
        return null;
      } }, t15.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t15, r) {
      function n(e22, t22, r2) {
        this.name = e22, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t22, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e2("./stream/StreamHelper"), i = e2("./stream/DataWorker"), a = e2("./utf8"), o = e2("./compressedObject"), h = e2("./stream/GenericWorker");
      n.prototype = { internalStream: function(e22) {
        var t22 = null, r2 = "string";
        try {
          if (!e22)
            throw new Error("No output type specified.");
          var n2 = "string" === (r2 = e22.toLowerCase()) || "text" === r2;
          "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t22 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t22 = t22.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t22 = t22.pipe(new a.Utf8DecodeWorker()));
        } catch (e3) {
          (t22 = new h("error")).error(e3);
        }
        return new s(t22, r2, "");
      }, async: function(e22, t22) {
        return this.internalStream(e22).accumulate(t22);
      }, nodeStream: function(e22, t22) {
        return this.internalStream(e22 || "nodebuffer").toNodejsStream(t22);
      }, _compressWorker: function(e22, t22) {
        if (this._data instanceof o && this._data.compression.magic === e22.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e22, t22);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        n.prototype[u[f]] = l;
      t15.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l, t15) {
      (function(t22) {
        var r, n, e22 = t22.MutationObserver || t22.WebKitMutationObserver;
        if (e22) {
          var i = 0, s = new e22(u), a = t22.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t22.setImmediate || void 0 === t22.MessageChannel)
          r = "document" in t22 && "onreadystatechange" in t22.document.createElement("script") ? function() {
            var e3 = t22.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t22.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t22.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var e3, t32;
          n = true;
          for (var r2 = h.length; r2; ) {
            for (t32 = h, h = [], e3 = -1; ++e3 < r2; )
              t32[e3]();
            r2 = h.length;
          }
          n = false;
        }
        l.exports = function(e3) {
          1 !== h.push(e3) || n || r();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e2, t15, r) {
      var i = e2("immediate");
      function u() {
      }
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e22) {
        if ("function" != typeof e22)
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = void 0, e22 !== u && d(this, e22);
      }
      function h(e22, t22, r2) {
        this.promise = e22, "function" == typeof t22 && (this.onFulfilled = t22, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t22, r2, n2) {
        i(function() {
          var e22;
          try {
            e22 = r2(n2);
          } catch (e3) {
            return l.reject(t22, e3);
          }
          e22 === t22 ? l.reject(t22, new TypeError("Cannot resolve promise with itself")) : l.resolve(t22, e22);
        });
      }
      function c(e22) {
        var t22 = e22 && e22.then;
        if (e22 && ("object" == typeof e22 || "function" == typeof e22) && "function" == typeof t22)
          return function() {
            t22.apply(e22, arguments);
          };
      }
      function d(t22, e22) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, l.reject(t22, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, l.resolve(t22, e3));
        }
        var s2 = p(function() {
          e22(i2, n2);
        });
        "error" === s2.status && n2(s2.value);
      }
      function p(e22, t22) {
        var r2 = {};
        try {
          r2.value = e22(t22), r2.status = "success";
        } catch (e3) {
          r2.status = "error", r2.value = e3;
        }
        return r2;
      }
      (t15.exports = o).prototype.finally = function(t22) {
        if ("function" != typeof t22)
          return this;
        var r2 = this.constructor;
        return this.then(function(e22) {
          return r2.resolve(t22()).then(function() {
            return e22;
          });
        }, function(e22) {
          return r2.resolve(t22()).then(function() {
            throw e22;
          });
        });
      }, o.prototype.catch = function(e22) {
        return this.then(null, e22);
      }, o.prototype.then = function(e22, t22) {
        if ("function" != typeof e22 && this.state === a || "function" != typeof t22 && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e22 : t22, this.outcome) : this.queue.push(new h(r2, e22, t22));
        return r2;
      }, h.prototype.callFulfilled = function(e22) {
        l.resolve(this.promise, e22);
      }, h.prototype.otherCallFulfilled = function(e22) {
        f(this.promise, this.onFulfilled, e22);
      }, h.prototype.callRejected = function(e22) {
        l.reject(this.promise, e22);
      }, h.prototype.otherCallRejected = function(e22) {
        f(this.promise, this.onRejected, e22);
      }, l.resolve = function(e22, t22) {
        var r2 = p(c, t22);
        if ("error" === r2.status)
          return l.reject(e22, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e22, n2);
        else {
          e22.state = a, e22.outcome = t22;
          for (var i2 = -1, s2 = e22.queue.length; ++i2 < s2; )
            e22.queue[i2].callFulfilled(t22);
        }
        return e22;
      }, l.reject = function(e22, t22) {
        e22.state = s, e22.outcome = t22;
        for (var r2 = -1, n2 = e22.queue.length; ++r2 < n2; )
          e22.queue[r2].callRejected(t22);
        return e22;
      }, o.resolve = function(e22) {
        if (e22 instanceof this)
          return e22;
        return l.resolve(new this(u), e22);
      }, o.reject = function(e22) {
        var t22 = new this(u);
        return l.reject(t22, e22);
      }, o.all = function(e22) {
        var r2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e22))
          return this.reject(new TypeError("must be an array"));
        var n2 = e22.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t22 = -1, o2 = new this(u);
        for (; ++t22 < n2; )
          h2(e22[t22], t22);
        return o2;
        function h2(e3, t32) {
          r2.resolve(e3).then(function(e4) {
            s2[t32] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
          }, function(e4) {
            i2 || (i2 = true, l.reject(o2, e4));
          });
        }
      }, o.race = function(e22) {
        var t22 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e22))
          return this.reject(new TypeError("must be an array"));
        var r2 = e22.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (; ++i2 < r2; )
          a2 = e22[i2], t22.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e2, t15, r) {
      var n = {};
      (0, e2("./lib/utils/common").assign)(n, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t15.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t15, r) {
      var a = e2("./zlib/deflate"), o = e2("./utils/common"), h = e2("./utils/strings"), i = e2("./zlib/messages"), s = e2("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
      function p(e22) {
        if (!(this instanceof p))
          return new p(e22);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e22 || {});
        var t22 = this.options;
        t22.raw && 0 < t22.windowBits ? t22.windowBits = -t22.windowBits : t22.gzip && 0 < t22.windowBits && t22.windowBits < 16 && (t22.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t22.level, t22.method, t22.windowBits, t22.memLevel, t22.strategy);
        if (r2 !== l)
          throw new Error(i[r2]);
        if (t22.header && a.deflateSetHeader(this.strm, t22.header), t22.dictionary) {
          var n2;
          if (n2 = "string" == typeof t22.dictionary ? h.string2buf(t22.dictionary) : "[object ArrayBuffer]" === u.call(t22.dictionary) ? new Uint8Array(t22.dictionary) : t22.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e22, t22) {
        var r2 = new p(t22);
        if (r2.push(e22, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p.prototype.push = function(e22, t22) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t22 === ~~t22 ? t22 : true === t22 ? 4 : 0, "string" == typeof e22 ? i2.input = h.string2buf(e22) : "[object ArrayBuffer]" === u.call(e22) ? i2.input = new Uint8Array(e22) : i2.input = e22, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
        return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
      }, p.prototype.onData = function(e22) {
        this.chunks.push(e22);
      }, p.prototype.onEnd = function(e22) {
        e22 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e22, this.msg = this.strm.msg;
      }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e22, t22) {
        return (t22 = t22 || {}).raw = true, n(e22, t22);
      }, r.gzip = function(e22, t22) {
        return (t22 = t22 || {}).gzip = true, n(e22, t22);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t15, r) {
      var c = e2("./zlib/inflate"), d = e2("./utils/common"), p = e2("./utils/strings"), m = e2("./zlib/constants"), n = e2("./zlib/messages"), i = e2("./zlib/zstream"), s = e2("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(e22) {
        if (!(this instanceof a))
          return new a(e22);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e22 || {});
        var t22 = this.options;
        t22.raw && 0 <= t22.windowBits && t22.windowBits < 16 && (t22.windowBits = -t22.windowBits, 0 === t22.windowBits && (t22.windowBits = -15)), !(0 <= t22.windowBits && t22.windowBits < 16) || e22 && e22.windowBits || (t22.windowBits += 32), 15 < t22.windowBits && t22.windowBits < 48 && 0 == (15 & t22.windowBits) && (t22.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t22.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(n[r2]);
        this.header = new s(), c.inflateGetHeader(this.strm, this.header);
      }
      function o(e22, t22) {
        var r2 = new a(t22);
        if (r2.push(e22, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e22, t22) {
        var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t22 === ~~t22 ? t22 : true === t22 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e22 ? h.input = p.binstring2buf(e22) : "[object ArrayBuffer]" === _.call(e22) ? h.input = new Uint8Array(e22) : h.input = e22, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
        } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(e22) {
        this.chunks.push(e22);
      }, a.prototype.onEnd = function(e22) {
        e22 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e22, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e22, t22) {
        return (t22 = t22 || {}).raw = true, o(e22, t22);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t15, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r.assign = function(e22) {
        for (var t22 = Array.prototype.slice.call(arguments, 1); t22.length; ) {
          var r2 = t22.shift();
          if (r2) {
            if ("object" != typeof r2)
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e22[n2] = r2[n2]);
          }
        }
        return e22;
      }, r.shrinkBuf = function(e22, t22) {
        return e22.length === t22 ? e22 : e22.subarray ? e22.subarray(0, t22) : (e22.length = t22, e22);
      };
      var i = { arraySet: function(e22, t22, r2, n2, i2) {
        if (t22.subarray && e22.subarray)
          e22.set(t22.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0; s2 < n2; s2++)
            e22[i2 + s2] = t22[r2 + s2];
      }, flattenChunks: function(e22) {
        var t22, r2, n2, i2, s2, a;
        for (t22 = n2 = 0, r2 = e22.length; t22 < r2; t22++)
          n2 += e22[t22].length;
        for (a = new Uint8Array(n2), t22 = i2 = 0, r2 = e22.length; t22 < r2; t22++)
          s2 = e22[t22], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e22, t22, r2, n2, i2) {
        for (var s2 = 0; s2 < n2; s2++)
          e22[i2 + s2] = t22[r2 + s2];
      }, flattenChunks: function(e22) {
        return [].concat.apply([], e22);
      } };
      r.setTyped = function(e22) {
        e22 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e2, t15, r) {
      var h = e2("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e22) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e22) {
        s = false;
      }
      for (var u = new h.Buf8(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l(e22, t22) {
        if (t22 < 65537 && (e22.subarray && s || !e22.subarray && i))
          return String.fromCharCode.apply(null, h.shrinkBuf(e22, t22));
        for (var r2 = "", n2 = 0; n2 < t22; n2++)
          r2 += String.fromCharCode(e22[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e22) {
        var t22, r2, n2, i2, s2, a = e22.length, o = 0;
        for (i2 = 0; i2 < a; i2++)
          55296 == (64512 & (r2 = e22.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e22.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t22 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
          55296 == (64512 & (r2 = e22.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e22.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t22[s2++] = r2 : (r2 < 2048 ? t22[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t22[s2++] = 224 | r2 >>> 12 : (t22[s2++] = 240 | r2 >>> 18, t22[s2++] = 128 | r2 >>> 12 & 63), t22[s2++] = 128 | r2 >>> 6 & 63), t22[s2++] = 128 | 63 & r2);
        return t22;
      }, r.buf2binstring = function(e22) {
        return l(e22, e22.length);
      }, r.binstring2buf = function(e22) {
        for (var t22 = new h.Buf8(e22.length), r2 = 0, n2 = t22.length; r2 < n2; r2++)
          t22[r2] = e22.charCodeAt(r2);
        return t22;
      }, r.buf2string = function(e22, t22) {
        var r2, n2, i2, s2, a = t22 || e22.length, o = new Array(2 * a);
        for (r2 = n2 = 0; r2 < a; )
          if ((i2 = e22[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e22[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l(o, n2);
      }, r.utf8border = function(e22, t22) {
        var r2;
        for ((t22 = t22 || e22.length) > e22.length && (t22 = e22.length), r2 = t22 - 1; 0 <= r2 && 128 == (192 & e22[r2]); )
          r2--;
        return r2 < 0 ? t22 : 0 === r2 ? t22 : r2 + u[e22[r2]] > t22 ? r2 : t22;
      };
    }, { "./common": 41 }], 43: [function(e2, t15, r) {
      t15.exports = function(e22, t22, r2, n) {
        for (var i = 65535 & e22 | 0, s = e22 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t22[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e2, t15, r) {
      t15.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e2, t15, r) {
      var o = function() {
        for (var e22, t22 = [], r2 = 0; r2 < 256; r2++) {
          e22 = r2;
          for (var n = 0; n < 8; n++)
            e22 = 1 & e22 ? 3988292384 ^ e22 >>> 1 : e22 >>> 1;
          t22[r2] = e22;
        }
        return t22;
      }();
      t15.exports = function(e22, t22, r2, n) {
        var i = o, s = n + r2;
        e22 ^= -1;
        for (var a = n; a < s; a++)
          e22 = e22 >>> 8 ^ i[255 & (e22 ^ t22[a])];
        return -1 ^ e22;
      };
    }, {}], 46: [function(e2, t15, r) {
      var h, c = e2("../utils/common"), u = e2("./trees"), d = e2("./adler32"), p = e2("./crc32"), n = e2("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z2 = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B2 = 4;
      function R(e22, t22) {
        return e22.msg = n[t22], t22;
      }
      function T(e22) {
        return (e22 << 1) - (4 < e22 ? 9 : 0);
      }
      function D2(e22) {
        for (var t22 = e22.length; 0 <= --t22; )
          e22[t22] = 0;
      }
      function F(e22) {
        var t22 = e22.state, r2 = t22.pending;
        r2 > e22.avail_out && (r2 = e22.avail_out), 0 !== r2 && (c.arraySet(e22.output, t22.pending_buf, t22.pending_out, r2, e22.next_out), e22.next_out += r2, t22.pending_out += r2, e22.total_out += r2, e22.avail_out -= r2, t22.pending -= r2, 0 === t22.pending && (t22.pending_out = 0));
      }
      function N(e22, t22) {
        u._tr_flush_block(e22, 0 <= e22.block_start ? e22.block_start : -1, e22.strstart - e22.block_start, t22), e22.block_start = e22.strstart, F(e22.strm);
      }
      function U2(e22, t22) {
        e22.pending_buf[e22.pending++] = t22;
      }
      function P(e22, t22) {
        e22.pending_buf[e22.pending++] = t22 >>> 8 & 255, e22.pending_buf[e22.pending++] = 255 & t22;
      }
      function L(e22, t22) {
        var r2, n2, i2 = e22.max_chain_length, s2 = e22.strstart, a2 = e22.prev_length, o2 = e22.nice_match, h2 = e22.strstart > e22.w_size - z2 ? e22.strstart - (e22.w_size - z2) : 0, u2 = e22.window, l2 = e22.w_mask, f2 = e22.prev, c2 = e22.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
        e22.prev_length >= e22.good_match && (i2 >>= 2), o2 > e22.lookahead && (o2 = e22.lookahead);
        do {
          if (u2[(r2 = t22) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
              if (e22.match_start = t22, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            }
          }
        } while ((t22 = f2[t22 & l2]) > h2 && 0 != --i2);
        return a2 <= e22.lookahead ? a2 : e22.lookahead;
      }
      function j2(e22) {
        var t22, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e22.w_size;
        do {
          if (i2 = e22.window_size - e22.lookahead - e22.strstart, e22.strstart >= f2 + (f2 - z2)) {
            for (c.arraySet(e22.window, e22.window, f2, f2, 0), e22.match_start -= f2, e22.strstart -= f2, e22.block_start -= f2, t22 = r2 = e22.hash_size; n2 = e22.head[--t22], e22.head[t22] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t22 = r2 = f2; n2 = e22.prev[--t22], e22.prev[t22] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (0 === e22.strm.avail_in)
            break;
          if (a2 = e22.strm, o2 = e22.window, h2 = e22.strstart + e22.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e22.lookahead += r2, e22.lookahead + e22.insert >= x)
            for (s2 = e22.strstart - e22.insert, e22.ins_h = e22.window[s2], e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[s2 + 1]) & e22.hash_mask; e22.insert && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[s2 + x - 1]) & e22.hash_mask, e22.prev[s2 & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = s2, s2++, e22.insert--, !(e22.lookahead + e22.insert < x)); )
              ;
        } while (e22.lookahead < z2 && 0 !== e22.strm.avail_in);
      }
      function Z(e22, t22) {
        for (var r2, n2; ; ) {
          if (e22.lookahead < z2) {
            if (j2(e22), e22.lookahead < z2 && t22 === l)
              return A;
            if (0 === e22.lookahead)
              break;
          }
          if (r2 = 0, e22.lookahead >= x && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x - 1]) & e22.hash_mask, r2 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), 0 !== r2 && e22.strstart - r2 <= e22.w_size - z2 && (e22.match_length = L(e22, r2)), e22.match_length >= x)
            if (n2 = u._tr_tally(e22, e22.strstart - e22.match_start, e22.match_length - x), e22.lookahead -= e22.match_length, e22.match_length <= e22.max_lazy_match && e22.lookahead >= x) {
              for (e22.match_length--; e22.strstart++, e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x - 1]) & e22.hash_mask, r2 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart, 0 != --e22.match_length; )
                ;
              e22.strstart++;
            } else
              e22.strstart += e22.match_length, e22.match_length = 0, e22.ins_h = e22.window[e22.strstart], e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + 1]) & e22.hash_mask;
          else
            n2 = u._tr_tally(e22, 0, e22.window[e22.strstart]), e22.lookahead--, e22.strstart++;
          if (n2 && (N(e22, false), 0 === e22.strm.avail_out))
            return A;
        }
        return e22.insert = e22.strstart < x - 1 ? e22.strstart : x - 1, t22 === f ? (N(e22, true), 0 === e22.strm.avail_out ? O : B2) : e22.last_lit && (N(e22, false), 0 === e22.strm.avail_out) ? A : I;
      }
      function W(e22, t22) {
        for (var r2, n2, i2; ; ) {
          if (e22.lookahead < z2) {
            if (j2(e22), e22.lookahead < z2 && t22 === l)
              return A;
            if (0 === e22.lookahead)
              break;
          }
          if (r2 = 0, e22.lookahead >= x && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x - 1]) & e22.hash_mask, r2 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), e22.prev_length = e22.match_length, e22.prev_match = e22.match_start, e22.match_length = x - 1, 0 !== r2 && e22.prev_length < e22.max_lazy_match && e22.strstart - r2 <= e22.w_size - z2 && (e22.match_length = L(e22, r2), e22.match_length <= 5 && (1 === e22.strategy || e22.match_length === x && 4096 < e22.strstart - e22.match_start) && (e22.match_length = x - 1)), e22.prev_length >= x && e22.match_length <= e22.prev_length) {
            for (i2 = e22.strstart + e22.lookahead - x, n2 = u._tr_tally(e22, e22.strstart - 1 - e22.prev_match, e22.prev_length - x), e22.lookahead -= e22.prev_length - 1, e22.prev_length -= 2; ++e22.strstart <= i2 && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x - 1]) & e22.hash_mask, r2 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), 0 != --e22.prev_length; )
              ;
            if (e22.match_available = 0, e22.match_length = x - 1, e22.strstart++, n2 && (N(e22, false), 0 === e22.strm.avail_out))
              return A;
          } else if (e22.match_available) {
            if ((n2 = u._tr_tally(e22, 0, e22.window[e22.strstart - 1])) && N(e22, false), e22.strstart++, e22.lookahead--, 0 === e22.strm.avail_out)
              return A;
          } else
            e22.match_available = 1, e22.strstart++, e22.lookahead--;
        }
        return e22.match_available && (n2 = u._tr_tally(e22, 0, e22.window[e22.strstart - 1]), e22.match_available = 0), e22.insert = e22.strstart < x - 1 ? e22.strstart : x - 1, t22 === f ? (N(e22, true), 0 === e22.strm.avail_out ? O : B2) : e22.last_lit && (N(e22, false), 0 === e22.strm.avail_out) ? A : I;
      }
      function M(e22, t22, r2, n2, i2) {
        this.good_length = e22, this.max_lazy = t22, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H2() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G2(e22) {
        var t22;
        return e22 && e22.state ? (e22.total_in = e22.total_out = 0, e22.data_type = i, (t22 = e22.state).pending = 0, t22.pending_out = 0, t22.wrap < 0 && (t22.wrap = -t22.wrap), t22.status = t22.wrap ? C : E, e22.adler = 2 === t22.wrap ? 0 : 1, t22.last_flush = l, u._tr_init(t22), m) : R(e22, _);
      }
      function K(e22) {
        var t22 = G2(e22);
        return t22 === m && function(e3) {
          e3.window_size = 2 * e3.w_size, D2(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
        }(e22.state), t22;
      }
      function Y2(e22, t22, r2, n2, i2, s2) {
        if (!e22)
          return _;
        var a2 = 1;
        if (t22 === g && (t22 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t22 < 0 || 9 < t22 || s2 < 0 || b < s2)
          return R(e22, _);
        8 === n2 && (n2 = 9);
        var o2 = new H2();
        return (e22.state = o2).strm = e22, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t22, o2.strategy = s2, o2.method = r2, K(e22);
      }
      h = [new M(0, 0, 0, 0, function(e22, t22) {
        var r2 = 65535;
        for (r2 > e22.pending_buf_size - 5 && (r2 = e22.pending_buf_size - 5); ; ) {
          if (e22.lookahead <= 1) {
            if (j2(e22), 0 === e22.lookahead && t22 === l)
              return A;
            if (0 === e22.lookahead)
              break;
          }
          e22.strstart += e22.lookahead, e22.lookahead = 0;
          var n2 = e22.block_start + r2;
          if ((0 === e22.strstart || e22.strstart >= n2) && (e22.lookahead = e22.strstart - n2, e22.strstart = n2, N(e22, false), 0 === e22.strm.avail_out))
            return A;
          if (e22.strstart - e22.block_start >= e22.w_size - z2 && (N(e22, false), 0 === e22.strm.avail_out))
            return A;
        }
        return e22.insert = 0, t22 === f ? (N(e22, true), 0 === e22.strm.avail_out ? O : B2) : (e22.strstart > e22.block_start && (N(e22, false), e22.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e22, t22) {
        return Y2(e22, t22, v, 15, 8, 0);
      }, r.deflateInit2 = Y2, r.deflateReset = K, r.deflateResetKeep = G2, r.deflateSetHeader = function(e22, t22) {
        return e22 && e22.state ? 2 !== e22.state.wrap ? _ : (e22.state.gzhead = t22, m) : _;
      }, r.deflate = function(e22, t22) {
        var r2, n2, i2, s2;
        if (!e22 || !e22.state || 5 < t22 || t22 < 0)
          return e22 ? R(e22, _) : _;
        if (n2 = e22.state, !e22.output || !e22.input && 0 !== e22.avail_in || 666 === n2.status && t22 !== f)
          return R(e22, 0 === e22.avail_out ? -5 : _);
        if (n2.strm = e22, r2 = n2.last_flush, n2.last_flush = t22, n2.status === C)
          if (2 === n2.wrap)
            e22.adler = 0, U2(n2, 31), U2(n2, 139), U2(n2, 8), n2.gzhead ? (U2(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U2(n2, 255 & n2.gzhead.time), U2(n2, n2.gzhead.time >> 8 & 255), U2(n2, n2.gzhead.time >> 16 & 255), U2(n2, n2.gzhead.time >> 24 & 255), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U2(n2, 255 & n2.gzhead.extra.length), U2(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e22.adler >>> 16), P(n2, 65535 & e22.adler)), e22.adler = 1;
          }
        if (69 === n2.status)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), F(e22), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U2(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (73 === n2.status)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), F(e22), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (91 === n2.status)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), F(e22), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else
            n2.status = 103;
        if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e22), n2.pending + 2 <= n2.pending_buf_size && (U2(n2, 255 & e22.adler), U2(n2, e22.adler >> 8 & 255), e22.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
          if (F(e22), 0 === e22.avail_out)
            return n2.last_flush = -1, m;
        } else if (0 === e22.avail_in && T(t22) <= T(r2) && t22 !== f)
          return R(e22, -5);
        if (666 === n2.status && 0 !== e22.avail_in)
          return R(e22, -5);
        if (0 !== e22.avail_in || 0 !== n2.lookahead || t22 !== l && 666 !== n2.status) {
          var o2 = 2 === n2.strategy ? function(e3, t32) {
            for (var r3; ; ) {
              if (0 === e3.lookahead && (j2(e3), 0 === e3.lookahead)) {
                if (t32 === l)
                  return A;
                break;
              }
              if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t32 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B2) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t22) : 3 === n2.strategy ? function(e3, t32) {
            for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
              if (e3.lookahead <= S) {
                if (j2(e3), e3.lookahead <= S && t32 === l)
                  return A;
                if (0 === e3.lookahead)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e3.strstart + S;
                do {
                } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t32 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B2) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t22) : h[n2.level].func(n2, t22);
          if (o2 !== O && o2 !== B2 || (n2.status = 666), o2 === A || o2 === O)
            return 0 === e22.avail_out && (n2.last_flush = -1), m;
          if (o2 === I && (1 === t22 ? u._tr_align(n2) : 5 !== t22 && (u._tr_stored_block(n2, 0, 0, false), 3 === t22 && (D2(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e22), 0 === e22.avail_out))
            return n2.last_flush = -1, m;
        }
        return t22 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U2(n2, 255 & e22.adler), U2(n2, e22.adler >> 8 & 255), U2(n2, e22.adler >> 16 & 255), U2(n2, e22.adler >> 24 & 255), U2(n2, 255 & e22.total_in), U2(n2, e22.total_in >> 8 & 255), U2(n2, e22.total_in >> 16 & 255), U2(n2, e22.total_in >> 24 & 255)) : (P(n2, e22.adler >>> 16), P(n2, 65535 & e22.adler)), F(e22), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
      }, r.deflateEnd = function(e22) {
        var t22;
        return e22 && e22.state ? (t22 = e22.state.status) !== C && 69 !== t22 && 73 !== t22 && 91 !== t22 && 103 !== t22 && t22 !== E && 666 !== t22 ? R(e22, _) : (e22.state = null, t22 === E ? R(e22, -3) : m) : _;
      }, r.deflateSetDictionary = function(e22, t22) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t22.length;
        if (!e22 || !e22.state)
          return _;
        if (2 === (s2 = (r2 = e22.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
          return _;
        for (1 === s2 && (e22.adler = d(e22.adler, t22, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D2(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t22, l2 - r2.w_size, r2.w_size, 0), t22 = u2, l2 = r2.w_size), a2 = e22.avail_in, o2 = e22.next_in, h2 = e22.input, e22.avail_in = l2, e22.next_in = 0, e22.input = t22, j2(r2); r2.lookahead >= x; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x - 1, j2(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e22.next_in = o2, e22.input = h2, e22.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t15, r) {
      t15.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e2, t15, r) {
      t15.exports = function(e22, t22) {
        var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z2, C;
        r2 = e22.state, n = e22.next_in, z2 = e22.input, i = n + (e22.avail_in - 5), s = e22.next_out, C = e22.output, a = s - (t22 - e22.avail_out), o = s + (e22.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = m[d & g];
            t:
              for (; ; ) {
                if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e22.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (d += z2[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = _[d & b];
                  r:
                    for (; ; ) {
                      if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e22.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (d += z2[n++] << p, (p += 8) < y && (d += z2[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                        e22.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e22.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; )
                            ;
                          x = s - k, S = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e22.next_in = n, e22.next_out = s, e22.avail_in = n < i ? i - n + 5 : 5 - (n - i), e22.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
      };
    }, {}], 49: [function(e2, t15, r) {
      var I = e2("../utils/common"), O = e2("./adler32"), B2 = e2("./crc32"), R = e2("./inffast"), T = e2("./inftrees"), D2 = 1, F = 2, N = 0, U2 = -2, P = 1, n = 852, i = 592;
      function L(e22) {
        return (e22 >>> 24 & 255) + (e22 >>> 8 & 65280) + ((65280 & e22) << 8) + ((255 & e22) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e22) {
        var t22;
        return e22 && e22.state ? (t22 = e22.state, e22.total_in = e22.total_out = t22.total = 0, e22.msg = "", t22.wrap && (e22.adler = 1 & t22.wrap), t22.mode = P, t22.last = 0, t22.havedict = 0, t22.dmax = 32768, t22.head = null, t22.hold = 0, t22.bits = 0, t22.lencode = t22.lendyn = new I.Buf32(n), t22.distcode = t22.distdyn = new I.Buf32(i), t22.sane = 1, t22.back = -1, N) : U2;
      }
      function o(e22) {
        var t22;
        return e22 && e22.state ? ((t22 = e22.state).wsize = 0, t22.whave = 0, t22.wnext = 0, a(e22)) : U2;
      }
      function h(e22, t22) {
        var r2, n2;
        return e22 && e22.state ? (n2 = e22.state, t22 < 0 ? (r2 = 0, t22 = -t22) : (r2 = 1 + (t22 >> 4), t22 < 48 && (t22 &= 15)), t22 && (t22 < 8 || 15 < t22) ? U2 : (null !== n2.window && n2.wbits !== t22 && (n2.window = null), n2.wrap = r2, n2.wbits = t22, o(e22))) : U2;
      }
      function u(e22, t22) {
        var r2, n2;
        return e22 ? (n2 = new s(), (e22.state = n2).window = null, (r2 = h(e22, t22)) !== N && (e22.state = null), r2) : U2;
      }
      var l, f, c = true;
      function j2(e22) {
        if (c) {
          var t22;
          for (l = new I.Buf32(512), f = new I.Buf32(32), t22 = 0; t22 < 144; )
            e22.lens[t22++] = 8;
          for (; t22 < 256; )
            e22.lens[t22++] = 9;
          for (; t22 < 280; )
            e22.lens[t22++] = 7;
          for (; t22 < 288; )
            e22.lens[t22++] = 8;
          for (T(D2, e22.lens, 0, 288, l, 0, e22.work, { bits: 9 }), t22 = 0; t22 < 32; )
            e22.lens[t22++] = 5;
          T(F, e22.lens, 0, 32, f, 0, e22.work, { bits: 5 }), c = false;
        }
        e22.lencode = l, e22.lenbits = 9, e22.distcode = f, e22.distbits = 5;
      }
      function Z(e22, t22, r2, n2) {
        var i2, s2 = e22.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t22, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t22, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t22, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e22) {
        return u(e22, 15);
      }, r.inflateInit2 = u, r.inflate = function(e22, t22) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z2, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e22 || !e22.state || !e22.output || !e22.input && 0 !== e22.avail_in)
          return U2;
        12 === (r2 = e22.state).mode && (r2.mode = 13), a2 = e22.next_out, i2 = e22.output, h2 = e22.avail_out, s2 = e22.next_in, n2 = e22.input, o2 = e22.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
        e:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e22.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e22.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  e22.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e22.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e22.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e22.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B2(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e22.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e22.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e22.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict)
                  return e22.next_out = a2, e22.avail_out = h2, e22.next_in = s2, e22.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e22.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t22 || 6 === t22)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j2(r2), r2.mode = 20, 6 !== t22)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e22.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e22.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t22)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                    break e;
                  I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e22.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e22.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z2 = _ + 2; l2 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        e22.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z2 = _ + 3; l2 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z2 = _ + 7; l2 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e22.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode)
                  break;
                if (0 === r2.lens[256]) {
                  e22.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e22.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  e22.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t22)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e22.next_out = a2, e22.avail_out = h2, e22.next_in = s2, e22.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e22, c2), a2 = e22.next_out, i2 = e22.output, h2 = e22.avail_out, s2 = e22.next_in, n2 = e22.input, o2 = e22.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e22.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z2 = r2.extra; l2 < z2; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e22.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z2 = r2.extra; l2 < z2; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e22.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2)
                  break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e22.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else
                  m = i2, p = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                  ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2)
                  break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h2, e22.total_out += c2, r2.total += c2, c2 && (e22.adler = r2.check = r2.flags ? B2(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    e22.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e22.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U2;
            }
        return e22.next_out = a2, e22.avail_out = h2, e22.next_in = s2, e22.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e22.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t22)) && Z(e22, e22.output, e22.next_out, c2 - e22.avail_out) ? (r2.mode = 31, -4) : (f2 -= e22.avail_in, c2 -= e22.avail_out, e22.total_in += f2, e22.total_out += c2, r2.total += c2, r2.wrap && c2 && (e22.adler = r2.check = r2.flags ? B2(r2.check, i2, c2, e22.next_out - c2) : O(r2.check, i2, c2, e22.next_out - c2)), e22.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t22) && x === N && (x = -5), x);
      }, r.inflateEnd = function(e22) {
        if (!e22 || !e22.state)
          return U2;
        var t22 = e22.state;
        return t22.window && (t22.window = null), e22.state = null, N;
      }, r.inflateGetHeader = function(e22, t22) {
        var r2;
        return e22 && e22.state ? 0 == (2 & (r2 = e22.state).wrap) ? U2 : ((r2.head = t22).done = false, N) : U2;
      }, r.inflateSetDictionary = function(e22, t22) {
        var r2, n2 = t22.length;
        return e22 && e22.state ? 0 !== (r2 = e22.state).wrap && 11 !== r2.mode ? U2 : 11 === r2.mode && O(1, t22, n2, 0) !== r2.check ? -3 : Z(e22, t22, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U2;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t15, r) {
      var D2 = e2("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t15.exports = function(e22, t22, r2, n, i, s, a, o) {
        var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z2 = 0, C = 0, E = 0, A = null, I = 0, O = new D2.Buf16(16), B2 = new D2.Buf16(16), R = null, T = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < n; v++)
          O[t22[r2 + v]]++;
        for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
          ;
        if (w < k && (k = w), 0 === w)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w && 0 === O[y]; y++)
          ;
        for (k < y && (k = y), b = z2 = 1; b <= 15; b++)
          if (z2 <<= 1, (z2 -= O[b]) < 0)
            return -1;
        if (0 < z2 && (0 === e22 || 1 !== w))
          return -1;
        for (B2[1] = 0, b = 1; b < 15; b++)
          B2[b + 1] = B2[b] + O[b];
        for (v = 0; v < n; v++)
          0 !== t22[r2 + v] && (a[B2[t22[r2 + v]]++] = v);
        if (d = 0 === e22 ? (A = R = a, 19) : 1 === e22 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U2, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e22 && 852 < C || 2 === e22 && 592 < C)
          return 1;
        for (; ; ) {
          for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
            ;
          for (h = 1 << b - 1; E & h; )
            h >>= 1;
          if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
            if (b === w)
              break;
            b = t22[r2 + a[v]];
          }
          if (k < b && (E & f) !== l) {
            for (0 === S && (S = k), c += y, z2 = 1 << (x = b - S); x + S < w && !((z2 -= O[x + S]) <= 0); )
              x++, z2 <<= 1;
            if (C += 1 << x, 1 === e22 && 852 < C || 2 === e22 && 592 < C)
              return 1;
            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
          }
        }
        return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e2, t15, r) {
      t15.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e2, t15, r) {
      var i = e2("../utils/common"), o = 0, h = 1;
      function n(e22) {
        for (var t22 = e22.length; 0 <= --t22; )
          e22[t22] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l + 2));
      n(z2);
      var C = new Array(2 * f);
      n(C);
      var E = new Array(512);
      n(E);
      var A = new Array(256);
      n(A);
      var I = new Array(a);
      n(I);
      var O, B2, R, T = new Array(f);
      function D2(e22, t22, r2, n2, i2) {
        this.static_tree = e22, this.extra_bits = t22, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e22 && e22.length;
      }
      function F(e22, t22) {
        this.dyn_tree = e22, this.max_code = 0, this.stat_desc = t22;
      }
      function N(e22) {
        return e22 < 256 ? E[e22] : E[256 + (e22 >>> 7)];
      }
      function U2(e22, t22) {
        e22.pending_buf[e22.pending++] = 255 & t22, e22.pending_buf[e22.pending++] = t22 >>> 8 & 255;
      }
      function P(e22, t22, r2) {
        e22.bi_valid > d - r2 ? (e22.bi_buf |= t22 << e22.bi_valid & 65535, U2(e22, e22.bi_buf), e22.bi_buf = t22 >> d - e22.bi_valid, e22.bi_valid += r2 - d) : (e22.bi_buf |= t22 << e22.bi_valid & 65535, e22.bi_valid += r2);
      }
      function L(e22, t22, r2) {
        P(e22, r2[2 * t22], r2[2 * t22 + 1]);
      }
      function j2(e22, t22) {
        for (var r2 = 0; r2 |= 1 & e22, e22 >>>= 1, r2 <<= 1, 0 < --t22; )
          ;
        return r2 >>> 1;
      }
      function Z(e22, t22, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1; n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= t22; i2++) {
          var o2 = e22[2 * i2 + 1];
          0 !== o2 && (e22[2 * i2] = j2(s2[o2]++, o2));
        }
      }
      function W(e22) {
        var t22;
        for (t22 = 0; t22 < l; t22++)
          e22.dyn_ltree[2 * t22] = 0;
        for (t22 = 0; t22 < f; t22++)
          e22.dyn_dtree[2 * t22] = 0;
        for (t22 = 0; t22 < c; t22++)
          e22.bl_tree[2 * t22] = 0;
        e22.dyn_ltree[2 * m] = 1, e22.opt_len = e22.static_len = 0, e22.last_lit = e22.matches = 0;
      }
      function M(e22) {
        8 < e22.bi_valid ? U2(e22, e22.bi_buf) : 0 < e22.bi_valid && (e22.pending_buf[e22.pending++] = e22.bi_buf), e22.bi_buf = 0, e22.bi_valid = 0;
      }
      function H2(e22, t22, r2, n2) {
        var i2 = 2 * t22, s2 = 2 * r2;
        return e22[i2] < e22[s2] || e22[i2] === e22[s2] && n2[t22] <= n2[r2];
      }
      function G2(e22, t22, r2) {
        for (var n2 = e22.heap[r2], i2 = r2 << 1; i2 <= e22.heap_len && (i2 < e22.heap_len && H2(t22, e22.heap[i2 + 1], e22.heap[i2], e22.depth) && i2++, !H2(t22, n2, e22.heap[i2], e22.depth)); )
          e22.heap[r2] = e22.heap[i2], r2 = i2, i2 <<= 1;
        e22.heap[r2] = n2;
      }
      function K(e22, t22, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (0 !== e22.last_lit)
          for (; n2 = e22.pending_buf[e22.d_buf + 2 * o2] << 8 | e22.pending_buf[e22.d_buf + 2 * o2 + 1], i2 = e22.pending_buf[e22.l_buf + o2], o2++, 0 === n2 ? L(e22, i2, t22) : (L(e22, (s2 = A[i2]) + u + 1, t22), 0 !== (a2 = w[s2]) && P(e22, i2 -= I[s2], a2), L(e22, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e22, n2 -= T[s2], a2)), o2 < e22.last_lit; )
            ;
        L(e22, m, t22);
      }
      function Y2(e22, t22) {
        var r2, n2, i2, s2 = t22.dyn_tree, a2 = t22.stat_desc.static_tree, o2 = t22.stat_desc.has_stree, h2 = t22.stat_desc.elems, u2 = -1;
        for (e22.heap_len = 0, e22.heap_max = _, r2 = 0; r2 < h2; r2++)
          0 !== s2[2 * r2] ? (e22.heap[++e22.heap_len] = u2 = r2, e22.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; e22.heap_len < 2; )
          s2[2 * (i2 = e22.heap[++e22.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e22.depth[i2] = 0, e22.opt_len--, o2 && (e22.static_len -= a2[2 * i2 + 1]);
        for (t22.max_code = u2, r2 = e22.heap_len >> 1; 1 <= r2; r2--)
          G2(e22, s2, r2);
        for (i2 = h2; r2 = e22.heap[1], e22.heap[1] = e22.heap[e22.heap_len--], G2(e22, s2, 1), n2 = e22.heap[1], e22.heap[--e22.heap_max] = r2, e22.heap[--e22.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e22.depth[i2] = (e22.depth[r2] >= e22.depth[n2] ? e22.depth[r2] : e22.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e22.heap[1] = i2++, G2(e22, s2, 1), 2 <= e22.heap_len; )
          ;
        e22.heap[--e22.heap_max] = e22.heap[1], function(e3, t32) {
          var r3, n3, i3, s3, a3, o3, h3 = t32.dyn_tree, u3 = t32.max_code, l2 = t32.stat_desc.static_tree, f2 = t32.stat_desc.has_stree, c2 = t32.stat_desc.extra_bits, d2 = t32.stat_desc.extra_base, p2 = t32.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            e3.bl_count[s3] = 0;
          for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
            p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
          if (0 !== m2) {
            do {
              for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                s3--;
              e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p2; 0 !== s3; s3--)
              for (n3 = e3.bl_count[s3]; 0 !== n3; )
                u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
          }
        }(e22, t22), Z(s2, u2, e22.bl_count);
      }
      function X(e22, t22, r2) {
        var n2, i2, s2 = -1, a2 = t22[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), t22[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = t22[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e22.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e22.bl_tree[2 * i2]++, e22.bl_tree[2 * b]++) : o2 <= 10 ? e22.bl_tree[2 * v]++ : e22.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V2(e22, t22, r2) {
        var n2, i2, s2 = -1, a2 = t22[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = t22[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2)
              for (; L(e22, i2, e22.bl_tree), 0 != --o2; )
                ;
            else
              0 !== i2 ? (i2 !== s2 && (L(e22, i2, e22.bl_tree), o2--), L(e22, b, e22.bl_tree), P(e22, o2 - 3, 2)) : o2 <= 10 ? (L(e22, v, e22.bl_tree), P(e22, o2 - 3, 3)) : (L(e22, y, e22.bl_tree), P(e22, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      n(T);
      var q = false;
      function J(e22, t22, r2, n2) {
        P(e22, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t32, r3, n3) {
          M(e3), U2(e3, r3), U2(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t32, r3, e3.pending), e3.pending += r3;
        }(e22, t22, r2);
      }
      r._tr_init = function(e22) {
        q || (function() {
          var e3, t22, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0; n2 < a - 1; n2++)
            for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
              A[r2++] = n2;
          for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
            for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
              E[i2++] = n2;
          for (i2 >>= 7; n2 < f; n2++)
            for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
              E[256 + i2++] = n2;
          for (t22 = 0; t22 <= g; t22++)
            s2[t22] = 0;
          for (e3 = 0; e3 <= 143; )
            z2[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (; e3 <= 255; )
            z2[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (; e3 <= 279; )
            z2[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (; e3 <= 287; )
            z2[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (Z(z2, l + 1, s2), e3 = 0; e3 < f; e3++)
            C[2 * e3 + 1] = 5, C[2 * e3] = j2(e3, 5);
          O = new D2(z2, w, u + 1, l, g), B2 = new D2(C, k, 0, f, g), R = new D2(new Array(0), x, 0, c, p);
        }(), q = true), e22.l_desc = new F(e22.dyn_ltree, O), e22.d_desc = new F(e22.dyn_dtree, B2), e22.bl_desc = new F(e22.bl_tree, R), e22.bi_buf = 0, e22.bi_valid = 0, W(e22);
      }, r._tr_stored_block = J, r._tr_flush_block = function(e22, t22, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e22.level ? (2 === e22.strm.data_type && (e22.strm.data_type = function(e3) {
          var t32, r3 = 4093624447;
          for (t32 = 0; t32 <= 31; t32++, r3 >>>= 1)
            if (1 & r3 && 0 !== e3.dyn_ltree[2 * t32])
              return o;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
            return h;
          for (t32 = 32; t32 < u; t32++)
            if (0 !== e3.dyn_ltree[2 * t32])
              return h;
          return o;
        }(e22)), Y2(e22, e22.l_desc), Y2(e22, e22.d_desc), a2 = function(e3) {
          var t32;
          for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y2(e3, e3.bl_desc), t32 = c - 1; 3 <= t32 && 0 === e3.bl_tree[2 * S[t32] + 1]; t32--)
            ;
          return e3.opt_len += 3 * (t32 + 1) + 5 + 5 + 4, t32;
        }(e22), i2 = e22.opt_len + 3 + 7 >>> 3, (s2 = e22.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t22 ? J(e22, t22, r2, n2) : 4 === e22.strategy || s2 === i2 ? (P(e22, 2 + (n2 ? 1 : 0), 3), K(e22, z2, C)) : (P(e22, 4 + (n2 ? 1 : 0), 3), function(e3, t32, r3, n3) {
          var i3;
          for (P(e3, t32 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
          V2(e3, e3.dyn_ltree, t32 - 1), V2(e3, e3.dyn_dtree, r3 - 1);
        }(e22, e22.l_desc.max_code + 1, e22.d_desc.max_code + 1, a2 + 1), K(e22, e22.dyn_ltree, e22.dyn_dtree)), W(e22), n2 && M(e22);
      }, r._tr_tally = function(e22, t22, r2) {
        return e22.pending_buf[e22.d_buf + 2 * e22.last_lit] = t22 >>> 8 & 255, e22.pending_buf[e22.d_buf + 2 * e22.last_lit + 1] = 255 & t22, e22.pending_buf[e22.l_buf + e22.last_lit] = 255 & r2, e22.last_lit++, 0 === t22 ? e22.dyn_ltree[2 * r2]++ : (e22.matches++, t22--, e22.dyn_ltree[2 * (A[r2] + u + 1)]++, e22.dyn_dtree[2 * N(t22)]++), e22.last_lit === e22.lit_bufsize - 1;
      }, r._tr_align = function(e22) {
        P(e22, 2, 3), L(e22, m, z2), function(e3) {
          16 === e3.bi_valid ? (U2(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        }(e22);
      };
    }, { "../utils/common": 41 }], 53: [function(e2, t15, r) {
      t15.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e2, t15, r) {
      (function(e22) {
        !function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t22, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
              process.nextTick(function() {
                c(e4);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e4 = true, t32 = r2.onmessage;
                return r2.onmessage = function() {
                  e4 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t32, e4;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
              r2.postMessage(a + e4, "*");
            }) : r2.MessageChannel ? ((t22 = new MessageChannel()).port1.onmessage = function(e4) {
              c(e4.data);
            }, function(e4) {
              t22.port2.postMessage(e4);
            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
              var t32 = l.createElement("script");
              t32.onreadystatechange = function() {
                c(e4), t32.onreadystatechange = null, s.removeChild(t32), t32 = null;
              }, s.appendChild(t32);
            }) : function(e4) {
              setTimeout(c, 0, e4);
            }, e3.setImmediate = function(e4) {
              "function" != typeof e4 && (e4 = new Function("" + e4));
              for (var t32 = new Array(arguments.length - 1), r3 = 0; r3 < t32.length; r3++)
                t32[r3] = arguments[r3 + 1];
              var n2 = { callback: e4, args: t32 };
              return h[o] = n2, i(o), o++;
            }, e3.clearImmediate = f;
          }
          function f(e4) {
            delete h[e4];
          }
          function c(e4) {
            if (u)
              setTimeout(c, 0, e4);
            else {
              var t32 = h[e4];
              if (t32) {
                u = true;
                try {
                  !function(e5) {
                    var t42 = e5.callback, r3 = e5.args;
                    switch (r3.length) {
                      case 0:
                        t42();
                        break;
                      case 1:
                        t42(r3[0]);
                        break;
                      case 2:
                        t42(r3[0], r3[1]);
                        break;
                      case 3:
                        t42(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t42.apply(n, r3);
                    }
                  }(t32);
                } finally {
                  f(e4), u = false;
                }
              }
            }
          }
          function d(e4) {
            e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
          }
        }("undefined" == typeof self ? void 0 === e22 ? this : e22 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
var JSZip = getDefaultExportFromCjs(jszip_minExports);
var validator$2 = {};
var util$3 = {};
(function(exports) {
  const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  const nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  const regexName = new RegExp("^" + nameRegexp + "$");
  const getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0; index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  const isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        if (arrayMode === "strict") {
          target[keys[i]] = [a[keys[i]]];
        } else {
          target[keys[i]] = a[keys[i]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
})(util$3);
var util$2 = util$3;
var defaultOptions$2 = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
validator$2.validate = function(xmlData, options) {
  options = Object.assign({}, defaultOptions$2, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err)
        return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1)
            ;
          else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err)
                return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t15) => t15.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
};
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
var doubleQuote = '"';
var singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i])
        ;
      else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = util$2.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return util$2.isName(attrName);
}
function validateTagName(tagname) {
  return util$2.isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}
var OptionsBuilder = {};
var defaultOptions$1 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val2) {
    return val2;
  },
  attributeValueProcessor: function(attrName, val2) {
    return val2;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  }
  // skipEmptyListItem: false
};
var buildOptions$1 = function(options) {
  return Object.assign({}, defaultOptions$1, options);
};
OptionsBuilder.buildOptions = buildOptions$1;
OptionsBuilder.defaultOptions = defaultOptions$1;
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val2) {
    if (key === "__proto__")
      key = "#__proto__";
    this.child.push({ [key]: val2 });
  }
  addChild(node) {
    if (node.tagname === "__proto__")
      node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
  }
};
var xmlNode$1 = XmlNode;
var util$1 = util$3;
function readDocType$1(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && isEntity(xmlData, i)) {
          i += 7;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[validateEntityName(entityName)] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && isElement(xmlData, i))
          i += 8;
        else if (hasBody && isAttlist(xmlData, i))
          i += 8;
        else if (hasBody && isNotation(xmlData, i))
          i += 9;
        else
          comment = true;
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
function readEntityExp(xmlData, i) {
  let entityName2 = "";
  for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
    entityName2 += xmlData[i];
  }
  entityName2 = entityName2.trim();
  if (entityName2.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const startChar = xmlData[i++];
  let val2 = "";
  for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
    val2 += xmlData[i];
  }
  return [entityName2, val2, i];
}
function isEntity(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
    return true;
  return false;
}
function isElement(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isAttlist(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isNotation(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
    return true;
  return false;
}
function validateEntityName(name) {
  if (util$1.isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}
var DocTypeReader = readDocType$1;
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
if (!Number.parseInt && window.parseInt) {
  Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
  Number.parseFloat = window.parseFloat;
}
var consider = {
  hex: true,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber$1(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string")
    return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
    return str;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return Number.parseInt(trimmedStr, 16);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign2 = match[1];
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const eNotation = match[4] || match[6];
      if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
        return str;
      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
        return str;
      else {
        const num = Number(trimmedStr);
        const numStr = "" + num;
        if (numStr.search(/[eE]/) !== -1) {
          if (options.eNotation)
            return num;
          else
            return str;
        } else if (eNotation) {
          if (options.eNotation)
            return num;
          else
            return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (numStr === "0" && numTrimmedByZeros === "")
            return num;
          else if (numStr === numTrimmedByZeros)
            return num;
          else if (sign2 && numStr === "-" + numTrimmedByZeros)
            return num;
          else
            return str;
        }
        if (leadingZeros) {
          if (numTrimmedByZeros === numStr)
            return num;
          else if (sign2 + numTrimmedByZeros === numStr)
            return num;
          else
            return str;
        }
        if (trimmedStr === numStr)
          return num;
        else if (trimmedStr === sign2 + numStr)
          return num;
        return str;
      }
    } else {
      return str;
    }
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".")
      numStr = "0";
    else if (numStr[0] === ".")
      numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".")
      numStr = numStr.substr(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
var strnum = toNumber$1;
var util = util$3;
var xmlNode = xmlNode$1;
var readDocType = DocTypeReader;
var toNumber = strnum;
var OrderedObjParser$1 = class OrderedObjParser {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "¢" },
      "pound": { regex: /&(pound|#163);/g, val: "£" },
      "yen": { regex: /&(yen|#165);/g, val: "¥" },
      "euro": { regex: /&(euro|#8364);/g, val: "€" },
      "copyright": { regex: /&(copy|#169);/g, val: "©" },
      "reg": { regex: /&(reg|#174);/g, val: "®" },
      "inr": { regex: /&(inr|#8377);/g, val: "₹" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue$1;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val2 !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val2 = val2.trim();
    }
    if (val2.length > 0) {
      if (!escapeEntities)
        val2 = this.replaceEntitiesValue(val2);
      const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val2;
      } else if (typeof newval !== typeof val2 || newval !== val2) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val2.trim();
        if (trimmedVal === val2) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val2;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === "string") {
    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__")
          aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new xmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData)
          throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags)
          ;
        else {
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val2 == void 0)
          val2 = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val2);
        }
        i = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2)
              throw new Error(`Unexpected end of ${rawTagName}`);
            i = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new xmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new xmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath) {
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false)
    ;
  else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode);
  } else {
    currentNode.addChild(childNode);
  }
}
var replaceEntitiesValue$1 = function(val2) {
  if (this.options.processEntities) {
    for (let entityName2 in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName2];
      val2 = val2.replace(entity.regx, entity.val);
    }
    for (let entityName2 in this.lastEntities) {
      const entity = this.lastEntities[entityName2];
      val2 = val2.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName2 in this.htmlEntities) {
        const entity = this.htmlEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
    }
    val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val2;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0)
      isLeafNode = Object.keys(currentNode.child).length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
      return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary)
        attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result)
    return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val2, shouldParse, options) {
  if (shouldParse && typeof val2 === "string") {
    const newval = val2.trim();
    if (newval === "true")
      return true;
    else if (newval === "false")
      return false;
    else
      return toNumber(val2, options);
  } else {
    if (util.isExist(val2)) {
      return val2;
    } else {
      return "";
    }
  }
}
var OrderedObjParser_1 = OrderedObjParser$1;
var node2json = {};
function prettify$1(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName$1(tagObj);
    let newJpath = "";
    if (jPath === void 0)
      newJpath = property;
    else
      newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text === void 0)
        text = tagObj[property];
      else
        text += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val2 = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val2, options);
      if (tagObj[":@"]) {
        assignAttributes(val2, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val2 = val2[options.textNodeName];
      } else if (Object.keys(val2).length === 0) {
        if (options.alwaysCreateTextNode)
          val2[options.textNodeName] = "";
        else
          val2 = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val2);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val2];
        } else {
          compressedObj[property] = val2;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0)
      compressedObj[options.textNodeName] = text;
  } else if (text !== void 0)
    compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName$1(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key !== ":@")
      return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
node2json.prettify = prettify$1;
var { buildOptions } = OptionsBuilder;
var OrderedObjParser2 = OrderedObjParser_1;
var { prettify } = node2json;
var validator$1 = validator$2;
var XMLParser$1 = class XMLParser {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData === "string")
      ;
    else if (xmlData.toString) {
      xmlData = xmlData.toString();
    } else {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true)
        validationOption = {};
      const result = validator$1.validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser2(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0)
      return orderedResult;
    else
      return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
};
var XMLParser_1 = XMLParser$1;
var EOL = "\n";
function toXml(jArray, options) {
  let indentation = "";
  if (options.format && options.indentBy.length > 0) {
    indentation = EOL;
  }
  return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
  let xmlStr = "";
  let isPreviousElementTag = false;
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const tagName = propName(tagObj);
    if (tagName === void 0)
      continue;
    let newJPath = "";
    if (jPath.length === 0)
      newJPath = tagName;
    else
      newJPath = `${jPath}.${tagName}`;
    if (tagName === options.textNodeName) {
      let tagText = tagObj[tagName];
      if (!isStopNode(newJPath, options)) {
        tagText = options.tagValueProcessor(tagName, tagText);
        tagText = replaceEntitiesValue(tagText, options);
      }
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += tagText;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.cdataPropName) {
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.commentPropName) {
      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
      isPreviousElementTag = true;
      continue;
    } else if (tagName[0] === "?") {
      const attStr2 = attr_to_str(tagObj[":@"], options);
      const tempInd = tagName === "?xml" ? "" : indentation;
      let piTextNodeName = tagObj[tagName][0][options.textNodeName];
      piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
      isPreviousElementTag = true;
      continue;
    }
    let newIdentation = indentation;
    if (newIdentation !== "") {
      newIdentation += options.indentBy;
    }
    const attStr = attr_to_str(tagObj[":@"], options);
    const tagStart = indentation + `<${tagName}${attStr}`;
    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    if (options.unpairedTags.indexOf(tagName) !== -1) {
      if (options.suppressUnpairedNode)
        xmlStr += tagStart + ">";
      else
        xmlStr += tagStart + "/>";
    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
      xmlStr += tagStart + "/>";
    } else if (tagValue && tagValue.endsWith(">")) {
      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
    } else {
      xmlStr += tagStart + ">";
      if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
        xmlStr += indentation + options.indentBy + tagValue + indentation;
      } else {
        xmlStr += tagValue;
      }
      xmlStr += `</${tagName}>`;
    }
    isPreviousElementTag = true;
  }
  return xmlStr;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!obj.hasOwnProperty(key))
      continue;
    if (key !== ":@")
      return key;
  }
}
function attr_to_str(attrMap, options) {
  let attrStr = "";
  if (attrMap && !options.ignoreAttributes) {
    for (let attr in attrMap) {
      if (!attrMap.hasOwnProperty(attr))
        continue;
      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
      attrVal = replaceEntitiesValue(attrVal, options);
      if (attrVal === true && options.suppressBooleanAttributes) {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
      } else {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
      }
    }
  }
  return attrStr;
}
function isStopNode(jPath, options) {
  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
  let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
  for (let index in options.stopNodes) {
    if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
      return true;
  }
  return false;
}
function replaceEntitiesValue(textValue, options) {
  if (textValue && textValue.length > 0 && options.processEntities) {
    for (let i = 0; i < options.entities.length; i++) {
      const entity = options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}
var orderedJs2Xml = toXml;
var buildFromOrderedJs = orderedJs2Xml;
var defaultOptions = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function() {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  this.processTextOrObjNode = processTextOrObjNode;
  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = ">\n";
    this.newLine = "\n";
  } else {
    this.indentate = function() {
      return "";
    };
    this.tagEndChar = ">";
    this.newLine = "";
  }
}
Builder.prototype.build = function(jObj) {
  if (this.options.preserveOrder) {
    return buildFromOrderedJs(jObj, this.options);
  } else {
    if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
      jObj = {
        [this.options.arrayNodeName]: jObj
      };
    }
    return this.j2x(jObj, 0).val;
  }
};
Builder.prototype.j2x = function(jObj, level) {
  let attrStr = "";
  let val2 = "";
  for (let key in jObj) {
    if (!Object.prototype.hasOwnProperty.call(jObj, key))
      continue;
    if (typeof jObj[key] === "undefined") {
      if (this.isAttribute(key)) {
        val2 += "";
      }
    } else if (jObj[key] === null) {
      if (this.isAttribute(key)) {
        val2 += "";
      } else if (key[0] === "?") {
        val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
      } else {
        val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
      }
    } else if (jObj[key] instanceof Date) {
      val2 += this.buildTextValNode(jObj[key], key, "", level);
    } else if (typeof jObj[key] !== "object") {
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
      } else {
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
          val2 += this.replaceEntitiesValue(newval);
        } else {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j2 = 0; j2 < arrLen; j2++) {
        const item = jObj[key][j2];
        if (typeof item === "undefined")
          ;
        else if (item === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (typeof item === "object") {
          if (this.options.oneListGroup) {
            const result = this.j2x(item, level + 1);
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr;
            }
          } else {
            listTagVal += this.processTextOrObjNode(item, key, level);
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
      }
      if (this.options.oneListGroup) {
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val2 += listTagVal;
    } else {
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks2 = Object.keys(jObj[key]);
        const L = Ks2.length;
        for (let j2 = 0; j2 < L; j2++) {
          attrStr += this.buildAttrPairStr(Ks2[j2], "" + jObj[key][Ks2[j2]]);
        }
      } else {
        val2 += this.processTextOrObjNode(jObj[key], key, level);
      }
    }
  }
  return { attrStr, val: val2 };
};
Builder.prototype.buildAttrPairStr = function(attrName, val2) {
  val2 = this.options.attributeValueProcessor(attrName, "" + val2);
  val2 = this.replaceEntitiesValue(val2);
  if (this.options.suppressBooleanAttributes && val2 === "true") {
    return " " + attrName;
  } else
    return " " + attrName + '="' + val2 + '"';
};
function processTextOrObjNode(object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}
Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
  if (val2 === "") {
    if (key[0] === "?")
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    else {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  } else {
    let tagEndExp = "</" + key + this.tagEndChar;
    let piClosingChar = "";
    if (key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
    if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
    }
  }
};
Builder.prototype.closeTag = function(key) {
  let closeTag = "";
  if (this.options.unpairedTags.indexOf(key) !== -1) {
    if (!this.options.suppressUnpairedNode)
      closeTag = "/";
  } else if (this.options.suppressEmptyNode) {
    closeTag = "/";
  } else {
    closeTag = `></${key}`;
  }
  return closeTag;
};
Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val2}-->` + this.newLine;
  } else if (key[0] === "?") {
    return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
  } else {
    let textValue = this.options.tagValueProcessor(key, val2);
    textValue = this.replaceEntitiesValue(textValue);
    if (textValue === "") {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    } else {
      return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
    }
  }
};
Builder.prototype.replaceEntitiesValue = function(textValue) {
  if (textValue && textValue.length > 0 && this.options.processEntities) {
    for (let i = 0; i < this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};
function indentate(level) {
  return this.options.indentBy.repeat(level);
}
function isAttribute(name) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}
var json2xml = Builder;
var validator = validator$2;
var XMLParser2 = XMLParser_1;
var XMLBuilder = json2xml;
var fxp = {
  XMLParser: XMLParser2,
  XMLValidator: validator,
  XMLBuilder
};
var Comment = class {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(components, text) {
    __publicField(this, "date", /* @__PURE__ */ new Date());
    __publicField(this, "author");
    __publicField(this, "guid", UUID.create());
    __publicField(this, "viewpoint");
    __publicField(this, "modifiedAuthor");
    __publicField(this, "modifiedDate");
    __publicField(this, "topic");
    __publicField(this, "_components");
    __publicField(this, "_comment", "");
    this._components = components;
    this._comment = text;
    const manager = this._components.get(BCFTopics);
    this.author = manager.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(value) {
    var _a22;
    const manager = this._components.get(BCFTopics);
    this._comment = value;
    this.modifiedDate = /* @__PURE__ */ new Date();
    this.modifiedAuthor = manager.config.author;
    (_a22 = this.topic) == null ? void 0 : _a22.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  /**
   * Serializes the Comment instance into a BCF compliant XML string.
   *
   * @returns A string representing the Comment in BCFv2 XML format.
   */
  serialize() {
    let viewpointTag = null;
    if (this.viewpoint) {
      viewpointTag = `<Viewpoint Guid="${this.viewpoint.guid}"/>`;
    }
    let modifiedDateTag = null;
    if (this.modifiedDate) {
      modifiedDateTag = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`;
    }
    let modifiedAuthorTag = null;
    if (this.modifiedAuthor) {
      modifiedAuthorTag = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`;
    }
    return `
      <Comment Guid="${this.guid}">
        <Date>${this.date.toISOString()}</Date>
        <Author>${this.author}</Author>
        <Comment>${this.comment}</Comment>
        ${viewpointTag ?? ""}
        ${modifiedAuthorTag ?? ""}
        ${modifiedDateTag ?? ""}
      </Comment>
    `;
  }
};
var _Topic = class _Topic2 {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(components) {
    __publicField(this, "guid", UUID.create());
    __publicField(this, "title", _Topic2.default.title);
    __publicField(this, "creationDate", /* @__PURE__ */ new Date());
    __publicField(this, "creationAuthor", "");
    __publicField(this, "viewpoints", new DataSet());
    __publicField(this, "relatedTopics", new DataSet());
    __publicField(this, "comments", new DataMap());
    __publicField(this, "customData", {});
    __publicField(this, "description");
    __publicField(this, "serverAssignedId");
    __publicField(this, "dueDate");
    __publicField(this, "modifiedAuthor");
    __publicField(this, "modifiedDate");
    __publicField(this, "index");
    __publicField(this, "_type", _Topic2.default.type);
    __publicField(this, "_status", _Topic2.default.status);
    __publicField(this, "_priority", _Topic2.default.priority);
    __publicField(this, "_stage", _Topic2.default.stage);
    __publicField(this, "_assignedTo", _Topic2.default.assignedTo);
    __publicField(this, "_labels", _Topic2.default.labels ?? /* @__PURE__ */ new Set());
    __publicField(this, "_components");
    this._components = components;
    const manager = components.get(BCFTopics);
    this.creationAuthor = manager.config.author;
    this.relatedTopics.guard = (guid) => guid !== this.guid;
  }
  set type(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, types } = manager.config;
    const valid = strict ? types.has(value) : true;
    if (!valid)
      return;
    this._type = value;
  }
  get type() {
    return this._type;
  }
  set status(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, statuses } = manager.config;
    const valid = strict ? statuses.has(value) : true;
    if (!valid)
      return;
    this._status = value;
  }
  get status() {
    return this._status;
  }
  set priority(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, priorities } = manager.config;
      const valid = strict ? priorities.has(value) : true;
      if (!valid)
        return;
      this._priority = value;
    } else {
      this._priority = value;
    }
  }
  get priority() {
    return this._priority;
  }
  set stage(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, stages } = manager.config;
      const valid = strict ? stages.has(value) : true;
      if (!valid)
        return;
      this._stage = value;
    } else {
      this._stage = value;
    }
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, users } = manager.config;
      const valid = strict ? users.has(value) : true;
      if (!valid)
        return;
      this._assignedTo = value;
    } else {
      this._assignedTo = value;
    }
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, labels } = manager.config;
    if (strict) {
      const _value = /* @__PURE__ */ new Set();
      for (const label of value) {
        const valid = strict ? labels.has(label) : true;
        if (!valid)
          continue;
        _value.add(label);
      }
      this._labels = _value;
    } else {
      this._labels = value;
    }
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "guid")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this._components.get(BCFTopics);
    manager.list.set(this.guid, this);
    return this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(text, viewpoint) {
    const comment = new Comment(this._components, text);
    comment.viewpoint = viewpoint;
    comment.topic = this;
    this.comments.set(comment.guid, comment);
    return comment;
  }
  createLabelTags(version = this._managerVersion) {
    let tag = "Labels";
    if (version === "2.1")
      tag = "Labels";
    if (version === "3")
      tag = "Label";
    let tags = [...this.labels].map((label) => `<${tag}>${label}</${tag}>`).join("\n");
    for (const key in this.customData) {
      const value = this.customData[key];
      if (typeof value !== "string")
        continue;
      tags += `
<${tag}>${value}</${tag}>`;
    }
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Labels>
${tags}
</Labels>`;
      return "<Labels/>";
    }
    return tags;
  }
  createCommentTags(version = this._managerVersion) {
    const tags = [...this.comments.values()].map((comment) => comment.serialize()).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Comments>
${tags}
</Comments>`;
      return "<Comments/>";
    }
    return tags;
  }
  createViewpointTags(version = this._managerVersion) {
    let tag = "Viewpoints";
    if (version === "2.1")
      tag = "Viewpoints";
    if (version === "3")
      tag = "ViewPoint";
    const manager = this._components.get(Viewpoints);
    const viewpoints = [...this.viewpoints].map((viewpointID) => manager.list.get(viewpointID)).filter((viewpoint) => viewpoint);
    const tags = viewpoints.map((viewpoint) => {
      return `<${tag} Guid="${viewpoint.guid}">
          <Viewpoint>${viewpoint.guid}.bcfv</Viewpoint>
          <Snapshot>${viewpoint.guid}.jpeg</Snapshot>
        </${tag}>
      `;
    }).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Viewpoints>
${tags}
</Viewpoints>`;
      return "<Viewpoints />";
    }
    return tags;
  }
  createRelatedTopicTags(version = this._managerVersion) {
    const tags = [...this.relatedTopics].map(
      (guid) => `<RelatedTopic Guid="${guid}"></RelatedTopic>
      `
    ).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<RelatedTopics>
${tags}
</RelatedTopics>`;
      return "<RelatedTopics />";
    }
    return tags;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    const version = this._managerVersion;
    let serverAssignedIdAttribute = null;
    if (this.serverAssignedId) {
      serverAssignedIdAttribute = `ServerAssignedId="${this.serverAssignedId}"`;
    }
    let priorityTag = null;
    if (this.priority) {
      priorityTag = `<Priority>${this.priority}</Priority>`;
    }
    let indexTag = null;
    if (this.index && version === "2.1") {
      indexTag = `<Index>${this.index}</Index>`;
    }
    let modifiedDateTag = null;
    if (this.modifiedDate) {
      modifiedDateTag = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`;
    }
    let modifiedAuthorTag = null;
    if (this.modifiedAuthor) {
      modifiedAuthorTag = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`;
    }
    let dueDateTag = null;
    if (this.dueDate) {
      dueDateTag = `<DueDate>${this.dueDate.toISOString()}</DueDate>`;
    }
    let assignedToTag = null;
    if (this.assignedTo) {
      assignedToTag = `<AssignedTo>${this.assignedTo}</AssignedTo>`;
    }
    let descriptionTag = null;
    if (this.description) {
      descriptionTag = `<Description>${this.description}</Description>`;
    }
    let stageTag = null;
    if (this.stage) {
      stageTag = `<Stage>${this.stage}</Stage>`;
    }
    const commentTags = this.createCommentTags(version);
    const viewpointTags = this.createViewpointTags(version);
    const labelTags = this.createLabelTags(version);
    const relatedTopicTags = this.createRelatedTopicTags(version);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Markup>
        <Topic Guid="${this.guid}" TopicType="${this.type}" TopicStatus="${this.status}" ${serverAssignedIdAttribute ?? ""}>
          <Title>${this.title}</Title>
          <CreationDate>${this.creationDate.toISOString()}</CreationDate>
          <CreationAuthor>${this.creationAuthor}</CreationAuthor>
          ${priorityTag ?? ""}
          ${indexTag ?? ""}
          ${modifiedDateTag ?? ""}
          ${modifiedAuthorTag ?? ""}
          ${dueDateTag ?? ""}
          ${assignedToTag ?? ""}
          ${descriptionTag ?? ""}
          ${stageTag ?? ""}
          ${labelTags}
          ${relatedTopicTags}
          ${version === "3" ? commentTags : ""}
          ${version === "3" ? viewpointTags : ""}
        </Topic>
        ${version === "2.1" ? commentTags : ""}
        ${version === "2.1" ? viewpointTags : ""}
      </Markup>
    `;
  }
};
__publicField(_Topic, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
var Topic = _Topic;
var extensionsImporter = (manager, extensionsXML) => {
  if (extensionsXML.trim() === "")
    return;
  const extensions = BCFTopics.xmlParser.parse(extensionsXML).Extensions;
  if (!extensions)
    return;
  const { Priorities, TopicStatuses, TopicTypes, Users } = extensions;
  if (Priorities && Priorities.Priority) {
    const priorities = Array.isArray(Priorities.Priority) ? Priorities.Priority : [Priorities.Priority];
    for (const priority of priorities) {
      manager.config.priorities.add(priority);
    }
  }
  if (TopicStatuses && TopicStatuses.TopicStatus) {
    const statuses = Array.isArray(TopicStatuses.TopicStatus) ? TopicStatuses.TopicStatus : [TopicStatuses.TopicStatus];
    for (const status of statuses) {
      manager.config.statuses.add(status);
    }
  }
  if (TopicTypes && TopicTypes.TopicType) {
    const types = Array.isArray(TopicTypes.TopicType) ? TopicTypes.TopicType : [TopicTypes.TopicType];
    for (const type of types) {
      manager.config.types.add(type);
    }
  }
  if (Users && Users.User) {
    const users = Array.isArray(Users.User) ? Users.User : [Users.User];
    for (const user of users) {
      manager.config.users.add(user);
    }
  }
};
var BCFTopicsConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: false,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: false
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: false
      },
      strict: {
        type: "Boolean",
        value: false
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: false
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: false,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: false
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(value) {
    this._config.version.value = value;
  }
  get author() {
    return this._config.author.value;
  }
  set author(value) {
    this._config.author.value = value;
  }
  get types() {
    return this._config.types.value;
  }
  set types(value) {
    this._config.types.value = value;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(value) {
    this._config.statuses.value = value;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(value) {
    this._config.priorities.value = value;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(value) {
    this._config.labels.value = value;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(value) {
    this._config.stages.value = value;
  }
  get users() {
    return this._config.users.value;
  }
  set users(value) {
    this._config.users.value = value;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(value) {
    this._config.includeSelectionTag.value = value;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(value) {
    this._config.updateExtensionsOnImport.value = value;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(value) {
    this._config.strict.value = value;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(value) {
    this._config.includeAllExtensionsOnExport.value = value;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(value) {
    this._config.fallbackVersionOnImport.value = value;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(value) {
    this._config.ignoreIncompleteTopicsOnImport.value = value;
  }
};
var _BCFTopics = class _BCFTopics2 extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "enabled", false);
    __publicField(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: false,
      updateExtensionsOnImport: true,
      strict: false,
      includeAllExtensionsOnExport: true,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: false
    });
    __publicField(this, "config", new BCFTopicsConfigManager(
      this,
      this.components,
      "BCF Topics",
      _BCFTopics2.uuid
    ));
    __publicField(this, "list", new DataMap());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "isSetup", false);
    __publicField(this, "onBCFImported", new Event());
    __publicField(this, "onDisposed", new Event());
  }
  setup(config) {
    if (this.isSetup)
      return;
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.version = fullConfig.version;
    this.config.author = fullConfig.author;
    this.config.types = fullConfig.types;
    this.config.statuses = fullConfig.statuses;
    this.config.priorities = fullConfig.priorities;
    this.config.labels = fullConfig.labels;
    this.config.stages = fullConfig.stages;
    this.config.users = fullConfig.users;
    this.config.includeSelectionTag = fullConfig.includeSelectionTag;
    this.config.updateExtensionsOnImport = fullConfig.updateExtensionsOnImport;
    this.config.strict = fullConfig.strict;
    this.config.includeAllExtensionsOnExport = fullConfig.includeAllExtensionsOnExport;
    this.config.fallbackVersionOnImport = fullConfig.fallbackVersionOnImport || "";
    this.config.ignoreIncompleteTopicsOnImport = fullConfig.ignoreIncompleteTopicsOnImport;
    this.isSetup = true;
    this.enabled = true;
    this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(data) {
    const topic = new Topic(this.components);
    if (data) {
      topic.guid = data.guid ?? topic.guid;
      topic.set(data);
    } else {
      this.list.set(topic.guid, topic);
    }
    return topic;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const types = [...this.list].map(([_, topic]) => topic.type);
    return new Set(types);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const statuses = [...this.list].map(([_, topic]) => topic.status);
    return new Set(statuses);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const priorities = [...this.list].map(([_, topic]) => topic.priority).filter((priority) => priority);
    return new Set(priorities);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const stages = [...this.list].map(([_, topic]) => topic.stage).filter((stage) => stage);
    return new Set(stages);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const users = [];
    for (const [_, topic] of this.list) {
      users.push(topic.creationAuthor);
      if (topic.assignedTo)
        users.push(topic.assignedTo);
      if (topic.modifiedAuthor)
        users.push(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        users.push(comment.author);
        if (comment.modifiedAuthor)
          users.push(comment.modifiedAuthor);
      }
    }
    return new Set(users);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const labels = [];
    for (const [_, topic] of this.list)
      labels.push(...topic.labels);
    return new Set(labels);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [_, topic] of this.list) {
      for (const label of topic.labels)
        this.config.labels.add(label);
      this.config.types.add(topic.type);
      if (topic.priority)
        this.config.priorities.add(topic.priority);
      if (topic.stage)
        this.config.stages.add(topic.stage);
      this.config.statuses.add(topic.status);
      this.config.users.add(topic.creationAuthor);
      if (topic.assignedTo)
        this.config.users.add(topic.assignedTo);
      if (topic.modifiedAuthor)
        this.config.users.add(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        this.config.users.add(comment.author);
        if (comment.modifiedAuthor)
          this.config.users.add(comment.modifiedAuthor);
      }
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const viewpoints = this.components.get(Viewpoints);
    for (const [_, topic] of this.list) {
      for (const viewpointID of topic.viewpoints) {
        const exists = viewpoints.list.has(viewpointID);
        if (!exists)
          topic.viewpoints.delete(viewpointID);
      }
    }
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(topics = this.list.values()) {
    const zip = new JSZip();
    zip.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    );
    zip.file("bcf.extensions", this.serializeExtensions());
    const image = await fetch(
      "https://thatopen.github.io/engine_components/resources/favicon.ico"
    );
    const imgBlob = await image.arrayBuffer();
    const viewpoints = this.components.get(Viewpoints);
    for (const topic of topics) {
      const topicFolder = zip.folder(topic.guid);
      topicFolder.file("markup.bcf", topic.serialize());
      for (const viewpointID of topic.viewpoints) {
        const viewpoint = viewpoints.list.get(viewpointID);
        if (!viewpoint)
          continue;
        topicFolder.file(`${viewpointID}.jpeg`, imgBlob, {
          binary: true
        });
        topicFolder.file(`${viewpointID}.bcfv`, await viewpoint.serialize());
      }
    }
    const content = await zip.generateAsync({ type: "blob" });
    return content;
  }
  serializeExtensions() {
    const types = [...this.config.types].map((type) => `<TopicType>${type}</TopicType>`).join("\n");
    const statuses = [...this.config.statuses].map((status) => `<TopicStatus>${status}</TopicStatus>`).join("\n");
    const priorities = [...this.config.priorities].map((priority) => `<Priority>${priority}</Priority>`).join("\n");
    const labels = [...this.config.labels].map((label) => `<TopicLabel>${label}</TopicLabel>`).join("\n");
    const stages = [...this.config.stages].map((stage) => `<Stage>${stage}</Stage>`).join("\n");
    const users = [...this.config.users].map((user) => `<User>${user}</User>`).join("\n");
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${types.length !== 0 ? `<TopicTypes>
${types}
</TopicTypes>` : ""}
        ${statuses.length !== 0 ? `<TopicStatuses>
${statuses}
</TopicStatuses>` : ""}
        ${priorities.length !== 0 ? `<Priorities>
${priorities}
</Priorities>` : ""}
        ${labels.length !== 0 ? `<TopicLabels>
${labels}
</TopicLabels>` : ""}
        ${stages.length !== 0 ? `<Stages>
${stages}
</Stages>` : ""}
        ${users.length !== 0 ? `<Users>
${users}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(markupComment) {
    const {
      Guid,
      Date: CommentDate,
      Author,
      Comment: CommentText,
      Viewpoint: Viewpoint2
    } = markupComment;
    if (!(Guid && CommentDate && Author && Comment))
      return null;
    const viewpoints = this.components.get(Viewpoints);
    const comment = new Comment(this.components, CommentText ?? "");
    comment.guid = Guid;
    comment.date = new Date(CommentDate);
    comment.author = Author;
    comment.viewpoint = (Viewpoint2 == null ? void 0 : Viewpoint2.Guid) ? viewpoints.list.get(Viewpoint2.Guid) : void 0;
    comment.modifiedAuthor = markupComment.ModifiedAuthor;
    comment.modifiedDate = markupComment.ModifiedDate ? new Date(markupComment.ModifiedDate) : void 0;
    return comment;
  }
  getMarkupComments(markup, version) {
    var _a22;
    let data;
    if (version === "2.1")
      data = markup.Comment;
    if (version === "3")
      data = (_a22 = markup.Topic.Comments) == null ? void 0 : _a22.Comment;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    const comments = data.map((comment) => this.processMarkupComment(comment)).filter((comment) => comment);
    const array = Array.isArray(comments) ? comments : [comments];
    return array;
  }
  getMarkupLabels(markup, version) {
    var _a22;
    let data;
    if (version === "2.1")
      data = markup.Topic.Labels;
    if (version === "3")
      data = (_a22 = markup.Topic.Labels) == null ? void 0 : _a22.Label;
    if (!data)
      return [];
    const labels = Array.isArray(data) ? data : [data];
    return labels;
  }
  getMarkupViewpoints(markup, version) {
    var _a22;
    let data;
    if (version === "2.1")
      data = markup.Viewpoints;
    if (version === "3")
      data = (_a22 = markup.Topic.Viewpoints) == null ? void 0 : _a22.ViewPoint;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    return data;
  }
  getMarkupRelatedTopics(markup, version) {
    var _a22;
    let data;
    if (version === "2.1")
      data = markup.Topic.RelatedTopic;
    if (version === "3")
      data = (_a22 = markup.Topic.RelatedTopics) == null ? void 0 : _a22.RelatedTopic;
    if (!data)
      return [];
    const topics = Array.isArray(data) ? data : [data];
    return topics.map((topic) => topic.Guid);
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(data, world) {
    var _a22;
    const {
      fallbackVersionOnImport,
      ignoreIncompleteTopicsOnImport,
      updateExtensionsOnImport
    } = this.config;
    const zip = new JSZip();
    await zip.loadAsync(data);
    const files = Object.values(zip.files);
    let version = fallbackVersionOnImport;
    const versionFile = files.find((file) => file.name.endsWith(".version"));
    if (versionFile) {
      const versionXML = await versionFile.async("string");
      const bcfVersion = _BCFTopics2.xmlParser.parse(versionXML).Version.VersionId;
      version = String(bcfVersion);
    }
    if (!(version && (version === "2.1" || version === "3"))) {
      throw new Error(`BCFTopics: ${version} is not supported.`);
    }
    const extensionsFile = files.find(
      (file) => file.name.endsWith(".extensions")
    );
    if (updateExtensionsOnImport && extensionsFile) {
      const extensionsXML = await extensionsFile.async("string");
      extensionsImporter(this, extensionsXML);
    }
    const createdViewpoints = [];
    const viewpoints = this.components.get(Viewpoints);
    const viewpointFiles = files.filter((file) => file.name.endsWith(".bcfv"));
    for (const viewpointFile of viewpointFiles) {
      const xml = await viewpointFile.async("string");
      const visualizationInfo = _BCFTopics2.xmlParser.parse(xml).VisualizationInfo;
      if (!visualizationInfo) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const bcfViewpoint = {};
      const {
        Guid,
        ClippingPlanes,
        Components: Components2,
        OrthogonalCamera,
        PerspectiveCamera: PerspectiveCamera2
      } = visualizationInfo;
      if (Guid)
        bcfViewpoint.guid = Guid;
      if (Components2) {
        const { Selection, Visibility } = Components2;
        if (Selection && Selection.Component) {
          const components = Array.isArray(Selection.Component) ? Selection.Component : [Selection.Component];
          bcfViewpoint.selectionComponents = components.map((component) => component.IfcGuid).filter((guid) => guid);
        }
        if (Visibility && "DefaultVisibility" in Visibility) {
          bcfViewpoint.defaultVisibility = Visibility.DefaultVisibility;
        }
        if (Visibility && Visibility.Exceptions && "Component" in Visibility.Exceptions) {
          const { Component: Component2 } = Visibility.Exceptions;
          const components = Array.isArray(Component2) ? Component2 : [Component2];
          bcfViewpoint.exceptionComponents = components.map((component) => component.IfcGuid).filter((guid) => guid);
        }
        let ViewSetupHints;
        if (version === "2.1") {
          ViewSetupHints = Components2.ViewSetupHints;
        }
        if (version === "3") {
          ViewSetupHints = (_a22 = Components2.Visibility) == null ? void 0 : _a22.ViewSetupHints;
        }
        if (ViewSetupHints) {
          if ("OpeningsVisible" in ViewSetupHints) {
            bcfViewpoint.openingsVisible = ViewSetupHints.OpeningsVisible;
          }
          if ("SpacesVisible" in ViewSetupHints) {
            bcfViewpoint.spacesVisible = ViewSetupHints.SpacesVisible;
          }
          if ("SpaceBoundariesVisible" in ViewSetupHints) {
            bcfViewpoint.spaceBoundariesVisible = ViewSetupHints.SpaceBoundariesVisible;
          }
        }
      }
      if (OrthogonalCamera || PerspectiveCamera2) {
        const camera = visualizationInfo.PerspectiveCamera ?? visualizationInfo.OrthogonalCamera;
        const { CameraViewPoint, CameraDirection } = camera;
        const position = new Vector3(
          Number(CameraViewPoint.X),
          Number(CameraViewPoint.Z),
          Number(-CameraViewPoint.Y)
        );
        const direction = new Vector3(
          Number(CameraDirection.X),
          Number(CameraDirection.Z),
          Number(-CameraDirection.Y)
        );
        const viewpointCamera = {
          position: { x: position.x, y: position.y, z: position.z },
          direction: { x: direction.x, y: direction.y, z: direction.z },
          aspectRatio: "AspectRatio" in camera ? camera.AspectRatio : 1
          // Temporal simplification
        };
        if ("ViewToWorldScale" in camera) {
          bcfViewpoint.camera = {
            ...viewpointCamera,
            viewToWorldScale: camera.ViewToWorldScale
          };
        }
        if ("FieldOfView" in camera) {
          bcfViewpoint.camera = {
            ...viewpointCamera,
            fov: camera.FieldOfView
          };
        }
      }
      const viewpoint = new Viewpoint(this.components, world, {
        data: bcfViewpoint,
        setCamera: false
      });
      if (Components2) {
        const { Coloring } = Components2;
        if (Coloring && Coloring.Color) {
          const colors = Array.isArray(Coloring.Color) ? Coloring.Color : [Coloring.Color];
          for (const colorData of colors) {
            const { Color: Color2, Component: Component2 } = colorData;
            const components = Array.isArray(Component2) ? Component2 : [Component2];
            const guids = components.map((component) => component.IfcGuid);
            viewpoint.componentColors.set(Color2, guids);
          }
        }
      }
      createdViewpoints.push(viewpoint);
      if (ClippingPlanes) {
        const clipper = this.components.get(Clipper);
        const planes = Array.isArray(ClippingPlanes.ClippingPlane) ? ClippingPlanes.ClippingPlane : [ClippingPlanes.ClippingPlane];
        for (const plane of planes) {
          const { Location, Direction } = plane;
          if (!(Location && Direction))
            continue;
          const location = new Vector3(
            Location.X,
            Location.Z,
            -Location.Y
          );
          const direction = new Vector3(
            Direction.X,
            -Direction.Z,
            Direction.Y
          );
          const clippingPlane = clipper.createFromNormalAndCoplanarPoint(
            world,
            direction,
            location
          );
          clippingPlane.visible = false;
          clippingPlane.enabled = false;
          viewpoint.clippingPlanes.add(clippingPlane);
        }
      }
    }
    const topicRelations = {};
    const topics = [];
    const markupFiles = files.filter((file) => file.name.endsWith(".bcf"));
    for (const markupFile of markupFiles) {
      const xml = await markupFile.async("string");
      const markup = _BCFTopics2.xmlParser.parse(xml).Markup;
      const markupTopic = markup.Topic;
      const {
        Guid,
        TopicType,
        TopicStatus,
        Title,
        CreationDate,
        CreationAuthor
      } = markupTopic;
      if (ignoreIncompleteTopicsOnImport) {
        if (!(Guid && TopicType && TopicStatus && Title && CreationDate && CreationAuthor))
          continue;
      }
      const topic = new Topic(this.components);
      topic.guid = Guid ?? topic.guid;
      const relatedTopics = this.getMarkupRelatedTopics(markup, version);
      topicRelations[topic.guid] = new Set(relatedTopics);
      topic.type = TopicType ?? topic.type;
      topic.status = TopicStatus ?? topic.status;
      topic.title = Title ?? topic.title;
      topic.creationDate = CreationDate ? new Date(CreationDate) : topic.creationDate;
      topic.creationAuthor = CreationAuthor ?? topic.creationAuthor;
      topic.serverAssignedId = markupTopic.ServerAssignedId;
      topic.priority = markupTopic.Priority;
      topic.index = markupTopic.Index;
      topic.modifiedDate = markupTopic.ModifiedDate ? new Date(markupTopic.ModifiedDate) : void 0;
      topic.modifiedAuthor = markupTopic.ModifiedAuthor;
      topic.dueDate = markupTopic.DueDate ? new Date(markupTopic.DueDate) : void 0;
      topic.assignedTo = markupTopic.AssignedTo;
      topic.description = markupTopic.Description;
      topic.stage = markupTopic.Stage;
      const labels = this.getMarkupLabels(markup, version);
      for (const label of labels)
        topic.labels.add(label);
      const comments = this.getMarkupComments(markup, version);
      for (const comment of comments)
        topic.comments.set(comment.guid, comment);
      const markupViewpoints = this.getMarkupViewpoints(markup, version);
      for (const markupViewpoint of markupViewpoints) {
        if (!(markupViewpoint && markupViewpoint.Guid))
          continue;
        const viewpoint = viewpoints.list.get(markupViewpoint.Guid);
        if (viewpoint)
          topic.viewpoints.add(viewpoint.guid);
      }
      this.list.set(topic.guid, topic);
      topics.push(topic);
    }
    for (const topicID in topicRelations) {
      const topic = this.list.get(topicID);
      if (!topic)
        continue;
      const relations = topicRelations[topicID];
      for (const guid of relations) {
        topic.relatedTopics.add(guid);
      }
    }
    this.onBCFImported.trigger(topics);
    return { viewpoints: createdViewpoints, topics };
  }
};
__publicField(_BCFTopics, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
__publicField(_BCFTopics, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var BCFTopics = _BCFTopics;
var _BoundingBoxer = class _BoundingBoxer2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "_absoluteMin");
    __publicField(this, "_absoluteMax");
    __publicField(this, "_meshes", []);
    this.components.add(_BoundingBoxer2.uuid, this);
    this._absoluteMin = _BoundingBoxer2.newBound(true);
    this._absoluteMax = _BoundingBoxer2.newBound(false);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(bbox) {
    const { min, max } = bbox;
    const width = Math.abs(max.x - min.x);
    const height = Math.abs(max.y - min.y);
    const depth = Math.abs(max.z - min.z);
    const center = new Vector3();
    center.subVectors(max, min).divideScalar(2).add(min);
    return { width, height, depth, center };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(positive) {
    const factor = positive ? 1 : -1;
    return new Vector3(
      factor * Number.MAX_VALUE,
      factor * Number.MAX_VALUE,
      factor * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(points, min, max) {
    const maxPoint = max || this.newBound(false);
    const minPoint = min || this.newBound(true);
    for (const point of points) {
      if (point.x < minPoint.x)
        minPoint.x = point.x;
      if (point.y < minPoint.y)
        minPoint.y = point.y;
      if (point.z < minPoint.z)
        minPoint.z = point.z;
      if (point.x > maxPoint.x)
        maxPoint.x = point.x;
      if (point.y > maxPoint.y)
        maxPoint.y = point.y;
      if (point.z > maxPoint.z)
        maxPoint.z = point.z;
    }
    return new Box3(min, max);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const disposer = this.components.get(Disposer);
    for (const mesh of this._meshes) {
      disposer.destroy(mesh);
    }
    this._meshes = [];
    this.onDisposed.trigger(_BoundingBoxer2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const min = this._absoluteMin.clone();
    const max = this._absoluteMax.clone();
    return new Box3(min, max);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const min = this._absoluteMin.clone();
    const max = this._absoluteMax.clone();
    const dx = Math.abs((max.x - min.x) / 2);
    const dy = Math.abs((max.y - min.y) / 2);
    const dz = Math.abs((max.z - min.z) / 2);
    const center = new Vector3(min.x + dx, min.y + dy, min.z + dz);
    const radius = center.distanceTo(min);
    return new Sphere(center, radius);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const bbox = new Box3(this._absoluteMin, this._absoluteMax);
    const dimensions = _BoundingBoxer2.getDimensions(bbox);
    const { width, height, depth, center } = dimensions;
    const box = new BoxGeometry(width, height, depth);
    const mesh = new Mesh(box);
    this._meshes.push(mesh);
    mesh.position.copy(center);
    return mesh;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = _BoundingBoxer2.newBound(true);
    this._absoluteMax = _BoundingBoxer2.newBound(false);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(group) {
    for (const frag of group.items) {
      this.addMesh(frag.mesh);
    }
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(mesh, itemIDs) {
    if (!mesh.geometry.index) {
      return;
    }
    const bbox = _BoundingBoxer2.getFragmentBounds(mesh);
    mesh.updateMatrixWorld();
    const meshTransform = mesh.matrixWorld;
    const instanceTransform = new Matrix4();
    const isInstanced = mesh instanceof InstancedMesh;
    const instances = /* @__PURE__ */ new Set();
    if (mesh instanceof Xn) {
      if (!itemIDs) {
        itemIDs = mesh.fragment.ids;
      }
      for (const itemID of itemIDs) {
        const ids = mesh.fragment.getInstancesIDs(itemID);
        if (!ids)
          continue;
        for (const id of ids) {
          instances.add(id);
        }
      }
    } else {
      instances.add(0);
    }
    for (const instance of instances) {
      const min = bbox.min.clone();
      const max = bbox.max.clone();
      if (isInstanced) {
        mesh.getMatrixAt(instance, instanceTransform);
        min.applyMatrix4(instanceTransform);
        max.applyMatrix4(instanceTransform);
      }
      min.applyMatrix4(meshTransform);
      max.applyMatrix4(meshTransform);
      if (min.x < this._absoluteMin.x)
        this._absoluteMin.x = min.x;
      if (min.y < this._absoluteMin.y)
        this._absoluteMin.y = min.y;
      if (min.z < this._absoluteMin.z)
        this._absoluteMin.z = min.z;
      if (min.x > this._absoluteMax.x)
        this._absoluteMax.x = min.x;
      if (min.y > this._absoluteMax.y)
        this._absoluteMax.y = min.y;
      if (min.z > this._absoluteMax.z)
        this._absoluteMax.z = min.z;
      if (max.x > this._absoluteMax.x)
        this._absoluteMax.x = max.x;
      if (max.y > this._absoluteMax.y)
        this._absoluteMax.y = max.y;
      if (max.z > this._absoluteMax.z)
        this._absoluteMax.z = max.z;
      if (max.x < this._absoluteMin.x)
        this._absoluteMin.x = max.x;
      if (max.y < this._absoluteMin.y)
        this._absoluteMin.y = max.y;
      if (max.z < this._absoluteMin.z)
        this._absoluteMin.z = max.z;
    }
  }
  /**
   * Uses a FragmentIdMap to add its meshes to the bb calculation.
   *
   * This method iterates through the provided `fragmentIdMap`, retrieves the corresponding fragment from the `FragmentsManager`,
   * and then calls the `addMesh` method for each fragment's mesh, passing the expression IDs as the second parameter.
   *
   * @param fragmentIdMap - A mapping of fragment IDs to their corresponding expression IDs.
   *
   * @remarks
   * This method is used to add a mapping of fragment IDs to their corresponding expression IDs.
   * It ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * const fragmentIdMap: FRAGS.FragmentIdMap = {
   *   '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],
   *   '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],
   * };
   * boundingBoxer.addFragmentIdMap(fragmentIdMap);
   * ```
   */
  addFragmentIdMap(fragmentIdMap) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragmentID in fragmentIdMap) {
      const fragment = fragments.list.get(fragmentID);
      if (!fragment)
        continue;
      const expressIDs = fragmentIdMap[fragmentID];
      this.addMesh(fragment.mesh, expressIDs);
    }
  }
  static getFragmentBounds(mesh) {
    const position = mesh.geometry.attributes.position;
    const maxNum = Number.MAX_VALUE;
    const minNum = -maxNum;
    const min = new Vector3(maxNum, maxNum, maxNum);
    const max = new Vector3(minNum, minNum, minNum);
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const indices = Array.from(mesh.geometry.index.array);
    for (let i = 0; i < indices.length; i++) {
      if (i % 3 === 0) {
        if (indices[i] === 0 && indices[i + 1] === 0 && indices[i + 2] === 0) {
          i += 2;
          continue;
        }
      }
      const index = indices[i];
      const x = position.getX(index);
      const y = position.getY(index);
      const z2 = position.getZ(index);
      if (x < min.x)
        min.x = x;
      if (y < min.y)
        min.y = y;
      if (z2 < min.z)
        min.z = z2;
      if (x > max.x)
        max.x = x;
      if (y > max.y)
        max.y = y;
      if (z2 > max.z)
        max.z = z2;
    }
    return new Box3(min, max);
  }
};
__publicField(_BoundingBoxer, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var BoundingBoxer = _BoundingBoxer;
var _IfcIsolator = class _IfcIsolator2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    components.add(_IfcIsolator2.uuid, this);
  }
  async getIsolatedElements(webIfc, modelID, elementIDs) {
    const isolatedElementIDs = /* @__PURE__ */ new Set();
    function addElementAndReferences(elementID) {
      if (isolatedElementIDs.has(elementID))
        return;
      const element = webIfc.GetLine(modelID, elementID);
      if (!element)
        return;
      isolatedElementIDs.add(elementID);
      for (const prop in element) {
        const value = element[prop];
        if (value && value.constructor.name === "Handle" && value.value > 0) {
          addElementAndReferences(value.value);
        } else if (Array.isArray(value)) {
          value.forEach((refID) => {
            if (refID && refID.constructor.name === "Handle" && refID.value > 0) {
              addElementAndReferences(refID.value);
            }
          });
        }
      }
    }
    for (const elementID of elementIDs) {
      addElementAndReferences(elementID);
    }
    const arr = [];
    for (const elementID of isolatedElementIDs) {
      arr.push(elementID);
    }
    arr.sort((a, b) => {
      return a - b;
    });
    const isolatedElements = [];
    arr.forEach((elementID) => {
      const element = webIfc.GetLine(modelID, elementID);
      isolatedElements.push(element);
    });
    return isolatedElements;
  }
  /**
   * Exports isolated elements to the new model.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the new IFC model.
   * @param isolatedElements The array of isolated elements
   */
  async export(webIfc, modelID, isolatedElements) {
    isolatedElements.forEach((element) => {
      webIfc.WriteLine(modelID, element);
    });
    const data = webIfc.SaveModel(modelID);
    return data;
  }
  async splitIfc(webIfc, ifcFile, idsToExtract) {
    const ifcBuffer = new Uint8Array(ifcFile);
    const modelID = webIfc.OpenModel(ifcBuffer);
    const isolated = await this.getIsolatedElements(
      webIfc,
      modelID,
      idsToExtract
    );
    const newModelID = webIfc.CreateModel({ schema: Schemas.IFC2X3 });
    const data = await this.export(webIfc, newModelID, isolated);
    return data;
  }
};
__publicField(_IfcIsolator, "uuid", "6eb0ba2f-71c0-464e-bcec-2d7c335186b2");
var IfcIsolator = _IfcIsolator;
var _IfcFinderQuery = class _IfcFinderQuery2 {
  constructor(components) {
    __publicField(this, "onProgress", new Event());
    __publicField(this, "inclusive", false);
    __publicField(this, "rules", []);
    __publicField(this, "ids", {});
    __publicField(this, "needsUpdate", /* @__PURE__ */ new Map());
    __publicField(this, "components");
    this.components = components;
  }
  /**
   * Imports a query given its data. This data can be generating using its {@link IfcFinderQuery.export} method.
   *
   * @param components the instance of {@link Components} used by this app.
   * @param data the data of the query to import as a serializable object.
   */
  static import(components, data) {
    const newQuery = _IfcFinderQuery2.importers.get(data.type);
    if (!newQuery) {
      console.warn(`Invalid query data:.`, data);
      return null;
    }
    return newQuery(components, data);
  }
  /**
   * Imports the given serialized rules. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param serializedRules the rules to be parsed.
   */
  static importRules(serializedRules) {
    const rules = [];
    for (const serializedRule of serializedRules) {
      const rule = {};
      for (const id in serializedRule) {
        const item = serializedRule[id];
        if (item.regexp) {
          rule[id] = new RegExp(item.value);
        } else {
          rule[id] = item;
        }
      }
      rules.push(rule);
    }
    return rules;
  }
  /**
   * Imports the given IDs. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param data the serialized object representing the query whose IDs to parse.
   */
  static importIds(data) {
    const ids = {};
    for (const modelID in data.ids) {
      ids[modelID] = new Set(data.ids[modelID]);
    }
    return ids;
  }
  /**
   * Clears the data of the given model. If not specified, clears all the data.
   *
   * @param modelID ID of the model whose data to clear.
   */
  clear(modelID) {
    if (modelID === void 0) {
      this.ids = {};
      this.needsUpdate.clear();
      return;
    }
    delete this.ids[modelID];
    this.needsUpdate.delete(modelID);
  }
  addID(modelID, id) {
    if (!this.ids[modelID]) {
      this.ids[modelID] = /* @__PURE__ */ new Set();
    }
    this.ids[modelID].add(id);
  }
  getData() {
    const ids = {};
    for (const modelID in this.ids) {
      ids[modelID] = Array.from(this.ids[modelID]);
    }
    const rules = this.exportRules();
    return {
      name: this.name,
      inclusive: this.inclusive,
      type: "IfcFinderQuery",
      ids,
      rules
    };
  }
  exportRules() {
    const rules = [];
    for (const rule of this.rules) {
      const serializedRule = {};
      for (const id in rule) {
        const item = rule[id];
        if (item instanceof RegExp) {
          serializedRule[id] = { regexp: true, value: item.source };
        } else {
          serializedRule[id] = item;
        }
      }
      rules.push(serializedRule);
    }
    return rules;
  }
  findInFile(modelID, file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      const decoder = new TextDecoder("utf-8");
      const chunkSize = 1e4 * 1024;
      const offset = 1e3;
      let start = 0;
      const endLineToken = /;/;
      const readTextPart = () => {
        if (start >= file.size) {
          resolve();
          return;
        }
        const end = Math.min(start + chunkSize + offset, file.size);
        const slice = file.slice(start, end);
        reader.readAsArrayBuffer(slice);
      };
      reader.onload = () => {
        if (!(reader.result instanceof ArrayBuffer)) {
          return;
        }
        const buffer = new Uint8Array(reader.result);
        const snippet = decoder.decode(buffer);
        const lines = snippet.split(endLineToken);
        lines.shift();
        this.findInLines(modelID, lines);
        this.onProgress.trigger(start / file.size);
        start += chunkSize;
        readTextPart();
      };
      readTextPart();
    });
  }
  getIdFromLine(line) {
    const idString = line.slice(line.indexOf("#") + 1, line.indexOf("="));
    return parseInt(idString, 10);
  }
  testRules(line) {
    let category = null;
    let attrValues = null;
    let attrNames = null;
    let filtersPass = false;
    for (const rule of this.rules) {
      if (rule.type === "category") {
        if (category === null) {
          category = this.getCategoryFromLine(line);
          if (category === null) {
            if (!this.inclusive) {
              break;
            } else {
              continue;
            }
          }
        }
        if (!rule.value.test(category)) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
        filtersPass = true;
        continue;
      }
      if (attrValues === null) {
        attrValues = this.getAttributesFromLine(line);
        if (attrValues === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (category === null) {
        category = this.getCategoryFromLine(line);
        if (category === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (attrNames === null) {
        attrNames = Object.keys(new IFC4[category]());
        attrNames = attrNames.slice(2);
        if (attrNames === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (rule.type === "property") {
        const { name, value } = rule;
        if (!value.test(line)) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
        let someNameValueMatch = false;
        for (let i = 0; i < attrValues.length; i++) {
          const attrValue = attrValues[i];
          const attrName = attrNames[i];
          if (value.test(attrValue) && name.test(attrName)) {
            someNameValueMatch = true;
            break;
          }
        }
        if (!someNameValueMatch) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          }
        } else {
          filtersPass = true;
        }
      }
      if (rule.type === "operator") {
        const { name, value, operator } = rule;
        let someNameValueMatch = false;
        for (let i = 0; i < attrValues.length; i++) {
          const attrName = attrNames[i];
          const attrValue = attrValues[i].replace(
            /IFCLENGTHMEASURE\(|IFCVOLUMEMEASURE\(|\)/g,
            ""
          );
          if (name.test(attrName)) {
            if (operator === "=" && parseFloat(attrValue) === value) {
              someNameValueMatch = true;
              break;
            } else if (operator === "<" && parseFloat(attrValue) < value) {
              someNameValueMatch = true;
              break;
            } else if (operator === ">" && parseFloat(attrValue) > value) {
              someNameValueMatch = true;
              break;
            } else if (operator === ">=" && parseFloat(attrValue) >= value) {
              someNameValueMatch = true;
              break;
            } else if (operator === "<=" && parseFloat(attrValue) <= value) {
              someNameValueMatch = true;
              break;
            }
          }
        }
        if (!someNameValueMatch) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          }
        } else {
          filtersPass = true;
        }
      }
    }
    return filtersPass;
  }
  getCategoryFromLine(line) {
    const start = line.indexOf("=") + 1;
    const end = line.indexOf("(");
    const category = line.slice(start, end).trim();
    const name = ifcCategoryCase[category];
    if (!name) {
      return null;
    }
    return name;
  }
  getAttributesFromLine(line) {
    const matchRegex = /\((.*)\)/;
    const match = line.match(matchRegex);
    if (!(match && match[1])) {
      return null;
    }
    const splitRegex = /,(?![^()]*\))/g;
    const attrs = match[1].split(splitRegex).map((part) => part.trim());
    return attrs;
  }
};
__publicField(_IfcFinderQuery, "importers", /* @__PURE__ */ new Map());
var IfcFinderQuery = _IfcFinderQuery;
var IfcQueryGroup = class {
  constructor(components) {
    __publicField(this, "list", /* @__PURE__ */ new Map());
    __publicField(this, "id", MathUtils.generateUUID());
    __publicField(this, "mode", "intersect");
    __publicField(this, "_components");
    this._components = components;
  }
  /**
   * The list of unique queries contained in this group.
   */
  get queries() {
    return new Set(this.list.values());
  }
  /**
   * The items of all the queries contained in this group. The returned data depends on {@link IfcQueryGroup.mode}.
   */
  get items() {
    const maps = [];
    for (const query of this.queries) {
      maps.push(query.items);
    }
    if (this.mode === "combine") {
      return jc.combine(maps);
    }
    return jc.intersect(maps);
  }
  /**
   * Adds a new query to this group.
   * @param query the query to add.
   */
  add(query) {
    if (this.list.has(query.name)) {
      throw new Error(
        `This group already has a query with the name ${query.name}.`
      );
    }
    this.list.set(query.name, query);
  }
  /**
   * Clears the data of the given modelID of all queries contained in this group. If no modelID is provided, clears all data.
   * @param modelID the model whose data to remove.
   */
  clear(modelID) {
    for (const query of this.queries) {
      query.clear(modelID);
    }
  }
  /**
   * Imports data that has been previously exported through {@link IfcQueryGroup.export}.
   * @param data the serializable object used to persist a group's data.
   */
  import(data) {
    this.mode = data.mode;
    this.id = data.id;
    for (const id in data.queries) {
      const query = IfcFinderQuery.import(this._components, data.queries[id]);
      if (query) {
        this.list.set(id, query);
      }
    }
  }
  /**
   * Exports all the data of this group, so that it can be persisted and imported later using {@link IfcQueryGroup.import}.
   */
  export() {
    const queries = {};
    for (const [id, query] of this.list) {
      queries[id] = query.export();
    }
    return {
      mode: this.mode,
      id: this.id,
      queries
    };
  }
  /**
   * Updates all the queries contained in this group that need an update for the given file. It will skip those where {@link IfcFinderQuery.needsUpdate} is false.
   * @param modelID the identifier used to refer to the given file.
   * @param file the file to process.
   */
  async update(modelID, file) {
    for (const query of this.queries) {
      const needsUpdate = query.needsUpdate.get(modelID);
      if (needsUpdate === void 0 || needsUpdate) {
        await query.update(modelID, file);
      }
    }
  }
};
var _IfcBasicQuery = class _IfcBasicQuery2 extends IfcFinderQuery {
  constructor(components, data) {
    super(components);
    __publicField(this, "name");
    this.name = data.name;
    this.rules = data.rules;
    this.inclusive = data.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const fragments = this.components.get(FragmentsManager);
    const maps = [];
    for (const modelID in this.ids) {
      const ids = this.ids[modelID];
      const found = fragments.groups.get(modelID);
      if (!found) {
        console.warn(`Model ${modelID} not found!`);
        continue;
      }
      const map = found.getFragmentMap(ids);
      maps.push(map);
    }
    return jc.combine(maps);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const data = this.getData();
    data.type = _IfcBasicQuery2.type;
    return data;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(modelID, file) {
    this.ids[modelID] = /* @__PURE__ */ new Set();
    await this.findInFile(modelID, file);
    this.needsUpdate.set(modelID, false);
  }
  findInLines(modelID, lines) {
    for (const line of lines) {
      const filtersPass = this.testRules(line);
      if (filtersPass) {
        const id = this.getIdFromLine(line);
        this.addID(modelID, id);
      }
    }
  }
};
__publicField(_IfcBasicQuery, "type", "IfcBasicQuery");
var IfcBasicQuery = _IfcBasicQuery;
IfcFinderQuery.importers.set(
  IfcBasicQuery.type,
  (components, data) => {
    const query = new IfcBasicQuery(components, {
      name: data.name,
      rules: IfcFinderQuery.importRules(data.rules),
      inclusive: data.inclusive
    });
    query.ids = IfcFinderQuery.importIds(data);
    return query;
  }
);
var _IfcPropertyQuery = class _IfcPropertyQuery2 extends IfcFinderQuery {
  constructor(components, data) {
    super(components);
    __publicField(this, "name");
    __publicField(this, "psets", []);
    this.name = data.name;
    this.rules = data.rules;
    this.inclusive = data.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const indexer = this.components.get(IfcRelationsIndexer);
    const fragments = this.components.get(FragmentsManager);
    const maps = [];
    for (const modelID in this.ids) {
      const model = fragments.groups.get(modelID);
      if (!model) {
        console.log(`Model not found: ${modelID}.`);
        continue;
      }
      const ids = this.ids[modelID];
      for (const id of ids) {
        const elements = indexer.getEntityRelations(
          modelID,
          id,
          "DefinesOcurrence"
        );
        if (elements) {
          const map = model.getFragmentMap(elements);
          maps.push(map);
        }
      }
    }
    return jc.combine(maps);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const data = this.getData();
    data.type = _IfcPropertyQuery2.type;
    return data;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(modelID, file) {
    await this.findInFile(modelID, file);
    const psetIDs = /* @__PURE__ */ new Set();
    for (const pset of this.psets) {
      const attrs = this.getAttributesFromLine(pset);
      if (attrs === null) {
        continue;
      }
      const idsString = attrs[4].replace("(", "[").replace(")", "]").replace(/#/g, "");
      const containedPropertySingleValues = JSON.parse(idsString);
      for (const id of containedPropertySingleValues) {
        const ids = this.ids[modelID];
        if (ids && ids.has(id)) {
          const psetID = this.getIdFromLine(pset);
          psetIDs.add(psetID);
          break;
        }
      }
    }
    this.ids[modelID] = psetIDs;
    this.psets = [];
    this.needsUpdate.set(modelID, false);
  }
  findInLines(modelID, lines) {
    for (const line of lines) {
      const category = this.getCategoryFromLine(line);
      if (category === "IfcPropertySet") {
        this.psets.push(line);
        continue;
      }
      if (category !== "IfcPropertySingleValue") {
        continue;
      }
      const filtersPass = this.testRules(line);
      if (filtersPass) {
        const id = this.getIdFromLine(line);
        this.addID(modelID, id);
      }
    }
  }
};
__publicField(_IfcPropertyQuery, "type", "IfcPropertyQuery");
var IfcPropertyQuery = _IfcPropertyQuery;
IfcFinderQuery.importers.set(
  IfcPropertyQuery.type,
  (components, data) => {
    const query = new IfcPropertyQuery(components, {
      name: data.name,
      inclusive: data.inclusive,
      rules: IfcFinderQuery.importRules(data.rules)
    });
    query.ids = IfcFinderQuery.importIds(data);
    return query;
  }
);
var _IfcFinder = class _IfcFinder2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "list", /* @__PURE__ */ new Map());
    components.add(_IfcFinder2.uuid, this);
  }
  /**
   * List of all queries from all created {@link IfcQueryGroup} instances.
   */
  get queries() {
    const queries = /* @__PURE__ */ new Set();
    for (const [, group] of this.list) {
      for (const query of group.queries) {
        queries.add(query);
      }
    }
    return queries;
  }
  /**
   * Imports all the query groups provided in the given data. You can generate this data to save the result of queries and persist it over time.
   * @param data The data containing the serialized query groups to import.
   */
  import(data) {
    for (const id in data) {
      const group = new IfcQueryGroup(this.components);
      group.import(data[id]);
      this.list.set(id, group);
    }
  }
  /**
   * Exports all the query groups created. You can then import this data back using the import method.
   */
  export() {
    const result = {};
    for (const [id, group] of this.list) {
      result[id] = group.export();
    }
    return result;
  }
  /**
   * Creates a new {@link IfcQueryGroup}.
   */
  create() {
    const group = new IfcQueryGroup(this.components);
    this.list.set(group.id, group);
    return group;
  }
  /**
   * Creates the {@link IfcQueryGroup} with the given ID.
   */
  delete(id) {
    this.list.delete(id);
  }
  /**
   * Deletes all {@link IfcQueryGroup} instances.
   */
  clear() {
    this.list.clear();
  }
};
__publicField(_IfcFinder, "uuid", "0da7ad77-f734-42ca-942f-a074adfd1e3a");
var IfcFinder = _IfcFinder;
var _Classifier = class _Classifier2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "list", {});
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onFragmentsDisposed", (data) => {
      const { groupID, fragmentIDs } = data;
      for (const systemName in this.list) {
        const system = this.list[systemName];
        const groupNames = Object.keys(system);
        if (groupNames.includes(groupID)) {
          delete system[groupID];
          if (Object.values(system).length === 0) {
            delete this.list[systemName];
          }
        } else {
          for (const groupName of groupNames) {
            const group = system[groupName];
            for (const fragmentID of fragmentIDs) {
              delete group.map[fragmentID];
            }
            if (Object.values(group).length === 0) {
              delete system[groupName];
            }
          }
        }
      }
    });
    components.add(_Classifier2.uuid, this);
    const fragmentManager = components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {};
    const fragmentManager = this.components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.remove(this.onFragmentsDisposed);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(guid) {
    for (const systemName in this.list) {
      const system = this.list[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        delete group.map[guid];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(filter) {
    const fragments = this.components.get(FragmentsManager);
    if (!filter) {
      const result2 = {};
      for (const [id, fragment] of fragments.list) {
        result2[id] = new Set(fragment.ids);
      }
      return result2;
    }
    const filterCount = Object.keys(filter).length;
    const models = {};
    for (const name in filter) {
      const values = filter[name];
      if (!this.list[name]) {
        console.warn(`Classification ${name} does not exist.`);
        continue;
      }
      for (const value of values) {
        const found = this.list[name][value];
        if (found) {
          for (const guid in found.map) {
            if (!models[guid]) {
              models[guid] = /* @__PURE__ */ new Map();
            }
            for (const id of found.map[guid]) {
              const matchCount = models[guid].get(id);
              if (matchCount === void 0) {
                models[guid].set(id, 1);
              } else {
                models[guid].set(id, matchCount + 1);
              }
            }
          }
        }
      }
    }
    const result = {};
    for (const guid in models) {
      const model = models[guid];
      for (const [id, numberOfMatches] of model) {
        if (numberOfMatches === void 0) {
          throw new Error("Malformed fragments map!");
        }
        if (numberOfMatches === filterCount) {
          if (!result[guid]) {
            result[guid] = /* @__PURE__ */ new Set();
          }
          result[guid].add(id);
        }
      }
    }
    return result;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(modelID, group) {
    if (!this.list.models) {
      this.list.models = {};
    }
    const modelsClassification = this.list.models;
    if (!modelsClassification[modelID]) {
      modelsClassification[modelID] = { map: {}, id: null, name: modelID };
    }
    const currentModel = modelsClassification[modelID];
    for (const [expressID, data] of group.data) {
      const keys = data[0];
      for (const key of keys) {
        const fragID = group.keyFragments.get(key);
        if (!fragID)
          continue;
        if (!currentModel.map[fragID]) {
          currentModel.map[fragID] = /* @__PURE__ */ new Set();
        }
        currentModel.map[fragID].add(expressID);
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(group) {
    var _a22;
    if (!this.list.predefinedTypes) {
      this.list.predefinedTypes = {};
    }
    const currentTypes = this.list.predefinedTypes;
    const ids = group.getAllPropertiesIDs();
    for (const id of ids) {
      const entity = await group.getProperties(id);
      if (!entity)
        continue;
      const predefinedType = String((_a22 = entity.PredefinedType) == null ? void 0 : _a22.value).toUpperCase();
      if (!currentTypes[predefinedType]) {
        currentTypes[predefinedType] = {
          map: {},
          id: null,
          name: predefinedType
        };
      }
      const currentType = currentTypes[predefinedType];
      for (const [_expressID, data] of group.data) {
        const keys = data[0];
        for (const key of keys) {
          const fragmentID = group.keyFragments.get(key);
          if (!fragmentID) {
            throw new Error("Fragment ID not found!");
          }
          if (!currentType.map[fragmentID]) {
            currentType.map[fragmentID] = /* @__PURE__ */ new Set();
          }
          const currentFragment = currentType.map[fragmentID];
          currentFragment.add(entity.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(group) {
    if (!this.list.entities) {
      this.list.entities = {};
    }
    for (const [expressID, data] of group.data) {
      const rels = data[1];
      const type = rels[1];
      const entity = IfcCategoryMap[type];
      this.saveItem(group, "entities", entity, expressID);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(group, ifcRel, systemName) {
    if (!IfcPropertiesUtils.isRel(ifcRel))
      return;
    await IfcPropertiesUtils.getRelationMap(
      group,
      ifcRel,
      async (relatingID, relatedIDs) => {
        const { name: relatingName } = await IfcPropertiesUtils.getEntityName(
          group,
          relatingID
        );
        for (const expressID of relatedIDs) {
          this.saveItem(
            group,
            systemName,
            relatingName ?? "NO REL NAME",
            expressID
          );
        }
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   * @param config - The configuration for the classifier. It includes "useProperties", which is true by default
   * (if false, the classification will use the expressIDs instead of the names), and "isolate", which will make
   * the classifier just pick the WEBIFC categories provided.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(model, config = {}) {
    var _a22, _b;
    const indexer = this.components.get(IfcRelationsIndexer);
    const modelRelations = indexer.relationMaps[model.uuid];
    if (!modelRelations) {
      throw new Error(
        `Classifier: model relations of ${model.name || model.uuid} have to exists to group by spatial structure.`
      );
    }
    const systemName = config.systemName ?? "spatialStructures";
    const noProps = config.useProperties === void 0;
    const useProperties = noProps || config.useProperties;
    for (const [expressID] of modelRelations) {
      if (config.isolate) {
        const data = model.data.get(expressID);
        if (!data)
          continue;
        const category = data[1][1];
        if (category === void 0 || !config.isolate.has(category)) {
          continue;
        }
      }
      const spatialRels = indexer.getEntityRelations(
        model,
        expressID,
        "Decomposes"
      );
      if (spatialRels) {
        for (const id of spatialRels) {
          let relName2 = id.toString();
          if (useProperties) {
            const spatialRelAttrs = await model.getProperties(id);
            if (!spatialRelAttrs) {
              continue;
            }
            relName2 = (_a22 = spatialRelAttrs.Name) == null ? void 0 : _a22.value;
          }
          this.saveItem(model, systemName, relName2, expressID, id);
        }
      }
      const rels = indexer.getEntityRelations(
        model,
        expressID,
        "ContainsElements"
      );
      if (!rels) {
        continue;
      }
      let relName = expressID.toString();
      if (useProperties) {
        const relAttrs = await model.getProperties(expressID);
        if (!relAttrs) {
          continue;
        }
        relName = (_b = relAttrs.Name) == null ? void 0 : _b.value;
      }
      for (const id of rels) {
        this.saveItem(model, systemName, relName, id, expressID);
        const decompositionRelations = indexer.getEntityRelations(
          model,
          Number(id),
          "IsDecomposedBy"
        );
        if (!decompositionRelations) {
          continue;
        }
        for (const decomposedID of decompositionRelations) {
          this.saveItem(model, systemName, relName, decomposedID, expressID);
        }
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(items, color, override = false) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragID in items) {
      const found = fragments.list.get(fragID);
      if (!found)
        continue;
      const ids = items[fragID];
      found.setColor(color, ids, override);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(items) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragID in items) {
      const found = fragments.list.get(fragID);
      if (!found)
        continue;
      const ids = items[fragID];
      found.resetColor(ids);
    }
  }
  /**
   * Exports the computed classification to persists them and import them back
   * later for faster loading.
   */
  export() {
    const exported = {};
    for (const systemName in this.list) {
      exported[systemName] = {};
      const system = this.list[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        exported[systemName][groupName] = {
          map: jc.export(group.map),
          name: group.name,
          id: group.id
        };
      }
    }
    return exported;
  }
  /**
   * Imports a classification previously exported with .export().
   * @param data the serialized classification to import.
   */
  import(data) {
    for (const systemName in data) {
      if (!this.list[systemName]) {
        this.list[systemName] = {};
      }
      const system = data[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        this.list[systemName][groupName] = {
          map: jc.import(group.map),
          name: group.name,
          id: group.id
        };
      }
    }
  }
  saveItem(group, systemName, className, expressID, parentID = null) {
    if (!this.list[systemName]) {
      this.list[systemName] = {};
    }
    const keys = group.data.get(expressID);
    if (!keys)
      return;
    for (const key of keys[0]) {
      const fragmentID = group.keyFragments.get(key);
      if (fragmentID) {
        const system = this.list[systemName];
        if (!system[className]) {
          system[className] = { map: {}, id: parentID, name: className };
        }
        if (!system[className].map[fragmentID]) {
          system[className].map[fragmentID] = /* @__PURE__ */ new Set();
        }
        system[className].map[fragmentID].add(expressID);
      }
    }
  }
};
__publicField(_Classifier, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Classifier = _Classifier;
var _Exploder = class _Exploder2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "enabled", true);
    __publicField(this, "height", 10);
    __publicField(this, "groupName", "spatialStructures");
    __publicField(this, "list", /* @__PURE__ */ new Set());
    components.add(_Exploder2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(active) {
    if (!this.enabled)
      return;
    const classifier = this.components.get(Classifier);
    const fragments = this.components.get(FragmentsManager);
    const factor = active ? 1 : -1;
    let i = 0;
    const groups = classifier.list[this.groupName];
    const yTransform = new Matrix4();
    for (const groupName in groups) {
      yTransform.elements[13] = i * factor * this.height;
      for (const fragID in groups[groupName].map) {
        const fragment = fragments.list.get(fragID);
        const itemsID = groupName + fragID;
        const areItemsExploded = this.list.has(itemsID);
        if (!fragment || active && areItemsExploded || !active && !areItemsExploded) {
          continue;
        }
        if (active) {
          this.list.add(itemsID);
        } else {
          this.list.delete(itemsID);
        }
        const ids = groups[groupName].map[fragID];
        fragment.applyTransform(ids, yTransform);
        fragment.mesh.computeBoundingSphere();
        fragment.mesh.computeBoundingBox();
      }
      i++;
    }
  }
};
__publicField(_Exploder, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var Exploder = _Exploder;
var _Hider = class _Hider2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    this.components.add(_Hider2.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(visible, items) {
    const fragments = this.components.get(FragmentsManager);
    if (!items) {
      for (const [_id, fragment] of fragments.list) {
        if (fragment) {
          fragment.setVisibility(visible);
          this.updateCulledVisibility(fragment);
        }
      }
      return;
    }
    for (const fragID in items) {
      const ids = items[fragID];
      const fragment = fragments.list.get(fragID);
      if (fragment) {
        fragment.setVisibility(visible, ids);
        this.updateCulledVisibility(fragment);
      }
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(items) {
    this.set(false);
    this.set(true, items);
  }
  updateCulledVisibility(fragment) {
    const cullers = this.components.get(Cullers);
    for (const [_id, culler] of cullers.list) {
      const culled = culler.colorMeshes.get(fragment.id);
      if (culled) {
        culled.count = fragment.mesh.count;
      }
    }
  }
};
__publicField(_Hider, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Hider = _Hider;
var IfcStreamingSettings = class extends IfcFragmentSettings {
  constructor() {
    super(...arguments);
    __publicField(this, "minGeometrySize", 10);
    __publicField(this, "minAssetsSize", 1e3);
    __publicField(this, "maxTriangles", null);
  }
};
var _IfcGeometryTiler = class _IfcGeometryTiler2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onGeometryStreamed", new AsyncEvent());
    __publicField(this, "onAssetStreamed", new AsyncEvent());
    __publicField(this, "onProgress", new AsyncEvent());
    __publicField(this, "onIfcLoaded", new AsyncEvent());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "settings", new IfcStreamingSettings());
    __publicField(this, "enabled", true);
    __publicField(this, "webIfc", new IfcAPI2());
    __publicField(this, "_nextAvailableID", 0);
    __publicField(this, "_splittedGeometries", /* @__PURE__ */ new Map());
    __publicField(this, "_spatialTree", new SpatialStructure());
    __publicField(this, "_metaData", new IfcMetadataReader());
    __publicField(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    __publicField(this, "_streamSerializer", new Wc());
    __publicField(this, "_geometries", /* @__PURE__ */ new Map());
    __publicField(this, "_geometryCount", 0);
    __publicField(this, "_civil", new CivilReader());
    __publicField(this, "_groupSerializer", new Uc());
    __publicField(this, "_assets", []);
    __publicField(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(_IfcGeometryTiler2.uuid, this);
    this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset();
    this.onGeometryStreamed.reset();
    this.onAssetStreamed.reset();
    this.webIfc = null;
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(data) {
    await this.readIfcFile(data);
    await this.streamAllGeometries();
    this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(loadCallback) {
    await this.streamIfcFile(loadCallback);
    await this.streamAllGeometries();
    this.cleanUp();
  }
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModel(data, this.settings.webIfc);
    this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamIfcFile(loadCallback) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModelFromCallback(loadCallback, this.settings.webIfc);
    this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamAllGeometries() {
    console.log("Converting geometries to tiles...");
    const { minGeometrySize, minAssetsSize } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const allIfcEntities = this.webIfc.GetIfcEntityList(0);
    const chunks = [[]];
    const group = new Bc();
    group.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let counter = 0;
    let index = 0;
    for (const type of allIfcEntities) {
      if (!this.webIfc.IsIfcElement(type) && type !== IFCSPACE) {
        continue;
      }
      if (this.settings.excludedCategories.has(type)) {
        continue;
      }
      const result = this.webIfc.GetLineIDsWithType(0, type);
      const size = result.size();
      for (let i = 0; i < size; i++) {
        if (counter > minGeometrySize) {
          counter = 0;
          index++;
          chunks.push([]);
        }
        const itemID = result.get(i);
        chunks[index].push(itemID);
        const props = this.webIfc.GetLine(0, itemID);
        if (props.GlobalId) {
          const globalID = (props == null ? void 0 : props.GlobalId.value) || (props == null ? void 0 : props.GlobalId);
          group.globalToExpressIDs.set(globalID, itemID);
        }
        const level = this._spatialTree.itemsByFloor[itemID] || 0;
        group.data.set(itemID, [[], [level, type]]);
        counter++;
      }
    }
    this._spatialTree.cleanUp();
    let nextProgress = 0.01;
    let chunkCounter = 0;
    for (const chunk of chunks) {
      chunkCounter++;
      this.webIfc.StreamMeshes(0, chunk, (mesh) => {
        this.getMesh(this.webIfc, mesh, group);
      });
      if (this._geometryCount > this.settings.minGeometrySize) {
        await this.streamGeometries();
      }
      if (this._assets.length > minAssetsSize) {
        await this.streamAssets();
      }
      const currentProgress = chunkCounter / chunks.length;
      if (currentProgress > nextProgress) {
        nextProgress += 0.01;
        nextProgress = Math.max(nextProgress, currentProgress);
        await this.onProgress.trigger(Math.round(nextProgress * 100) / 100);
      }
    }
    if (this._geometryCount) {
      await this.streamGeometries();
    }
    if (this._assets.length) {
      await this.streamAssets();
    }
    const { opaque, transparent } = group.geometryIDs;
    for (const [id, { index: index2, uuid }] of this._visitedGeometries) {
      group.keyFragments.set(index2, uuid);
      const geometryID = id > 1 ? opaque : transparent;
      geometryID.set(id, index2);
    }
    SpatialIdsFinder.get(group, this.webIfc);
    const matrix = this.webIfc.GetCoordinationMatrix(0);
    group.coordinationMatrix.fromArray(matrix);
    group.civilData = this._civil.read(this.webIfc);
    const buffer = this._groupSerializer.export(group);
    await this.onIfcLoaded.trigger(buffer);
    group.dispose(true);
  }
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch (e2) {
    }
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
    this._visitedGeometries.clear();
    this._geometries.clear();
    this._assets = [];
    this._meshesWithHoles.clear();
  }
  getMesh(webIfc, mesh, group) {
    const size = mesh.geometries.size();
    const id = mesh.expressID;
    const asset = { id, geometries: [] };
    for (let i = 0; i < size; i++) {
      const geometry = mesh.geometries.get(i);
      const geometryID = geometry.geometryExpressID;
      const isOpaque = geometry.color.w === 1;
      const factor = isOpaque ? 1 : -1;
      const transpGeometryID = geometryID * factor;
      if (!this._visitedGeometries.has(transpGeometryID)) {
        this.getGeometry(webIfc, geometryID, isOpaque);
      }
      this.registerGeometryData(
        group,
        id,
        geometry,
        asset,
        geometryID,
        transpGeometryID
      );
      const splits = this._splittedGeometries.get(geometryID);
      if (splits) {
        for (const split of splits) {
          this.registerGeometryData(group, id, geometry, asset, split, split);
        }
      }
    }
    this._assets.push(asset);
  }
  getGeometry(webIfc, id, isOpaque) {
    const geometry = webIfc.GetGeometry(0, id);
    const index = webIfc.GetIndexArray(
      geometry.GetIndexData(),
      geometry.GetIndexDataSize()
    );
    const vertexData = webIfc.GetVertexArray(
      geometry.GetVertexData(),
      geometry.GetVertexDataSize()
    );
    const position = new Float32Array(vertexData.length / 2);
    const normal = new Float32Array(vertexData.length / 2);
    for (let i = 0; i < vertexData.length; i += 6) {
      position[i / 2] = vertexData[i];
      position[i / 2 + 1] = vertexData[i + 1];
      position[i / 2 + 2] = vertexData[i + 2];
      normal[i / 2] = vertexData[i + 3];
      normal[i / 2 + 1] = vertexData[i + 4];
      normal[i / 2 + 2] = vertexData[i + 5];
    }
    const factor = isOpaque ? 1 : -1;
    if (index.length === 0) {
      const boundingBox2 = new Float32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
      this._geometries.set(id, {
        position,
        normal,
        index,
        boundingBox: boundingBox2,
        hasHoles: false
      });
      const geomIndex = this._visitedGeometries.size;
      const uuid = MathUtils.generateUUID();
      const transpGeometryID = id * factor;
      this._visitedGeometries.set(transpGeometryID, { uuid, index: geomIndex });
      this._geometryCount++;
      geometry.delete();
      return;
    }
    const maxTris = this.settings.maxTriangles || index.length / 3;
    const maxIndexSize = maxTris * 3;
    let firstSplit = true;
    for (let i = 0; i < index.length; i += maxIndexSize) {
      const distanceToEnd = index.length - i;
      const distance = Math.min(distanceToEnd, maxIndexSize);
      const end = i + distance;
      const splittedIndexArray = [];
      const splittedPosArray = [];
      const splittedNorArray = [];
      let indexCounter = 0;
      for (let j2 = i; j2 < end; j2++) {
        splittedIndexArray.push(indexCounter++);
        const previousIndex = index[j2];
        splittedPosArray.push(position[previousIndex * 3]);
        splittedPosArray.push(position[previousIndex * 3 + 1]);
        splittedPosArray.push(position[previousIndex * 3 + 2]);
        splittedNorArray.push(normal[previousIndex * 3]);
        splittedNorArray.push(normal[previousIndex * 3 + 1]);
        splittedNorArray.push(normal[previousIndex * 3 + 2]);
      }
      const splittedIndex = new Uint32Array(splittedIndexArray);
      const splittedPosition = new Float32Array(splittedPosArray);
      const splittedNormal = new Float32Array(splittedNorArray);
      const obb3 = obbFromPoints(splittedPosition);
      const boundingBox2 = new Float32Array(obb3.transformation.elements);
      const hasHoles = false;
      const geometryID = firstSplit ? id : this._nextAvailableID++;
      this._geometries.set(geometryID, {
        position: splittedPosition,
        normal: splittedNormal,
        index: splittedIndex,
        boundingBox: boundingBox2,
        hasHoles
      });
      if (!firstSplit) {
        if (!this._splittedGeometries.has(id)) {
          this._splittedGeometries.set(id, /* @__PURE__ */ new Set());
        }
        const splits = this._splittedGeometries.get(id);
        splits.add(geometryID);
      }
      const geomIndex = this._visitedGeometries.size;
      const uuid = MathUtils.generateUUID();
      const transpGeometryID = geometryID * factor;
      this._visitedGeometries.set(transpGeometryID, { uuid, index: geomIndex });
      this._geometryCount++;
      firstSplit = false;
    }
    geometry.delete();
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets);
    this._assets = null;
    this._assets = [];
  }
  async streamGeometries() {
    const exportMap = /* @__PURE__ */ new Map();
    for (const [id, value] of this._geometries) {
      exportMap.set(id, value);
      if (exportMap.size > this.settings.minGeometrySize) {
        await this.outputGeometries(exportMap);
      }
    }
    await this.outputGeometries(exportMap);
    this._geometries.clear();
    this._geometryCount = 0;
  }
  async outputGeometries(exportMap) {
    let buffer = this._streamSerializer.export(exportMap);
    let data = {};
    for (const [id, { boundingBox: boundingBox2, hasHoles }] of exportMap) {
      data[id] = { boundingBox: boundingBox2, hasHoles };
    }
    await this.onGeometryStreamed.trigger({ data, buffer });
    data = null;
    buffer = null;
    exportMap.clear();
  }
  registerGeometryData(group, itemID, geometry, asset, geometryID, transpGeometryID) {
    const geometryData = this._visitedGeometries.get(transpGeometryID);
    if (geometryData === void 0) {
      throw new Error("Error getting geometry data for streaming!");
    }
    const data = group.data.get(itemID);
    if (!data) {
      throw new Error("Data not found!");
    }
    data[0].push(geometryData.index);
    const { x, y, z: z2, w } = geometry.color;
    const color = [x, y, z2, w];
    const transformation = geometry.flatTransformation;
    asset.geometries.push({ color, geometryID, transformation });
  }
};
__publicField(_IfcGeometryTiler, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var IfcGeometryTiler = _IfcGeometryTiler;
var PropertiesStreamingSettings = class extends IfcFragmentSettings {
  constructor() {
    super(...arguments);
    __publicField(this, "propertiesSize", 100);
  }
};
var IfcPropertiesTiler = class extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onPropertiesStreamed", new AsyncEvent());
    __publicField(this, "onProgress", new AsyncEvent());
    __publicField(this, "onIndicesStreamed", new AsyncEvent());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "enabled", true);
    __publicField(this, "settings", new PropertiesStreamingSettings());
    __publicField(this, "webIfc", new IfcAPI2());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset();
    this.onPropertiesStreamed.reset();
    this.webIfc = null;
    this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(data) {
    await this.readIfcFile(data);
    await this.streamAllProperties();
    this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(loadCallback) {
    await this.streamIfcFile(loadCallback);
    await this.streamAllProperties();
    this.cleanUp();
  }
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModel(data, this.settings.webIfc);
  }
  async streamIfcFile(loadCallback) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModelFromCallback(loadCallback, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize } = this.settings;
    const allIfcEntities = new Set(this.webIfc.GetIfcEntityList(0));
    const spatialStructure = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const type of spatialStructure) {
      allIfcEntities.add(type);
    }
    let nextProgress = 0.01;
    let typeCounter = 0;
    for (const type of allIfcEntities) {
      typeCounter++;
      if (GeometryTypes.has(type)) {
        continue;
      }
      const isSpatial = spatialStructure.has(type);
      const ids = this.webIfc.GetLineIDsWithType(0, type);
      const idCount = ids.size();
      let count = 0;
      for (let i = 0; i < idCount - propertiesSize; i += propertiesSize) {
        const data = {};
        for (let j2 = 0; j2 < propertiesSize; j2++) {
          count++;
          const nextProperty = ids.get(i + j2);
          try {
            const property = this.webIfc.GetLine(0, nextProperty, isSpatial);
            data[property.expressID] = property;
          } catch (e2) {
            console.log(`Could not get property: ${nextProperty}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type, data });
      }
      if (count !== idCount) {
        const data = {};
        for (let i = count; i < idCount; i++) {
          const nextProperty = ids.get(i);
          try {
            const property = this.webIfc.GetLine(0, nextProperty, isSpatial);
            data[property.expressID] = property;
          } catch (e2) {
            console.log(`Could not get property: ${nextProperty}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type, data });
      }
      const currentProgress = typeCounter / allIfcEntities.size;
      if (currentProgress > nextProgress) {
        nextProgress = Math.round(nextProgress * 100) / 100;
        await this.onProgress.trigger(nextProgress);
        nextProgress += 0.01;
      }
    }
    await this.onProgress.trigger(1);
    const relations = this.components.get(IfcRelationsIndexer);
    const rels = await relations.processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(rels);
  }
  cleanUp() {
    this.webIfc.Dispose();
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
  }
};
__publicField(IfcPropertiesTiler, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Viewpoint = class {
  constructor(components, world, _config) {
    __publicField(this, "title");
    __publicField(this, "guid", UUID.create());
    __publicField(this, "clippingPlanes", new DataSet());
    __publicField(this, "camera", {
      aspectRatio: 1,
      fov: 60,
      direction: { x: 0, y: 0, z: 0 },
      position: { x: 0, y: 0, z: 0 }
    });
    __publicField(this, "exceptionComponents", new DataSet());
    __publicField(this, "selectionComponents", new DataSet());
    __publicField(this, "componentColors", new DataMap());
    __publicField(this, "spacesVisible", false);
    __publicField(this, "spaceBoundariesVisible", false);
    __publicField(this, "openingsVisible", false);
    __publicField(this, "defaultVisibility", true);
    __publicField(this, "_components");
    __publicField(this, "world");
    const config = { setCamera: true, ..._config };
    const { data, setCamera } = config;
    this._components = components;
    this.world = world;
    if (data) {
      this.guid = data.guid ?? this.guid;
      this.set(data);
    }
    if (setCamera)
      this.updateCamera();
  }
  get _selectionModelIdMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = {};
    for (const [id, model] of fragments.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of this.selectionComponents) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    return modelIdMap;
  }
  get _exceptionModelIdMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = {};
    for (const [id, model] of fragments.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of this.exceptionComponents) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    return modelIdMap;
  }
  /**
   * A list of components that should be selected (highlighted) when displaying a viewpoint.
   * @returns The fragmentIdMap for components marked as selections.
   */
  get selection() {
    const fragments = this._components.get(FragmentsManager);
    const fragmentIdMap = fragments.modelIdToFragmentIdMap(
      this._selectionModelIdMap
    );
    return fragmentIdMap;
  }
  /**
   * A list of components to hide when defaultVisibility = true or to show when defaultVisibility = false
   * @returns The fragmentIdMap for components marked as exceptions.
   */
  get exception() {
    const fragments = this._components.get(FragmentsManager);
    const fragmentIdMap = fragments.modelIdToFragmentIdMap(
      this._exceptionModelIdMap
    );
    return fragmentIdMap;
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    if ("fov" in this.camera)
      return "Perspective";
    return "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @remarks
   * The position vector represents the camera's position in the world coordinate system.
   * The function applies the base coordinate system transformation to the position vector.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const fragments = this._components.get(FragmentsManager);
    const { position } = this.camera;
    const { x, y, z: z2 } = position;
    const vector = new Vector3(x, y, z2);
    fragments.applyBaseCoordinateSystem(vector, new Matrix4());
    return vector;
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   *
   * @remarks
   * The direction vector represents the direction in which the camera is pointing.
   * It is calculated by extracting the x, y, and z components from the camera's direction property.
   *
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { direction } = this.camera;
    const { x, y, z: z2 } = direction;
    const vector = new Vector3(x, y, z2);
    return vector;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    const manager = this._components.get(BCFTopics);
    const topicsList = [...manager.list.values()];
    const topics = topicsList.filter(
      (topic) => topic.viewpoints.has(this.guid)
    );
    return topics;
  }
  /**
   * Adds components to the viewpoint based on the provided fragment ID map.
   *
   * @param fragmentIdMap - A map containing fragment IDs as keys and arrays of express IDs as values.
   */
  addComponentsFromMap(fragmentIdMap) {
    const fragments = this._components.get(FragmentsManager);
    const guids = fragments.fragmentIdMapToGuids(fragmentIdMap);
    this.selectionComponents.add(...guids);
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
  }
  /**
   * Replace the properties of the viewpoint with the provided data.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   * @remarks The existing selection and exception components will be fully replaced in case new ones are provided.
   *
   * @param data - An object containing the properties to be set.
   *               The properties not included in the object will remain unchanged.
   *
   * @returns The viewpoint instance with the updated properties.
   */
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "guid")
        continue;
      const value = _data[key];
      if (key === "selectionComponents") {
        this.selectionComponents.clear();
        this.selectionComponents.add(...value);
        continue;
      }
      if (key === "exceptionComponents") {
        this.exceptionComponents.clear();
        this.exceptionComponents.add(...value);
        continue;
      }
      if (key in this)
        _this[key] = value;
    }
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
    return this;
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(world, transition = true) {
    const { camera } = world ?? this.world;
    if (!camera.hasCameraControls()) {
      throw new Error(
        "Viewpoint: the world's camera need controls to set the viewpoint."
      );
    }
    if (camera instanceof OrthoPerspectiveCamera) {
      camera.projection.set(this.projection);
    }
    const basePosition = new Vector3(
      this.camera.position.x,
      this.camera.position.y,
      this.camera.position.z
    );
    const baseTarget = new Vector3(
      this.camera.direction.x,
      this.camera.direction.y,
      this.camera.direction.z
    );
    if (basePosition.equals(new Vector3()) && baseTarget.equals(new Vector3())) {
      return;
    }
    const position = this.position;
    const direction = this.direction;
    let target = {
      x: position.x + direction.x * 80,
      y: position.y + direction.y * 80,
      z: position.z + direction.z * 80
    };
    const selection = this.selection;
    if (Object.keys(selection).length === 0) {
      const raycasters = this._components.get(Raycasters);
      const raycaster = raycasters.get(this.world);
      const result = raycaster.castRayFromVector(position, this.direction);
      if (result)
        target = result.point;
    } else {
      const bb = this._components.get(BoundingBoxer);
      bb.reset();
      bb.addFragmentIdMap(selection);
      target = bb.getSphere().center;
      bb.reset();
    }
    await camera.controls.setLookAt(
      position.x,
      position.y,
      position.z,
      target.x,
      target.y,
      target.z,
      transition
    );
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   *
   * @remarks
   * This function retrieves the camera's position, direction, and aspect ratio from the world's camera and renderer.
   * It then calculates the camera's perspective or orthographic settings based on the camera type.
   * Finally, it updates the viewpoint's camera settings and updates the viewpoint to the Viewpoints manager.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  updateCamera(world) {
    const { camera, renderer } = world ?? this.world;
    if (!renderer) {
      throw new Error("Viewpoint: the world needs to have a renderer!");
    }
    if (!camera.hasCameraControls()) {
      throw new Error("Viewpoint: world's camera need camera controls!");
    }
    const position = new Vector3();
    camera.controls.getPosition(position);
    const threeCamera = camera.three;
    const direction = new Vector3(0, 0, -1).applyEuler(
      threeCamera.rotation
    );
    const { width, height } = renderer.getSize();
    let aspectRatio = width / height;
    if (Number.isNaN(aspectRatio))
      aspectRatio = 1;
    const fragments = this._components.get(FragmentsManager);
    position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    const partialCamera = {
      aspectRatio,
      position: { x: position.x, y: position.y, z: position.z },
      direction: { x: direction.x, y: direction.y, z: direction.z }
    };
    if (threeCamera instanceof PerspectiveCamera) {
      this.camera = {
        ...partialCamera,
        fov: threeCamera.fov
      };
    } else if (threeCamera instanceof OrthographicCamera) {
      this.camera = {
        ...partialCamera,
        viewToWorldScale: threeCamera.top - threeCamera.bottom
      };
    }
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
  }
  applyVisibility() {
    const hider = this._components.get(Hider);
    hider.set(this.defaultVisibility);
    hider.set(!this.defaultVisibility, this.exception);
    hider.set(true, this.selection);
  }
  /**
   * Applies color to the components in the viewpoint based on their GUIDs.
   *
   * This function iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to apply the color to those fragments.
   *
   * @remarks
   * The color is applied using the `Classifier.setColor` method, which sets the color of the specified fragments.
   * The color is provided as a hexadecimal string, prefixed with a '#'.
   */
  applyColors() {
    const manager = this._components.get(Viewpoints);
    const fragments = this._components.get(FragmentsManager);
    const classifier = this._components.get(Classifier);
    for (const [color, guids] of this.componentColors) {
      const fragmentIdMap = fragments.guidToFragmentIdMap(guids);
      classifier.setColor(fragmentIdMap, color, manager.config.overwriteColors);
    }
  }
  /**
   * Resets the colors of all components in the viewpoint to their original color.
   */
  resetColors() {
    const fragments = this._components.get(FragmentsManager);
    const classifier = this._components.get(Classifier);
    for (const [_, guids] of this.componentColors) {
      const fragmentIdMap = fragments.guidToFragmentIdMap(guids);
      classifier.resetColor(fragmentIdMap);
    }
  }
  async createComponentTags(from) {
    var _a22, _b;
    const fragments = this._components.get(FragmentsManager);
    const manager = this._components.get(BCFTopics);
    let tags = "";
    if (manager.config.includeSelectionTag) {
      const modelIdMap = from === "selection" ? this._selectionModelIdMap : this._exceptionModelIdMap;
      for (const modelID in modelIdMap) {
        const model = fragments.groups.get(modelID);
        if (!model)
          continue;
        const expressIDs = modelIdMap[modelID];
        for (const expressID of expressIDs) {
          const attrs = await model.getProperties(expressID);
          if (!attrs)
            continue;
          const globalID = (_a22 = attrs.GlobalId) == null ? void 0 : _a22.value;
          if (!globalID)
            continue;
          const tag = (_b = attrs.Tag) == null ? void 0 : _b.value;
          let tagAttribute = null;
          if (tag)
            tagAttribute = `AuthoringToolId="${tag}"`;
          tags += `
<Component IfcGuid="${globalID}" ${tagAttribute ?? ""} />`;
        }
      }
    } else {
      tags = [...this.selectionComponents].map((globalId) => `<Component IfcGuid="${globalId}" />`).join(`
`);
    }
    return tags;
  }
  createColorTags() {
    let colorTags = "";
    for (const [color, components] of this.componentColors.entries()) {
      const hex = `#${color.getHexString()}`;
      const tags = components.map((globalId) => `
<Component IfcGuid="${globalId}" />`).join("\n");
      colorTags += `<Color Color="${hex}">
${tags}
</Color>`;
    }
    if (colorTags.length !== 0) {
      return `<Coloring>
${colorTags}
</Coloring>`;
    }
    return `<Coloring />`;
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(version = this._managerVersion) {
    const fragments = this._components.get(FragmentsManager);
    const position = this.position;
    position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    const direction = this.direction;
    direction.normalize();
    const rotationMatrix = new Matrix4().makeRotationX(Math.PI / 2);
    const upVector = direction.clone().applyMatrix4(rotationMatrix);
    upVector.normalize();
    const cameraViewpointXML = `<CameraViewPoint>
      <X>${position.x}</X>
      <Y>${-position.z}</Y>
      <Z>${position.y}</Z>
    </CameraViewPoint>`;
    const cameraDirectionXML = `<CameraDirection>
      <X>${direction.x}</X>
      <Y>${-direction.z}</Y>
      <Z>${direction.y}</Z>
    </CameraDirection>`;
    const cameraUpVectorXML = `<CameraUpVector>
      <X>${upVector.x}</X>
      <Y>${-upVector.z}</Y>
      <Z>${upVector.y}</Z>
    </CameraUpVector>`;
    const cameraRatioXML = `<AspectRatio>${this.camera.aspectRatio}</AspectRatio>`;
    let cameraXML = "";
    if ("viewToWorld" in this.camera) {
      cameraXML = `<OrthogonalCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>`;
    } else if ("fov" in this.camera) {
      cameraXML = `<PerspectiveCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`;
    }
    const viewSetupHints = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? false}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? false}" OpeningsVisible="${this.openingsVisible ?? false}" />`;
    const selectionTags = (await this.createComponentTags("selection")).trim();
    const exceptionTags = (await this.createComponentTags("exception")).trim();
    const colorTags = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${version === "2.1" ? viewSetupHints : ""}
        ${selectionTags.length !== 0 ? `<Selection>${selectionTags}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${version === "3" ? viewSetupHints : ""}
          ${exceptionTags.length !== 0 ? `<Exceptions>${exceptionTags}</Exceptions>` : ""}
        </Visibility>
        ${colorTags}
      </Components>
      ${cameraXML}
    </VisualizationInfo>`;
  }
};
var ViewpointsConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      overwriteColors: {
        value: false,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(value) {
    this._config.overwriteColors.value = value;
  }
};
var _Viewpoints = class _Viewpoints2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "list", new DataMap());
    __publicField(this, "isSetup", false);
    __publicField(this, "onSetup", new Event());
    __publicField(this, "config", new ViewpointsConfigManager(
      this,
      this.components,
      "Viewpoints",
      _Viewpoints2.uuid
    ));
    __publicField(this, "onDisposed", new Event());
    components.add(_Viewpoints2.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param world - The world in which the Viewpoint will be created.
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(world, data) {
    const viewpoint = new Viewpoint(this.components, world, { data });
    if (!data)
      this.list.set(viewpoint.guid, viewpoint);
    return viewpoint;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
__publicField(_Viewpoints, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
var Viewpoints = _Viewpoints;
var MiniMapConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      lockRotation: {
        value: true,
        type: "Boolean"
      },
      zoom: {
        type: "Number",
        interpolable: true,
        value: 0.05,
        min: 1e-3,
        max: 5
      },
      frontOffset: {
        type: "Number",
        interpolable: true,
        value: 0,
        min: 0,
        max: 100
      },
      sizeX: {
        type: "Number",
        interpolable: true,
        value: 320,
        min: 20,
        max: 5e3
      },
      sizeY: {
        type: "Number",
        interpolable: true,
        value: 160,
        min: 20,
        max: 5e3
      },
      backgroundColor: {
        value: new Color(),
        type: "Color"
      }
    });
  }
  /**
   * Whether the minimap is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the minimap is visible or not.
   */
  set visible(value) {
    this._config.visible.value = value;
    const style = this._component.renderer.domElement.style;
    style.display = value ? "block" : "none";
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  get lockRotation() {
    return this._config.lockRotation.value;
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  set lockRotation(value) {
    this._config.lockRotation.value = value;
    this._component.lockRotation = value;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  get zoom() {
    return this._config.zoom.value;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  set zoom(value) {
    this._config.zoom.value = value;
    this._component.zoom = value;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  get frontOffset() {
    return this._config.frontOffset.value;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  set frontOffset(value) {
    this._config.frontOffset.value = value;
    this._component.frontOffset = value;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  get sizeX() {
    return this._config.sizeX.value;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  set sizeX(value) {
    this._config.sizeX.value = value;
    const { sizeX, sizeY } = this._config;
    const size = new Vector2(sizeX.value, sizeY.value);
    this._component.resize(size);
  }
  /**
   * The vertical dimension of the minimap.
   */
  get sizeY() {
    return this._config.sizeY.value;
  }
  /**
   * The vertical dimension of the minimap.
   */
  set sizeY(value) {
    this._config.sizeY.value = value;
    const { sizeX, sizeY } = this._config;
    const size = new Vector2(sizeX.value, sizeY.value);
    this._component.resize(size);
  }
  /**
   * The color of the background of the minimap.
   */
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  /**
   * The color of the background of the minimap.
   */
  set backgroundColor(value) {
    this._config.backgroundColor.value = value;
    this._component.backgroundColor = value;
  }
};
var MiniMap = class {
  constructor(world, components) {
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onResize", new Event());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "frontOffset", 0);
    __publicField(this, "overrideMaterial", new MeshDepthMaterial());
    __publicField(this, "backgroundColor", new Color(395274));
    __publicField(this, "renderer");
    __publicField(this, "enabled", true);
    __publicField(this, "world");
    __publicField(this, "config");
    __publicField(this, "isSetup", false);
    __publicField(this, "_defaultConfig", {
      visible: true,
      lockRotation: false,
      zoom: 0.05,
      frontOffset: 0,
      sizeX: 320,
      sizeY: 160,
      backgroundColor: new Color(395274)
    });
    __publicField(this, "_lockRotation", true);
    __publicField(this, "_size", new Vector2(320, 160));
    __publicField(this, "_camera");
    __publicField(this, "_plane");
    __publicField(this, "_tempVector1", new Vector3());
    __publicField(this, "_tempVector2", new Vector3());
    __publicField(this, "_tempTarget", new Vector3());
    __publicField(this, "down", new Vector3(0, -1, 0));
    __publicField(this, "updatePlanes", () => {
      if (!this.world.renderer) {
        throw new Error("The given world must have a renderer!");
      }
      const planes = [];
      const renderer = this.world.renderer.three;
      for (const plane of renderer.clippingPlanes) {
        planes.push(plane);
      }
      planes.push(this._plane);
      this.renderer.clippingPlanes = planes;
    });
    this.world = world;
    if (!this.world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.renderer = new WebGLRenderer();
    this.renderer.setSize(this._size.x, this._size.y);
    const frustumSize = 1;
    const aspect = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2
    );
    this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes);
    this._camera.position.set(0, 200, 0);
    this._camera.zoom = 0.1;
    this._camera.rotation.x = -Math.PI / 2;
    this._plane = new Plane(this.down, 200);
    this.updatePlanes();
    this.config = new MiniMapConfigManager(this, components, "MiniMap");
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(active) {
    this._lockRotation = active;
    if (active) {
      this._camera.rotation.z = 0;
    }
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(value) {
    this._camera.zoom = value;
    this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.onResize.reset();
    this.overrideMaterial.dispose();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const scene = this.world.scene.three;
    const camera = this.world.camera;
    if (!camera.hasCameraControls()) {
      throw new Error("The given world must use camera controls!");
    }
    if (!(scene instanceof Scene)) {
      throw new Error("The given world must have a THREE.Scene as a root!");
    }
    const controls = camera.controls;
    controls.getPosition(this._tempVector1);
    this._camera.position.x = this._tempVector1.x;
    this._camera.position.z = this._tempVector1.z;
    if (this.frontOffset !== 0) {
      controls.getTarget(this._tempVector2);
      this._tempVector2.sub(this._tempVector1);
      this._tempVector2.normalize().multiplyScalar(this.frontOffset);
      this._camera.position.x += this._tempVector2.x;
      this._camera.position.z += this._tempVector2.z;
    }
    if (!this._lockRotation) {
      controls.getTarget(this._tempTarget);
      const angle = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = angle + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const previousBackground = scene.background;
    scene.background = this.backgroundColor;
    this.renderer.render(scene, this._camera);
    scene.background = previousBackground;
    this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(size = this._size) {
    this._size.copy(size);
    this.renderer.setSize(size.x, size.y);
    const aspect = size.x / size.y;
    const frustumSize = 1;
    this._camera.left = frustumSize * aspect / -2;
    this._camera.right = frustumSize * aspect / 2;
    this._camera.top = frustumSize / 2;
    this._camera.bottom = -1 / 2;
    this._camera.updateProjectionMatrix();
    this.onResize.trigger(size);
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.visible = true;
    this.config.lockRotation = fullConfig.lockRotation;
    this.config.zoom = fullConfig.zoom;
    this.config.frontOffset = fullConfig.frontOffset;
    this.config.sizeX = fullConfig.sizeX;
    this.config.sizeY = fullConfig.sizeY;
    this.config.backgroundColor = fullConfig.backgroundColor;
    this.isSetup = true;
    this.onSetup.trigger();
  }
};
var _MiniMaps = class _MiniMaps2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "onAfterUpdate", new Event());
    __publicField(this, "onBeforeUpdate", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "enabled", true);
    __publicField(this, "list", /* @__PURE__ */ new Map());
    this.components.add(_MiniMaps2.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      throw new Error("This world already has a minimap!");
    }
    const map = new MiniMap(world, this.components);
    this.list.set(world.uuid, map);
    return map;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(id) {
    const map = this.list.get(id);
    if (map) {
      map.dispose();
    }
    this.list.delete(id);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, map] of this.list) {
      map.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [_id, map] of this.list) {
      map.update();
    }
  }
};
__publicField(_MiniMaps, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var MiniMaps = _MiniMaps;
var _MeasurementUtils = class _MeasurementUtils2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    components.add(_MeasurementUtils2.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(point, lineStart, lineEnd, clamp2 = false) {
    const tempLine = new Line3();
    const tempPoint = new Vector3();
    tempLine.set(lineStart, lineEnd);
    tempLine.closestPointToPoint(point, clamp2, tempPoint);
    return tempPoint.distanceTo(point);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(mesh, triangleIndex, instance) {
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const allEdges = /* @__PURE__ */ new Map();
    const indices = mesh.geometry.index.array;
    const { plane: targetPlane } = this.getFaceData(
      triangleIndex,
      instance,
      mesh
    );
    const coplanarFacesIndices = [];
    for (let faceIndex = 0; faceIndex < indices.length / 3; faceIndex++) {
      const { plane, edges } = this.getFaceData(faceIndex, instance, mesh);
      if (plane.equals(targetPlane)) {
        coplanarFacesIndices.push({ index: faceIndex, edges });
        for (const { id, points, distance } of edges) {
          allEdges.set(id, { points, distance });
        }
      }
    }
    let nextFaceID = 0;
    const edgeFaceMap = /* @__PURE__ */ new Map();
    const faceEdgesMap = /* @__PURE__ */ new Map();
    for (const { index, edges } of coplanarFacesIndices) {
      const commonEdgesFaces = /* @__PURE__ */ new Map();
      for (const { id: edge } of edges) {
        if (edgeFaceMap.has(edge)) {
          const commonFace = edgeFaceMap.get(edge);
          commonEdgesFaces.set(edge, commonFace);
        }
      }
      const edgesIDs = edges.map((edge) => edge.id);
      if (!commonEdgesFaces.size) {
        const faceID = nextFaceID++;
        for (const { id: edge } of edges) {
          edgeFaceMap.set(edge, faceID);
        }
        faceEdgesMap.set(faceID, {
          edges: new Set(edgesIDs),
          indices: /* @__PURE__ */ new Set([index])
        });
        continue;
      }
      let firstFaceID = null;
      const otherFaces = /* @__PURE__ */ new Set();
      const edgesToAdd = new Set(edgesIDs);
      for (const [edge, faceID] of commonEdgesFaces) {
        if (firstFaceID === null) {
          firstFaceID = faceID;
        } else if (faceID !== firstFaceID) {
          otherFaces.add(faceID);
        }
        edgeFaceMap.delete(edge);
        const { edges: foundFaceEdges } = faceEdgesMap.get(faceID);
        foundFaceEdges.delete(edge);
        edgesToAdd.delete(edge);
      }
      if (firstFaceID === null) {
        throw new Error("Error computing face!");
      }
      const firstFace = faceEdgesMap.get(firstFaceID);
      const { indices: firstFaceIndices } = firstFace;
      firstFaceIndices.add(index);
      for (const edge of edgesToAdd) {
        edgeFaceMap.set(edge, firstFaceID);
        const { edges: firstFaceEdges } = firstFace;
        firstFaceEdges.add(edge);
      }
      for (const faceID of otherFaces) {
        const otherFace = faceEdgesMap.get(faceID);
        const { edges: otherEdges, indices: otherIndices } = otherFace;
        const firstFace2 = faceEdgesMap.get(firstFaceID);
        const { edges: firstEdges, indices: firstIndices } = firstFace2;
        for (const edge of otherEdges) {
          firstEdges.add(edge);
          edgeFaceMap.set(edge, firstFaceID);
        }
        for (const index2 of otherIndices) {
          firstIndices.add(index2);
        }
        faceEdgesMap.delete(faceID);
      }
    }
    for (const [_faceID, { indices: indices2, edges }] of faceEdgesMap) {
      if (indices2.has(triangleIndex)) {
        const foundEdges = [];
        for (const edgeID of edges) {
          const foundEdge = allEdges.get(edgeID);
          foundEdges.push(foundEdge);
        }
        return { edges: foundEdges, indices: indices2 };
      }
    }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(mesh, faceIndex, instance) {
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const indices = mesh.geometry.index.array;
    const pos = mesh.geometry.attributes.position.array;
    const nor = mesh.geometry.attributes.normal.array;
    const i1 = indices[faceIndex * 3] * 3;
    const i2 = indices[faceIndex * 3 + 1] * 3;
    const i3 = indices[faceIndex * 3 + 2] * 3;
    const p1 = new Vector3(pos[i1], pos[i1 + 1], pos[i1 + 2]);
    const p2 = new Vector3(pos[i2], pos[i2 + 1], pos[i2 + 2]);
    const p3 = new Vector3(pos[i3], pos[i3 + 1], pos[i3 + 2]);
    const n1 = new Vector3(nor[i1], nor[i1 + 1], nor[i1 + 2]);
    const n2 = new Vector3(nor[i2], nor[i2 + 1], nor[i2 + 2]);
    const n3 = new Vector3(nor[i3], nor[i3 + 1], nor[i3 + 2]);
    const averageNx = (n1.x + n2.x + n3.x) / 3;
    const averageNy = (n1.y + n2.y + n3.y) / 3;
    const averageNz = (n1.z + n2.z + n3.z) / 3;
    const faceNormal = new Vector3(averageNx, averageNy, averageNz);
    if (instance !== void 0 && mesh instanceof InstancedMesh) {
      const transform = new Matrix4();
      mesh.getMatrixAt(instance, transform);
      const rotation = new Matrix4();
      rotation.extractRotation(transform);
      faceNormal.applyMatrix4(rotation);
      p1.applyMatrix4(transform);
      p2.applyMatrix4(transform);
      p3.applyMatrix4(transform);
    }
    return { p1, p2, p3, faceNormal };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(vector) {
    const factor = 1e3;
    vector.x = Math.trunc(vector.x * factor) / factor;
    vector.y = Math.trunc(vector.y * factor) / factor;
    vector.z = Math.trunc(vector.z * factor) / factor;
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments and the bounding sphere.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume and its bounding sphere.
   *
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(frags) {
    const fragments = this.components.get(FragmentsManager);
    const tempMatrix2 = new Matrix4();
    const meshes = [];
    for (const fragID in frags) {
      const fragment = fragments.list.get(fragID);
      if (!fragment)
        continue;
      const itemIDs = frags[fragID];
      let instanceCount = 0;
      for (const id of itemIDs) {
        const instances = fragment.getInstancesIDs(id);
        if (!instances)
          continue;
        instanceCount += instances.size;
      }
      const mesh = new InstancedMesh(
        fragment.mesh.geometry,
        void 0,
        instanceCount
      );
      let counter = 0;
      for (const id of itemIDs) {
        const instances = fragment.getInstancesIDs(id);
        if (!instances)
          continue;
        for (const instance of instances) {
          fragment.mesh.getMatrixAt(instance, tempMatrix2);
          mesh.setMatrixAt(counter++, tempMatrix2);
        }
      }
      meshes.push(mesh);
    }
    const result = this.getVolumeFromMeshes(meshes);
    for (const mesh of meshes) {
      mesh.geometry = null;
      mesh.material = [];
      mesh.dispose();
    }
    return result;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes and the bounding sphere.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume
   * and its bounding sphere.
   *
   */
  getVolumeFromMeshes(meshes) {
    let volume = 0;
    for (const mesh of meshes) {
      volume += this.getVolumeOfMesh(mesh);
    }
    return volume;
  }
  getFaceData(faceIndex, instance, mesh) {
    const found = this.getVerticesAndNormal(mesh, faceIndex, instance);
    const { p1, p2, p3, faceNormal } = found;
    this.round(p1);
    this.round(p2);
    this.round(p3);
    this.round(faceNormal);
    const vertices = [
      { id: `${p1.x}|${p1.y}|${p1.z}`, value: p1 },
      { id: `${p2.x}|${p2.y}|${p2.z}`, value: p2 },
      { id: `${p3.x}|${p3.y}|${p3.z}`, value: p3 }
    ];
    vertices.sort((a, b) => {
      if (a.id < b.id) {
        return -1;
      }
      if (a.id > b.id) {
        return 1;
      }
      return 0;
    });
    const [
      { id: id1, value: v1 },
      { id: id2, value: v2 },
      { id: id3, value: v3 }
    ] = vertices;
    const edges = [
      {
        id: `${id1}|${id2}`,
        distance: v1.distanceTo(v2),
        points: [v1, v2]
      },
      {
        id: `${id2}|${id3}`,
        distance: v2.distanceTo(v3),
        points: [v2, v3]
      },
      {
        id: `${id1}|${id3}`,
        distance: v1.distanceTo(v3),
        points: [v1, v3]
      }
    ];
    const plane = new Plane();
    plane.setFromNormalAndCoplanarPoint(faceNormal, p1);
    plane.constant = Math.round(plane.constant * 10) / 10;
    return { plane, edges };
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(mesh) {
    let volume = 0;
    const p1 = new Vector3();
    const p2 = new Vector3();
    const p3 = new Vector3();
    const { index } = mesh.geometry;
    const pos = mesh.geometry.attributes.position.array;
    if (!index) {
      console.warn("Geometry must be indexed to compute its volume!");
      return 0;
    }
    const instances = [];
    if (mesh instanceof InstancedMesh) {
      for (let i = 0; i < mesh.count; i++) {
        const matrix = new Matrix4();
        mesh.getMatrixAt(i, matrix);
        instances.push(matrix);
      }
    } else {
      instances.push(new Matrix4().identity());
    }
    const { matrixWorld } = mesh;
    for (let i = 0; i < index.array.length - 2; i += 3) {
      for (const instance of instances) {
        const transform = instance.multiply(matrixWorld);
        const i1 = index.array[i] * 3;
        const i2 = index.array[i + 1] * 3;
        const i3 = index.array[i + 2] * 3;
        p1.set(pos[i1], pos[i1 + 1], pos[i1 + 2]).applyMatrix4(transform);
        p2.set(pos[i2], pos[i2 + 1], pos[i2 + 2]).applyMatrix4(transform);
        p3.set(pos[i3], pos[i3 + 1], pos[i3 + 2]).applyMatrix4(transform);
        volume += this.getSignedVolumeOfTriangle(p1, p2, p3);
      }
    }
    return Math.abs(volume);
  }
  getSignedVolumeOfTriangle(p1, p2, p3) {
    const v321 = p3.x * p2.y * p1.z;
    const v231 = p2.x * p3.y * p1.z;
    const v312 = p3.x * p1.y * p2.z;
    const v132 = p1.x * p3.y * p2.z;
    const v213 = p2.x * p1.y * p3.z;
    const v123 = p1.x * p2.y * p3.z;
    return 1 / 6 * (-v321 + v231 + v312 - v132 - v213 + v123);
  }
};
__publicField(_MeasurementUtils, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var MeasurementUtils = _MeasurementUtils;
var IDSFacet = class {
  constructor(components) {
    __publicField(this, "cardinality", "required");
    __publicField(this, "instructions");
    __publicField(this, "evalRequirement", (value, facetParameter, parameter, checks) => {
      const checkLog = {
        parameter,
        currentValue: value,
        requiredValue: facetParameter.parameter,
        pass: false
      };
      if (checks)
        this.addCheckResult(checkLog, checks);
      let pass = false;
      if (facetParameter.type === "simple") {
        pass = value === facetParameter.parameter;
      }
      if (facetParameter.type === "enumeration") {
        pass = facetParameter.parameter.includes(value);
      }
      if (facetParameter.type === "pattern") {
        const regex = new RegExp(facetParameter.parameter);
        pass = regex.test(String(value));
      }
      if (facetParameter.type === "length") {
        const { min, length, max } = facetParameter.parameter;
        if (length !== void 0) {
          pass = String(value).length === length;
        }
        if (min !== void 0) {
          pass = String(value).length >= min;
        }
        if (max !== void 0) {
          pass = String(value).length <= max;
        }
      }
      if (facetParameter.type === "bounds" && typeof value === "number") {
        const { min, minInclusive, max, maxInclusive } = facetParameter.parameter;
        let minPass = true;
        let maxPass = true;
        if (min !== void 0) {
          minPass = minInclusive ? value >= min : value > min;
        }
        if (max !== void 0) {
          maxPass = maxInclusive ? value <= max : value < max;
        }
        pass = minPass && maxPass;
      }
      if (this.cardinality === "prohibited")
        pass = !pass;
      if (this.cardinality === "optional")
        pass = true;
      checkLog.pass = pass;
      return checkLog.pass;
    });
    __publicField(this, "testResult", []);
    this.components = components;
  }
  addCheckResult(check, checks) {
    const index = checks.findIndex(
      ({ parameter }) => parameter === check.parameter
    );
    if (index !== -1) {
      checks[index] = check;
    } else {
      checks.push(check);
    }
  }
  saveResult(attrs, pass) {
    const { GlobalId } = attrs;
    if (!GlobalId)
      return;
    const { value: guid } = GlobalId;
    const result = {
      expressID: guid,
      pass,
      checks: [],
      cardinality: this.cardinality
    };
    this.testResult.push(result);
  }
};
var getParameterXML = (name, parameter) => {
  let parameterXML = "";
  if (!parameter)
    return parameterXML;
  if (parameter.type === "simple") {
    parameterXML = `<simpleValue>${parameter.parameter}</simpleValue>`;
  }
  if (parameter.type === "enumeration") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
    ${value.map((v) => `<xs:enumeration value="${v}" />`).join("\n")}
    </xs:restriction>`;
  }
  if (parameter.type === "pattern") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
      <xs:pattern value="${value}" />
    </xs:restriction>`;
  }
  if (parameter.type === "bounds") {
    const { min, minInclusive, max, maxInclusive } = parameter.parameter;
    let minTag = "";
    if (min !== void 0) {
      minTag = `<xs:min${minInclusive ? "Inclusive" : "Exclusive"} value="${min}">`;
    }
    let maxTag = "";
    if (max !== void 0) {
      maxTag = `<xs:max${maxInclusive ? "Inclusive" : "Exclusive"} value="${max}">`;
    }
    parameterXML = `<xs:restriction base="xs:double">
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  if (parameter.type === "length") {
    const { length, min, max } = parameter.parameter;
    let lengthTag = "";
    if (length !== void 0 && min === void 0 && max === void 0) {
      lengthTag = `<xs:length value="${length}" />`;
    }
    let minTag = "";
    if (min !== void 0 && length === void 0) {
      minTag = `<xs:minLength value="${min}" />`;
    }
    let maxTag = "";
    if (max !== void 0 && length === void 0) {
      maxTag = `<xs:maxLength value="${max}" />`;
    }
    parameterXML = `<xs:restriction base="xs:string">
      ${lengthTag}
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  const xml = `<${name[0].toLowerCase() + name.slice(1)}>
    ${parameterXML}
  </${name[0].toLowerCase() + name.slice(1)}>`;
  return xml;
};
var IDSAttribute = class extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField(this, "facetType", "Attribute");
    __publicField(this, "name");
    __publicField(this, "value");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<attribute ${attributes}>
  ${nameXML}
  ${valueXML}
</attribute>`;
  }
  // This can be very ineficcient as we do not have an easy way to get an entity based on an attribute
  // Right now, all entities must be iterated.
  // When the new IfcEntitiesFinder comes, this can become easier.
  // This may be greatly increase in performance if the applicability has any of the other facets and this is applied the latest
  async getEntities() {
    return [];
  }
  // async getEntities(
  //   model: FRAGS.FragmentsGroup,
  //   collector: FRAGS.IfcProperties = {},
  // ) {
  //   return [];
  //   // for (const expressID in model) {
  //   //   if (collector[expressID]) continue;
  //   //   const entity = model[expressID];
  //   //   // Check if the attribute exists
  //   //   const attribute = entity[this.name];
  //   //   const attributeExists = !!attribute;
  //   //   // Check if the attribute value matches
  //   //   let valueMatches = true;
  //   //   if (attributeExists && this.value && this.value.value) {
  //   //     if (this.value.type === "simpleValue") {
  //   //       valueMatches = attribute.value === this.value.value;
  //   //     }
  //   //     if (this.value.type === "restriction") {
  //   //       const regex = new RegExp(this.value.value);
  //   //       valueMatches = regex.test(attribute.value);
  //   //     }
  //   //   }
  //   //   if (attributeExists && valueMatches) {
  //   //     collector[entity.expressID] = entity;
  //   //   }
  //   // }
  // }
  // https://github.com/buildingSMART/IDS/tree/development/Documentation/ImplementersDocumentation/TestCases/attribute
  // Test cases from buildingSMART repo have been tested and they all match with the expected result
  // All invalid cases have been treated as failures
  // FragmentsGroup do not hold some of the entities used in the tests
  async test(entities) {
    var _a22;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a22 = attrs.GlobalId) == null ? void 0 : _a22.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      const attrNames = Object.keys(attrs);
      const matchingAttributes = attrNames.filter((name) => {
        const nameMatches = this.evalRequirement(name, this.name, "Name");
        const attrValue = attrs[name];
        if (nameMatches && attrValue === null) {
          if (this.cardinality === "optional" || this.cardinality === "prohibited") {
            return true;
          }
          return false;
        }
        if (nameMatches && (attrValue == null ? void 0 : attrValue.type) === 3 && attrValue.value === 2) {
          return false;
        }
        if (nameMatches && Array.isArray(attrValue) && attrValue.length === 0) {
          return false;
        }
        if (nameMatches && (attrValue == null ? void 0 : attrValue.type) === 1 && attrValue.value.trim() === "") {
          return false;
        }
        return nameMatches;
      });
      const attributeMatches = matchingAttributes.length > 0;
      checks.push({
        parameter: "Name",
        currentValue: attributeMatches ? matchingAttributes[0] : null,
        requiredValue: this.name.parameter,
        pass: this.cardinality === "prohibited" ? !attributeMatches : attributeMatches
      });
      if (this.value) {
        if (matchingAttributes[0]) {
          const attribute = attrs[matchingAttributes[0]];
          const isRef = (attribute == null ? void 0 : attribute.type) === 5;
          if (isRef) {
            checks.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value.parameter,
              pass: this.cardinality === "prohibited"
            });
          } else {
            this.evalRequirement(
              attribute ? attribute.value : null,
              this.value,
              "Value",
              checks
            );
          }
        } else {
          checks.push({
            parameter: "Value",
            currentValue: null,
            requiredValue: this.value.parameter,
            pass: this.cardinality === "prohibited"
          });
        }
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
};
var IDSClassification = class extends IDSFacet {
  constructor(components, system) {
    super(components);
    __publicField(this, "facetType", "Classification");
    __publicField(this, "system");
    __publicField(this, "value");
    __publicField(this, "uri");
    this.system = system;
  }
  serialize(type) {
    const systemXML = getParameterXML("System", this.system);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<classification ${attributes}>
  ${systemXML}
  ${valueXML}
</classification>`;
  }
  async getEntities(model, collector = {}) {
    var _a22;
    const result = [];
    const references = await model.getAllPropertiesOfType(
      IFCCLASSIFICATIONREFERENCE
    );
    const classifications = await model.getAllPropertiesOfType(
      IFCCLASSIFICATION
    );
    const systems = { ...references, ...classifications };
    const matchingClassifications = [];
    for (const id in systems) {
      const classificationID = Number(id);
      const attrs = await model.getProperties(classificationID);
      if (!attrs)
        continue;
      const referencedSourceID = (_a22 = attrs.ReferencedSource) == null ? void 0 : _a22.value;
      if (!referencedSourceID)
        continue;
      const classificationAttrs = await model.getProperties(referencedSourceID);
      if (!classificationAttrs)
        continue;
      const systemMatches = this.evalSystem(classificationAttrs);
      if (!systemMatches)
        continue;
      const valueMatches = this.evalValue(attrs);
      if (!valueMatches)
        continue;
      const uriMatches = this.evalURI(attrs);
      if (!uriMatches)
        continue;
      matchingClassifications.push(classificationID);
    }
    const indexer = this.components.get(IfcRelationsIndexer);
    for (const classificationID of matchingClassifications) {
      const expressIDs = indexer.getEntitiesWithRelation(
        model,
        "HasAssociations",
        classificationID
      );
      for (const expressID of expressIDs) {
        if (expressID in collector)
          continue;
        const attrs = await model.getProperties(expressID);
        if (!attrs)
          continue;
        collector[expressID] = attrs;
        result.push(expressID);
      }
    }
    return result;
  }
  async test(entities, model) {
    var _a22;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a22 = attrs.GlobalId) == null ? void 0 : _a22.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      let missingClassification = true;
      const elementClassifications = await this.getSystems(model, expressID);
      const allSystemNames = elementClassifications.map((classification) => this.getSystemName(classification)).filter((system) => system);
      for (const classificationAttrs of elementClassifications) {
        const systemMatches = this.evalSystem(classificationAttrs, checks);
        if (!systemMatches)
          continue;
        missingClassification = false;
        if (!(this.value && this.system))
          break;
        if (classificationAttrs.type !== IFCCLASSIFICATIONREFERENCE) {
          continue;
        }
        const valueMatches = !this.value || this.evalValue(classificationAttrs, checks);
        const uriMatches = !this.uri || this.evalURI(classificationAttrs, checks);
        if (valueMatches && uriMatches)
          break;
      }
      if (missingClassification) {
        this.addCheckResult(
          {
            parameter: "System",
            currentValue: allSystemNames,
            requiredValue: this.system,
            pass: this.cardinality === "optional"
          },
          checks
        );
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
  async processReferencedSource(model, attrs) {
    var _a22;
    const sourceID = (_a22 = attrs.ReferencedSource) == null ? void 0 : _a22.value;
    if (!sourceID)
      return null;
    const sourceAttrs = await model.getProperties(sourceID);
    if (!sourceAttrs)
      return null;
    if (sourceAttrs.type === IFCCLASSIFICATIONREFERENCE) {
      sourceAttrs.ReferencedSource = await this.processReferencedSource(
        model,
        sourceAttrs
      );
    }
    return sourceAttrs;
  }
  async getSystems(model, expressID) {
    var _a22;
    const result = [];
    const indexer = this.components.get(IfcRelationsIndexer);
    const ocurrenceAssociations = indexer.getEntityRelations(
      model,
      expressID,
      "HasAssociations"
    );
    if (ocurrenceAssociations) {
      for (const id of ocurrenceAssociations) {
        const attrs = await model.getProperties(id);
        if (!attrs)
          continue;
        if (attrs.type === IFCCLASSIFICATION) {
          result.push(attrs);
        }
        if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
          attrs.ReferencedSource = await this.processReferencedSource(
            model,
            attrs
          );
          if (attrs.ReferencedSource)
            result.push(attrs);
        }
      }
    }
    const occurrenceSystems = result.map((attrs) => {
      var _a3, _b, _c2;
      if (attrs.type === IFCCLASSIFICATION) {
        return (_a3 = attrs.Name) == null ? void 0 : _a3.value;
      }
      if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
        return (_c2 = (_b = attrs.ReferencedSource) == null ? void 0 : _b.Name) == null ? void 0 : _c2.value;
      }
      return null;
    }).filter((name) => name);
    const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
    if (!(types && types[0]))
      return result;
    const type = types[0];
    const typeAssociations = indexer.getEntityRelations(
      model,
      type,
      "HasAssociations"
    );
    if (typeAssociations) {
      for (const id of typeAssociations) {
        const attrs = await model.getProperties(id);
        if (!attrs)
          continue;
        if (attrs.type === IFCCLASSIFICATION) {
          if (occurrenceSystems.includes((_a22 = attrs.Name) == null ? void 0 : _a22.value))
            continue;
          result.push(attrs);
        }
        if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
          attrs.ReferencedSource = await this.processReferencedSource(
            model,
            attrs
          );
          if (attrs.ReferencedSource)
            result.push(attrs);
        }
      }
    }
    return result;
  }
  getSystemName(attrs) {
    var _a22, _b, _c2, _d;
    if (attrs.type === IFCCLASSIFICATION) {
      return (_a22 = attrs.Name) == null ? void 0 : _a22.value;
    }
    if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
      if (((_b = attrs.ReferencedSource) == null ? void 0 : _b.type) === IFCCLASSIFICATIONREFERENCE) {
        return this.getSystemName(attrs.ReferencedSource);
      }
      if (((_c2 = attrs.ReferencedSource) == null ? void 0 : _c2.type) === IFCCLASSIFICATION) {
        return (_d = attrs.ReferencedSource.Name) == null ? void 0 : _d.value;
      }
    }
    return null;
  }
  getAllReferenceIdentifications(attrs) {
    if (attrs.type !== IFCCLASSIFICATIONREFERENCE)
      return null;
    const identifications = [];
    if (attrs.Identification)
      identifications.push(attrs.Identification.value);
    if (attrs.ReferencedSource) {
      const identification = this.getAllReferenceIdentifications(
        attrs.ReferencedSource
      );
      if (identification)
        identifications.push(...identification);
    }
    return identifications;
  }
  evalSystem(attrs, checks) {
    const name = this.getSystemName(attrs);
    return this.evalRequirement(name, this.system, "System", checks);
  }
  evalValue(attrs, checks) {
    if (!this.value)
      return true;
    const identifications = this.getAllReferenceIdentifications(attrs);
    if (!identifications)
      return false;
    const identifier = identifications.find((id) => {
      if (!this.value)
        return false;
      return this.evalRequirement(id, this.value, "Value");
    });
    if (checks) {
      this.addCheckResult(
        {
          parameter: "Value",
          currentValue: identifier ?? null,
          requiredValue: this.value,
          pass: !!identifier
        },
        checks
      );
    }
    return !!identifier;
  }
  evalURI(attrs, checks) {
    var _a22;
    if (!this.uri)
      return true;
    const result = this.evalRequirement(
      (_a22 = attrs.Location) == null ? void 0 : _a22.value,
      {
        type: "simple",
        parameter: this.uri
      },
      "URI",
      checks
    );
    return result;
  }
};
var IDSEntity = class extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField(this, "facetType", "Entity");
    __publicField(this, "name");
    __publicField(this, "predefinedType");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const predefinedTypeXML = getParameterXML("Name", this.predefinedType);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<entity ${attributes}>
  ${nameXML}
  ${predefinedTypeXML}
</entity>`;
  }
  // IFCSURFACESTYLEREFRACTION is not present in the FragmentsGroup
  // IFCSURFACESTYLERENDERING is not present in the FragmentsGroup
  async getEntities(model, collector = {}) {
    const types = Object.entries(IfcCategoryMap);
    const typeIDs = [];
    for (const [type] of types) {
      const validName = await this.evalName({ type });
      if (!validName)
        continue;
      typeIDs.push(Number(type));
    }
    let entities = {};
    for (const id of typeIDs) {
      const elements = await model.getAllPropertiesOfType(id);
      if (elements)
        entities = { ...entities, ...elements };
    }
    if (!this.predefinedType) {
      for (const expressID in entities) {
        if (expressID in collector)
          continue;
        collector[expressID] = entities[expressID];
      }
      return Object.keys(entities).map(Number);
    }
    const result = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      if (expressID in collector)
        continue;
      const attrs = entities[expressID];
      const validPredefinedType = await this.evalPredefinedType(model, attrs);
      if (validPredefinedType) {
        collector[expressID] = attrs;
        result.push(expressID);
      }
    }
    return result;
  }
  async test(entities, model) {
    var _a22;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result = {
        guid: (_a22 = attrs.GlobalId) == null ? void 0 : _a22.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result);
      await this.evalName(attrs, checks);
      await this.evalPredefinedType(model, attrs, checks);
      result.pass = checks.every(({ pass }) => pass);
    }
    return this.testResult;
  }
  async evalName(attrs, checks) {
    const entityName2 = IfcCategoryMap[attrs.type];
    const result = this.evalRequirement(entityName2, this.name, "Name", checks);
    return result;
  }
  async evalPredefinedType(model, attrs, checks) {
    var _a22, _b, _c2, _d;
    if (!this.predefinedType)
      return null;
    const indexer = this.components.get(IfcRelationsIndexer);
    const isRequirementUserDefined = typeof this.predefinedType.parameter === "string" && this.predefinedType.parameter === "USERDEFINED";
    let value = (_a22 = attrs.PredefinedType) == null ? void 0 : _a22.value;
    if (value === "USERDEFINED" && !isRequirementUserDefined) {
      const attrNames = Object.keys(attrs);
      const result2 = attrNames.find(
        (str) => /^((?!Predefined).)*Type$/.test(str)
      );
      value = result2 ? (_b = attrs[result2]) == null ? void 0 : _b.value : "USERDEFINED";
    }
    if (!value) {
      const types = indexer.getEntityRelations(
        model,
        attrs.expressID,
        "IsTypedBy"
      );
      if (types && types[0]) {
        const typeAttrs = await model.getProperties(types[0]);
        if (typeAttrs) {
          value = (_c2 = typeAttrs.PredefinedType) == null ? void 0 : _c2.value;
          if (value === "USERDEFINED" && !isRequirementUserDefined) {
            const attrNames = Object.keys(typeAttrs);
            const result2 = attrNames.find(
              (str) => /^((?!Predefined).)*Type$/.test(str)
            );
            value = result2 ? (_d = typeAttrs[result2]) == null ? void 0 : _d.value : "USERDEFINED";
          }
        }
      }
    }
    const result = this.evalRequirement(
      value,
      this.predefinedType,
      "PredefinedType",
      checks
    );
    return result;
  }
};
var IDSProperty = class extends IDSFacet {
  constructor(components, propertySet, baseName) {
    super(components);
    __publicField(this, "facetType", "Property");
    __publicField(this, "propertySet");
    __publicField(this, "baseName");
    __publicField(this, "value");
    __publicField(this, "dataType");
    __publicField(this, "uri");
    __publicField(this, "_unsupportedTypes", [
      IFCCOMPLEXPROPERTY,
      IFCPHYSICALCOMPLEXQUANTITY
    ]);
    this.propertySet = propertySet;
    this.baseName = baseName;
  }
  serialize(type) {
    const propertySetXML = getParameterXML("PropertySet", this.propertySet);
    const baseNameXML = getParameterXML("BaseName", this.baseName);
    const valueXML = getParameterXML("Value", this.value);
    const dataTypeXML = this.dataType ? `dataType=${this.dataType}` : "";
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<property ${dataTypeXML} ${attributes}>
  ${propertySetXML}
  ${baseNameXML}
  ${valueXML}
</property>`;
  }
  async getEntities(model, collector = {}) {
    var _a22, _b;
    let sets = {};
    const psets = await model.getAllPropertiesOfType(IFCPROPERTYSET);
    sets = { ...sets, ...psets };
    const qsets = await model.getAllPropertiesOfType(IFCELEMENTQUANTITY);
    sets = { ...sets, ...qsets };
    if (Object.keys(sets).length === 0)
      return [];
    const matchingSets = [];
    for (const _setID in sets) {
      const setID = Number(_setID);
      const attrs = await model.getProperties(setID);
      if (!attrs)
        continue;
      const nameMatches = ((_a22 = attrs.Name) == null ? void 0 : _a22.value) === this.propertySet.parameter;
      if (!nameMatches)
        continue;
      let propsListName;
      if (attrs.type === IFCPROPERTYSET)
        propsListName = "HasProperties";
      if (attrs.type === IFCELEMENTQUANTITY)
        propsListName = "Quantities";
      if (!propsListName)
        continue;
      for (const handle of attrs[propsListName]) {
        const propAttrs = await model.getProperties(handle.value);
        if (!propAttrs)
          continue;
        const propNameMatches = ((_b = propAttrs.Name) == null ? void 0 : _b.value) === this.baseName.parameter;
        if (!propNameMatches)
          continue;
        if (this.value) {
          const valueKey = Object.keys(propAttrs).find(
            (name) => name.endsWith("Value")
          );
          if (!valueKey)
            continue;
          const valueMatches = propAttrs[valueKey].value === this.value.parameter;
          if (!valueMatches)
            continue;
        }
        matchingSets.push(setID);
      }
    }
    const indexer = this.components.get(IfcRelationsIndexer);
    for (const setID of matchingSets) {
      const expressIDs = indexer.getEntitiesWithRelation(
        model,
        "IsDefinedBy",
        setID
      );
      for (const expressID of expressIDs) {
        if (expressID in collector)
          continue;
        const attrs = await model.getProperties(expressID);
        if (!attrs)
          continue;
        collector[expressID] = attrs;
      }
    }
    return [];
  }
  async test(entities, model) {
    var _a22;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a22 = attrs.GlobalId) == null ? void 0 : _a22.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      const sets = await this.getPsets(model, expressID);
      const matchingSets = sets.filter((set) => {
        const result3 = this.evalRequirement(
          set.Name ?? null,
          this.propertySet,
          "PropertySet"
        );
        if (!result3)
          return false;
        checks.push({
          currentValue: set.Name,
          parameter: "PropertySet",
          pass: true,
          requiredValue: this.propertySet.parameter
        });
        return true;
      });
      if (matchingSets.length === 0) {
        checks.push({
          currentValue: null,
          parameter: "PropertySet",
          pass: false,
          requiredValue: this.propertySet.parameter
        });
        continue;
      }
      for (const set of matchingSets) {
        if (!("Properties" in set)) {
          checks.push({
            currentValue: null,
            parameter: "BaseName",
            pass: false,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        const items = set.Properties;
        const matchingItems = items.filter((item) => {
          var _a3;
          if (this._unsupportedTypes.includes(item.type)) {
            return false;
          }
          const result3 = this.evalRequirement(
            ((_a3 = item.Name) == null ? void 0 : _a3.value) ?? null,
            this.baseName,
            "BaseName"
          );
          if (!result3)
            return false;
          checks.push({
            currentValue: item.Name.value,
            parameter: "BaseName",
            pass: true,
            requiredValue: this.baseName.parameter
          });
          return true;
        });
        if (matchingItems.length === 0) {
          checks.push({
            currentValue: null,
            parameter: "BaseName",
            pass: false,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        for (const item of matchingItems) {
          this.evalValue(item, checks);
          this.evalDataType(item, checks);
          this.evalURI();
        }
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
  getItemsAttrName(type) {
    let propsListName;
    if (type === IFCPROPERTYSET)
      propsListName = "HasProperties";
    if (type === IFCELEMENTQUANTITY)
      propsListName = "Quantities";
    return propsListName;
  }
  getValueKey(attrs) {
    return Object.keys(attrs).find(
      (name) => name.endsWith("Value") || name.endsWith("Values")
    );
  }
  async simplifyPset(model, attrs, propsListName) {
    var _a22;
    const props = [];
    const list = attrs[propsListName];
    if (!list)
      return attrs;
    for (const { value } of list) {
      const propAttrs = await model.getProperties(value);
      if (propAttrs)
        props.push(propAttrs);
    }
    const attrsClone = {
      Name: (_a22 = attrs.Name) == null ? void 0 : _a22.value,
      Properties: props,
      type: attrs.type
    };
    return attrsClone;
  }
  async getTypePsets(model, expressID) {
    const sets = [];
    const indexer = this.components.get(IfcRelationsIndexer);
    const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
    if (!(types && types[0]))
      return sets;
    const typeAttrs = await model.getProperties(types[0]);
    if (!(typeAttrs && "HasPropertySets" in typeAttrs && Array.isArray(typeAttrs.HasPropertySets))) {
      return sets;
    }
    for (const { value } of typeAttrs.HasPropertySets) {
      const psetAttrs = await model.getProperties(value);
      if (!(psetAttrs && "HasProperties" in psetAttrs && Array.isArray(psetAttrs.HasProperties))) {
        continue;
      }
      const pset = await this.simplifyPset(model, psetAttrs, "HasProperties");
      sets.push(pset);
    }
    return sets;
  }
  async getPsets(model, expressID) {
    var _a22;
    const typePsets = await this.getTypePsets(model, expressID);
    const indexer = this.components.get(IfcRelationsIndexer);
    const definitions = indexer.getEntityRelations(
      model,
      expressID,
      "IsDefinedBy"
    );
    if (!definitions)
      return typePsets;
    const sets = [];
    for (const definitionID of definitions) {
      const attrs = await model.getProperties(definitionID);
      if (!attrs)
        continue;
      const propsListName = this.getItemsAttrName(attrs.type);
      if (!propsListName)
        continue;
      const occurencePset = await this.simplifyPset(
        model,
        attrs,
        propsListName
      );
      const typePset = typePsets.find(
        ({ Name }) => Name === occurencePset.Name
      );
      if (typePset) {
        for (const prop of typePset.Properties) {
          const name = (_a22 = prop.Name) == null ? void 0 : _a22.value;
          const existingProp = occurencePset.Properties.find(
            ({ Name }) => Name.value === name
          );
          if (!existingProp)
            occurencePset.Properties.push(prop);
        }
      }
      sets.push(occurencePset);
    }
    return sets;
  }
  // IFCPROPERTYBOUNDEDVALUE are not supported yet
  // IFCPROPERTYTABLEVALUE are not supported yet
  // Work must to be done to convert numerical value units to IDS-nominated standard units https://github.com/buildingSMART/IDS/blob/development/Documentation/UserManual/units.md
  evalValue(attrs, checks) {
    const valueKey = this.getValueKey(attrs);
    const valueAttr = attrs[valueKey];
    if (this.value) {
      if (!valueAttr) {
        checks == null ? void 0 : checks.push({
          parameter: "Value",
          currentValue: null,
          pass: false,
          requiredValue: this.value.parameter
        });
        return false;
      }
      const facetValue = structuredClone(this.value);
      if (valueAttr.name === "IFCLABEL" && facetValue.type === "simple") {
        facetValue.parameter = String(facetValue.parameter);
      }
      if ((attrs.type === IFCPROPERTYLISTVALUE || attrs.type === IFCPROPERTYENUMERATEDVALUE) && Array.isArray(valueAttr)) {
        const values = valueAttr.map((value) => value.value);
        const matchingValue = valueAttr.find((value) => {
          if (!facetValue)
            return false;
          return this.evalRequirement(value.value, facetValue, "Value");
        });
        checks == null ? void 0 : checks.push({
          currentValue: values,
          pass: !!matchingValue,
          parameter: "Value",
          requiredValue: facetValue.parameter
        });
        return !!matchingValue;
      }
      const result = this.evalRequirement(
        valueAttr.value,
        facetValue,
        "Value",
        checks
      );
      return result;
    }
    if (!valueKey)
      return true;
    if (valueAttr.type === 3 && valueAttr.value === 2) {
      checks == null ? void 0 : checks.push({
        parameter: "Value",
        currentValue: null,
        pass: false,
        requiredValue: null
      });
      return false;
    }
    if (valueAttr.type === 1 && valueAttr.value.trim() === "") {
      checks == null ? void 0 : checks.push({
        parameter: "Value",
        currentValue: "",
        pass: false,
        requiredValue: null
      });
      return false;
    }
    return true;
  }
  evalDataType(attrs, checks) {
    if (!this.dataType)
      return true;
    const valueKey = this.getValueKey(attrs);
    const valueAttr = attrs[valueKey];
    if (!valueAttr) {
      checks == null ? void 0 : checks.push({
        parameter: "DataType",
        currentValue: null,
        pass: false,
        requiredValue: this.dataType
      });
      return false;
    }
    if ((attrs.type === IFCPROPERTYLISTVALUE || attrs.type === IFCPROPERTYENUMERATEDVALUE) && Array.isArray(valueAttr) && valueAttr[0]) {
      const valueType = valueAttr[0].name;
      const result2 = this.evalRequirement(
        valueType,
        {
          type: "simple",
          parameter: this.dataType
        },
        "DataType",
        checks
      );
      return result2;
    }
    const result = this.evalRequirement(
      valueAttr.name,
      {
        type: "simple",
        parameter: this.dataType
      },
      "DataType",
      checks
    );
    return result;
  }
  evalURI() {
    return true;
  }
};
var IDSSpecification = class {
  constructor(components, name, ifcVersion) {
    __publicField(this, "name");
    __publicField(this, "ifcVersion", /* @__PURE__ */ new Set());
    __publicField(this, "identifier", UUID.create());
    __publicField(this, "description");
    __publicField(this, "instructions");
    __publicField(this, "requirementsDescription");
    __publicField(this, "applicability", new DataSet());
    __publicField(this, "requirements", new DataSet());
    __publicField(this, "components");
    this.components = components;
    this.name = name;
    for (const version of ifcVersion) {
      this.ifcVersion.add(version);
    }
  }
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "identifier")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this.components.get(IDSSpecifications);
    manager.list.set(this.identifier, this);
    return this;
  }
  /**
   * Tests the model to test against the specification's requirements.
   *
   * @param model - The model to be tested.
   * @returns An array representing the test results.
   * If no requirements are defined for the specification, an empty array is returned.
   */
  async test(model) {
    let result = [];
    if (this.requirements.size === 0)
      return result;
    const entities = {};
    for (const facet of this.applicability) {
      await facet.getEntities(model, entities);
    }
    const requirement = [...this.requirements][0];
    result = await requirement.test(entities, model);
    return result;
  }
  /**
   * Serializes the IDSSpecification instance into XML format.
   *
   * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
   *
   * @returns The XML representation of the IDSSpecification.
   */
  serialize() {
    const name = `name="${this.name}"`;
    const identifier = this.identifier ? `identifier="${this.identifier}"` : "";
    const description = this.description ? `description="${this.description}"` : "";
    const instructions = this.instructions ? `instructions="${this.instructions}"` : "";
    const xml = `<specification ifcVersion="${[...this.ifcVersion].join(" ")}" ${name} ${identifier} ${description} ${instructions}>
      <applicability minOccurs="1" maxOccurs="unbounded">
        ${[...this.applicability].map((facet) => facet.serialize("applicability")).join("\n")}
      </applicability>
      <requirements>
        ${[...this.requirements].map((facet) => facet.serialize("requirement")).join("\n")}
      </requirements>
    </specification>`;
    return xml;
  }
};
var getParameterValue = (property) => {
  if (!property)
    return void 0;
  const result = {};
  if ("simpleValue" in property) {
    result.type = "simple";
    result.parameter = property.simpleValue;
  }
  if ("restriction" in property) {
    const restriction = property.restriction;
    if ("pattern" in restriction) {
      result.type = "pattern";
      result.parameter = restriction.pattern.value;
    }
    if ("enumeration" in restriction) {
      result.type = "enumeration";
      const enumeration = restriction.enumeration.map(
        ({ value }) => value
      );
      result.parameter = enumeration;
    }
  }
  if (result.parameter === void 0)
    return void 0;
  return result;
};
var createEntityFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSEntity(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.predefinedType = getParameterValue(element.predefinedType);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createAttributeFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSAttribute(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.value = getParameterValue(element.value);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createClassificationFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const systemParameter = element.system;
    const system = getParameterValue(systemParameter);
    if (!system)
      continue;
    const facet = new IDSClassification(components, system);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "simple") {
      value.parameter = String(value.parameter);
    }
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createPropertyFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const psetParameter = element.propertySet;
    const baseNameParameter = element.baseName;
    const pset = getParameterValue(psetParameter);
    const baseName = getParameterValue(baseNameParameter);
    if (!(baseName && pset))
      continue;
    const facet = new IDSProperty(components, pset, baseName);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.dataType = element.dataType;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var _IDSSpecifications = class _IDSSpecifications2 extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "list", new DataMap());
    components.add(_IDSSpecifications2.uuid, this);
  }
  /**
   * Retrieves a FragmentIdMap based on the given IDSCheckResult array.
   * The map separates the IDs into two categories: pass and fail.
   *
   * @param model - The FragmentsGroup model from which to retrieve the fragment map.
   * @param result - An array of IDSCheckResult objects, each representing a check result.
   *
   * @returns An object containing two properties:
   * - `pass`: A FragmentIdMap that passed the checks.
   * - `fail`: A FragmentIdMap that failed the checks.
   */
  getFragmentIdMap(model, result) {
    const passResults = result.filter((check) => check.pass);
    const passIDs = passResults.map((check) => check.expressID);
    const pass = model.getFragmentMap(passIDs);
    const failResults = result.filter((check) => !check.pass);
    const failIDs = failResults.map((check) => check.expressID);
    const fail = model.getFragmentMap(failIDs);
    return { pass, fail };
  }
  /**
   * Creates a new IDSSpecification instance and adds it to the list.
   *
   * @param name - The name of the IDSSpecification.
   * @param ifcVersion - An array of IfcVersion values that the specification supports.
   *
   * @returns The newly created IDSSpecification instance.
   */
  create(name, ifcVersion, identifier) {
    const specification = new IDSSpecification(
      this.components,
      name,
      ifcVersion
    );
    if (identifier)
      specification.identifier = identifier;
    this.list.set(specification.identifier, specification);
    return specification;
  }
  /**
   * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
   * It creates IDSSpecification instances based on the parsed data and returns them in an array.
   * Also, the instances are added to the list array.
   *
   * @param data - The XML string to parse.
   *
   * @returns An array of IDSSpecification instances created from the parsed data.
   */
  load(data) {
    const result = [];
    const ids = _IDSSpecifications2.xmlParser.parse(data).ids;
    const { specifications } = ids;
    if (specifications && specifications.specification) {
      const specs = Array.isArray(specifications.specification) ? specifications.specification : [specifications.specification];
      for (const spec of specs) {
        const { name, ifcVersion, description, instructions, identifier } = spec;
        if (!(name && ifcVersion))
          continue;
        const applicabilities = [];
        const reqs = [];
        const { applicability, requirements } = spec;
        if (applicability) {
          const { maxOccurs, ...rest } = applicability;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
            }
          }
        }
        let requirementsDescription;
        if (requirements) {
          const { maxOccurs, ...rest } = requirements;
          requirementsDescription = requirements.description;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "attribute") {
                const facets2 = createAttributeFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "classification") {
                const facets2 = createClassificationFacets(
                  this.components,
                  elements
                );
                reqs.push(...facets2);
              }
              if (facetName === "property") {
                const facets2 = createPropertyFacets(this.components, elements);
                reqs.push(...facets2);
              }
            }
          }
        }
        if (applicabilities.length > 0 && reqs.length > 0) {
          const specification = this.create(
            name,
            ifcVersion.split(/\s+/),
            identifier
          );
          specification.description = description;
          specification.instructions = instructions;
          specification.requirementsDescription = requirementsDescription;
          specification.applicability.add(...applicabilities);
          specification.requirements.add(...reqs);
          result.push(specification);
        }
      }
    }
    return result;
  }
  /**
   * Exports the IDSSpecifications data into an XML string.
   *
   * @param info - The metadata information for the exported XML.
   * @param specifications - An optional iterable of IDSSpecification instances to export.
   * If not provided, all specifications in the list will be exported.
   *
   * @returns A string containing the exported IDSSpecifications data in XML format.
   */
  export(info, specifications = this.list.values()) {
    const _specifications = specifications ?? this.list;
    const xml = `<ids xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://standards.buildingsmart.org/IDS http://standards.buildingsmart.org/IDS/1.0/ids.xsd" xmlns:ids="http://standards.buildingsmart.org/IDS">
  <!-- Made with That Open Engine ${Components.release} (https://github.com/thatopen/engine_components) -->
  <info>
    <title>${info.title}</title>
    ${info.copyright ? `<copyright>${info.copyright}</copyright>` : ""}
    ${info.version ? `<version>${info.version}</version>` : ""}
    ${info.description ? `<description>${info.description}</description>` : ""}
    ${info.author ? `<author>${info.author}</author>` : ""}
    ${info.date ? `<date>${info.date.toISOString().split("T")[0]}</date>` : ""}
    ${info.purpose ? `<purpose>${info.purpose}</purpose>` : ""}
    ${info.milestone ? `<milestone>${info.milestone}</milestone>` : ""}
  </info>
  <specifications>
    ${[..._specifications].map((spec) => spec.serialize()).join("\n")}
  </specifications>
</ids>`;
    return xml;
  }
};
__publicField(_IDSSpecifications, "uuid", "9f0b9f78-9b2e-481a-b766-2fbfd01f342c");
__publicField(_IDSSpecifications, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var IDSSpecifications = _IDSSpecifications;
export {
  AsyncEvent,
  BCFTopics,
  BCFTopicsConfigManager,
  Base,
  BaseCamera,
  BaseRenderer,
  BaseScene,
  BaseWorldItem,
  BoundingBoxer,
  Classifier,
  Clipper,
  Comment,
  Component,
  ComponentWithUI,
  Components,
  ConfigManager,
  Configurator,
  ControlsUtils,
  CullerRenderer,
  Cullers,
  DataMap,
  DataSet,
  Disposer,
  Event,
  EventManager,
  Exploder,
  FirstPersonMode,
  FragmentsManager,
  GeometryTypes,
  Grids,
  Hider,
  IDSAttribute,
  IDSClassification,
  IDSEntity,
  IDSFacet,
  IDSProperty,
  IDSSpecification,
  IDSSpecifications,
  IfcBasicQuery,
  IfcCategories,
  IfcCategoryMap,
  IfcElements,
  IfcFinder,
  IfcFinderQuery,
  IfcFragmentSettings,
  IfcGeometryTiler,
  IfcIsolator,
  IfcJsonExporter,
  IfcLoader,
  IfcPropertiesManager,
  IfcPropertiesTiler,
  IfcPropertiesUtils,
  IfcPropertyQuery,
  IfcRelationsIndexer,
  IfcStreamingSettings,
  MaterialsUtils,
  MeasurementUtils,
  MeshCullerRenderer,
  MiniMap,
  MiniMapConfigManager,
  MiniMaps,
  Mouse,
  OrbitMode,
  OrthoPerspectiveCamera,
  PlanMode,
  ProjectionManager,
  PropertiesStreamingSettings,
  Raycasters,
  SectionGenerator,
  ShadowedScene,
  SimpleCamera,
  SimpleGrid,
  SimpleGridConfigManager,
  SimplePlane,
  SimpleRaycaster,
  SimpleRenderer,
  SimpleScene,
  SimpleSceneConfigManager,
  SimpleWorld,
  Topic,
  UUID,
  VertexPicker,
  Viewpoint,
  Viewpoints,
  Worlds,
  extensionsImporter,
  ifcCategoryCase,
  ifcRelAttrsPosition,
  ifcRelClassNames,
  isPointInFrontOfPlane,
  obbFromPoints,
  readPixelsAsync,
  relToAttributesMap
};
/*! Bundled license information:

@thatopen/fragments/dist/index.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

@thatopen/components/dist/index.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=@thatopen_components.js.map
